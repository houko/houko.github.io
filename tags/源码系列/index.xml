<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>源码系列 on 小莫的博客-fighting(技术分享、生活随笔)</title><link>https://blog.xiaomo.info/tags/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/</link><description>Recent content in 源码系列 on 小莫的博客-fighting(技术分享、生活随笔)</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>@Copyright 2023</copyright><lastBuildDate>Mon, 05 Aug 2019 00:00:00 +0900</lastBuildDate><atom:link href="https://blog.xiaomo.info/tags/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/index.xml" rel="self" type="application/rss+xml"/><item><title>jdk源码系列-Java到底是值传递还是引用传递？</title><link>https://blog.xiaomo.info/2019/javapassbyvalueandreference/</link><pubDate>Mon, 05 Aug 2019 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2019/javapassbyvalueandreference/</guid><description>首先，不要纠结于 Pass By Value 和 Pass By Reference 的字面上的意义，否则很容易陷入所谓的“一切传引用其实本质上是传值”这种并不能解决问题无意义论战中。更何况，要想</description></item><item><title>jdk源码系列-Thread.sleep(0)和Thread.sleep(1)的区别</title><link>https://blog.xiaomo.info/2019/jdksourcecodereadthreadsleep/</link><pubDate>Mon, 22 Jul 2019 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2019/jdksourcecodereadthreadsleep/</guid><description>某人的代码中用了一句看似莫明其妙的话：Thread.Sleep(0) 。既然是 Sleep 0 毫秒，那么他跟去掉这句代码相比，有啥区别么？Thread.S</description></item><item><title>jdk源码系列-Java中ArrayList、LinkedList和Vector的联系与区别</title><link>https://blog.xiaomo.info/2018/jdksourcecodereadarraylistandlinkedarraylist/</link><pubDate>Mon, 11 Jun 2018 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2018/jdksourcecodereadarraylistandlinkedarraylist/</guid><description>毫无疑问，List是一种非常基础的数据结构，翻译过来就是列表。正如它的名字所示，List表示的是一个有序(插入顺序)的元素序列。在Java的</description></item><item><title>jdk源码系列-String,StringBuffer,StringBuilder</title><link>https://blog.xiaomo.info/2018/jdksourcecodereadstringdifferent/</link><pubDate>Sat, 09 Jun 2018 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2018/jdksourcecodereadstringdifferent/</guid><description>String,StringBuilder以及StringBuffer这三个类之间有什么区别? 这三个类之间的区别主要是在两个方面，即运行速度和</description></item><item><title>jdk源码系列-创建对象</title><link>https://blog.xiaomo.info/2018/jdksourcecodereadcreateobject/</link><pubDate>Sat, 09 Jun 2018 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2018/jdksourcecodereadcreateobject/</guid><description>String str=new String(&amp;quot;abc&amp;quot;);到底创建了几个对象？相信大家对这此并不陌生，答案也是众所周知的，2个。接下来我们就从这道</description></item><item><title>jdk源码系列-类的初始化顺序</title><link>https://blog.xiaomo.info/2018/jdksourcecodereadclassinitorder/</link><pubDate>Sat, 09 Jun 2018 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2018/jdksourcecodereadclassinitorder/</guid><description>大家在去参加面试的时候，经常会遇到这样的考题：给你两个类的代码，它们之间是继承的关系，每个类里只有构造器方法和一些变量，构造器里可能还有一段</description></item><item><title>jdk源码系列-AtomicInteger</title><link>https://blog.xiaomo.info/2018/jdksourcecodereadatomicinteger/</link><pubDate>Sat, 02 Jun 2018 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2018/jdksourcecodereadatomicinteger/</guid><description>JDK 里面提供的以 Atomic* 开头的类基本原理都是一致的， 都是借助了底层硬件级别的 Lock 来实现原子操作的。 本文以 AtomicInteger 为例进行讲述， 其他的类似。阅读本文前建议先阅</description></item><item><title>jdk源码系列-ConcurrentHashMap</title><link>https://blog.xiaomo.info/2018/jdksourcecodereadconcurrenthashmap/</link><pubDate>Sat, 02 Jun 2018 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2018/jdksourcecodereadconcurrenthashmap/</guid><description>ConcurrentHashMap 是将锁的范围细化来实现高效并发的。 基本策略是将数据结构分为一个一个 Segment（每一个都是一个并发可读的 hash table， 即分段锁）作为一个</description></item><item><title>jdk源码系列-Integer</title><link>https://blog.xiaomo.info/2018/jdksourcecodereadinteger/</link><pubDate>Sat, 02 Jun 2018 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2018/jdksourcecodereadinteger/</guid><description>对于 Integer 这个 Java 程序员几乎天天使用的类,使用上却可以看出普通程序员和优秀程序员区别。 深入代码 在创建数字 1 的对象时， 大多数人会使用 new Integer</description></item><item><title>jdk源码系列-ThreadLocal</title><link>https://blog.xiaomo.info/2018/jdksourcecodereadthreadlocal/</link><pubDate>Sat, 02 Jun 2018 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2018/jdksourcecodereadthreadlocal/</guid><description>这个类提供本地线程变量。不同于一般的变量，这些变量在他们各自的线程里通过 get、set 访问一个它自己的变量，这是一个独立初始化的变量副本。在</description></item><item><title>jdk源码系列-内存模型</title><link>https://blog.xiaomo.info/2018/jdksourcecodereadmemoryactor/</link><pubDate>Sat, 02 Jun 2018 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2018/jdksourcecodereadmemoryactor/</guid><description>为了让程序员忽略掉各种硬件和操作系统的内存访问差异， 也既无需关心不同架构上内存模型的差异， Java 在代码和硬件内存模型间又提供了一个 Java 内存模型。 并</description></item><item><title>jdk源码系列-深入了解IO的工作机制</title><link>https://blog.xiaomo.info/2018/jdksourcecodereadio/</link><pubDate>Sat, 02 Jun 2018 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2018/jdksourcecodereadio/</guid><description>I/O 问题是任何编程语言都无法回避的问题，可以说 I/O 问题是整个人机交互的核心问题，因为 I/O 是机器获取和交换信息的主要渠道。在当今这个数据大爆炸时代，</description></item><item><title>jdk源码系列-线程池</title><link>https://blog.xiaomo.info/2018/jdksourcecodereadthreadpool/</link><pubDate>Sat, 02 Jun 2018 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2018/jdksourcecodereadthreadpool/</guid><description>Executors 是 Executor、ExecutorService、ThreadFactory、Callable 类的工厂和工具方法。 创建一个固定大小的线程</description></item><item><title>jdk源码系列-Object</title><link>https://blog.xiaomo.info/2018/jdksourcecodereadobject/</link><pubDate>Fri, 01 Jun 2018 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2018/jdksourcecodereadobject/</guid><description>Object类是类层次结构的根，是每一个类的父类。所有的对象（包括数组）都是实现了object类的方法。 Object结构 这里有7个nativ</description></item><item><title>jdk源码系列-NIO</title><link>https://blog.xiaomo.info/2018/jdksourcecodereadnio/</link><pubDate>Thu, 31 May 2018 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2018/jdksourcecodereadnio/</guid><description>Java NIO和IO之间第一个区别是， IO是面向流的， NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节， 直至读取所有字节， 它们没</description></item><item><title>jdk源码系列-throwable和Exception的区别</title><link>https://blog.xiaomo.info/2018/throwableandexception/</link><pubDate>Tue, 29 May 2018 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2018/throwableandexception/</guid><description>在写代码的时候Exception随手就来，但是提到Throwable总觉得又熟悉又陌生。 先上图为敬 从上图可以看出,throwable是Exc</description></item><item><title>jdk源码系列-顺序索引</title><link>https://blog.xiaomo.info/2018/jdksourcecoderead/</link><pubDate>Fri, 25 May 2018 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2018/jdksourcecoderead/</guid><description>很多java开发的小伙伴都会阅读jdk源码，然而确不知道应该从哪读起。以下为通常所需阅读的源码范围。 标题为包名，后面序号为优先级1-4，优先</description></item></channel></rss>