---
author: 小莫
date: 2017-03-07
title: 关于对象的一些思考
tags:
- java
category: java
permalink: AboutObject
---
《thinking jn java》被公认为java界的圣经，没有拜读过《thinking jn java》，谈不上算是合格的java程序员。怀着这份敬畏，我开始了 thinking in java.
<!-- more -->

### 对象有自己的特性和行为。
1. 所有的东西都是对象。可将对象想象成一种新型变量；它保存着数据，但可要求它对自身进行操作。理论上讲，可从要解决的问题身上提出所有概念性的组件，然后在程序中将其表达为一个对象。
2. 程序是一大堆对象的组合；通过消息传递，各对象知道自己该做什么。为了向对象发出请求，需向那个对象“发送一个消息”。更具体的讲，可将消息想象为一个调用请求，它调用的是从属于目标对象的一个子例程或函数。
3. 每个对象都有自己的存储宽间，可容纳其他对象。或者说，通过封装现有对象，可制作出新型对象。所以，尽管对象的概念都非常简单，但是在程序中却可达到任意高的复杂程度。
4. 每个对象都有一种类型。根据语法， 每个对象都某个“类“的一个”实例“。其中，"类"(class)是"类型"（type)的同义词。一个类最重要的特性就是”能将什么消息发给它？“
5. 同一类所有对象都能接收相同的消息。这实际是别有含义的一种说法。由于类型为Circle的一个对象也属于类型为Shape的一个对象，所以一个圆能完全接收形状消息。这意味着可让程序代码统一指挥形状，令其自动控制所有符合形状描述的对象，其中自然包括圆。这一特性称为对象的可替换性，是OOP最重要的概念之一。

### 数据存在哪
程序运行时,我们最好对数据保存到什么地方做到心中有数。特别要注意的是内存的分配。有六个地方都可以保存数据:

(1) 寄存器。
这是最快的保存区域,因为它位于和其他所有保存方式不同的地方:处理器内部。然而,寄存器的数量十分有限,所以寄存器是根据需要由编译器分配。我们对此没有直接的控制权,也不可能在自己的程序里找到寄存器存在的任何踪迹。

(2) 堆栈。
驻留于常规 RAM(随机访问存储器)区域,但可通过它的“堆栈指针”获得处理的直接支持。堆栈指针若向下移,会创建新的内存;若向上移,则会释放那些内存。这是一种特别快、特别有效的数据保存方式,仅次于寄存器。创建程序时,Java 编译器必须准确地知道堆栈内保存的所有数据的“长度”以及“存在时间”。这是由于它必须生成相应的代码,以便向上和向下移动指针。这一限制无疑影响了程序的灵活性,所以尽管有些 Java 数据要保存在堆栈里——特别是对象句柄,但 Java 对象并不放到其中。

(3) 堆。
一种常规用途的内存池(也在 RAM 区域),其中保存了 Java 对象。和堆栈不同,“内存堆”或“堆”(Heap)最吸引人的地方在于编译器不必知道要从堆里分配多少存储空间,也不必知道存储的数据要在堆里停留多长的时间。因此,用堆保存数据时会得到更大的灵活性。要求创建一个对象时,只需用 new 命令编制相关的代码即可。执行这些代码时,会在堆里自动进行数据的保存。当然,为达到这种灵活性,必然会付出一定的代价:在堆里分配存储空间时会花掉更长的时间!

(4) 静态存储。
这儿的“静态”(Static)是指“位于固定位置”(尽管也在 RAM 里)。程序运行期间,静态存储的数据将随时等候调用。可用 static 关键字指出一个对象的特定元素是静态的。但 Java 对象本身永远都不会置入静态存储空间。

(5) 常数存储。
常数值通常直接置于程序代码内部。这样做是安全的,因为它们永远都不会改变。有的常数需要严格地保护,所以可考虑将它们置入只读存储器(ROM)。

(6) 非 RAM 存储。
若数据完全独立于一个程序之外,则程序不运行时仍可存在,并在程序的控制范围之外。其中两个最主要的例子便是“流式对象”和“固定对象”。对于流式对象,对象会变成字节流,通常会发给另一台机器。而对于固定对象,对象保存在磁盘中。即使程序中止运行,它们仍可保持自己的状态不变。对于这些类型的数据存储,一个特别有用的技巧就是它们能存在于其他媒体中。一旦需要,甚至能将它们恢复成普通的、基于 RAM 的对象。Java 1.1 提供了对 Lightweight persistence 的支持。未来的版本甚至可能提供更完整的方案。