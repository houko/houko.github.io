<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>java on 小莫的博客-fighting(技术分享、生活随笔)</title><link>https://blog.xiaomo.info/categories/java/</link><description>Recent content in java on 小莫的博客-fighting(技术分享、生活随笔)</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>@Copyright 2023</copyright><lastBuildDate>Thu, 17 Dec 2020 00:00:00 +0900</lastBuildDate><atom:link href="https://blog.xiaomo.info/categories/java/index.xml" rel="self" type="application/rss+xml"/><item><title>postman和commandline tools（newman）用法介绍</title><link>https://blog.xiaomo.info/2020/newmancommandline/</link><pubDate>Thu, 17 Dec 2020 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2020/newmancommandline/</guid><description>不知道大家对大批量重复性的工作内容的第一反应是怎样的，我的第一反应肯定是写脚本，还得是python的。但是发现postman对批量api调用</description></item><item><title>spring cloud集成spring security</title><link>https://blog.xiaomo.info/2020/springbootwithspringsecurity/</link><pubDate>Mon, 30 Nov 2020 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2020/springbootwithspringsecurity/</guid><description>在spring boot/spring cloud成为java生态中绝对主流的开发框架时，spring家族其他的框架也开始变得越来越流行。对于认证授权的方案也有更多</description></item><item><title>使用flyway版本控制工具维护数据库表</title><link>https://blog.xiaomo.info/2020/flyway/</link><pubDate>Fri, 27 Nov 2020 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2020/flyway/</guid><description>最近的公司项目需求需要在现有的项目中集成spring-security，鉴于对spring security的知识较为零散，虽然之前集中学习了</description></item><item><title>使用IDEA保存时自动格式化代码配置</title><link>https://blog.xiaomo.info/2020/autoformatonsave/</link><pubDate>Thu, 26 Nov 2020 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2020/autoformatonsave/</guid><description>公司的Java项目在提交代码时会自动执行CI。为了统一代码风格，CI中配置了使用google-java-format来检查代码格式，所以ID</description></item><item><title>jdk源码系列-Java到底是值传递还是引用传递？</title><link>https://blog.xiaomo.info/2019/javapassbyvalueandreference/</link><pubDate>Mon, 05 Aug 2019 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2019/javapassbyvalueandreference/</guid><description>首先，不要纠结于 Pass By Value 和 Pass By Reference 的字面上的意义，否则很容易陷入所谓的“一切传引用其实本质上是传值”这种并不能解决问题无意义论战中。更何况，要想</description></item><item><title>jdk源码系列-Thread.sleep(0)和Thread.sleep(1)的区别</title><link>https://blog.xiaomo.info/2019/jdksourcecodereadthreadsleep/</link><pubDate>Mon, 22 Jul 2019 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2019/jdksourcecodereadthreadsleep/</guid><description>某人的代码中用了一句看似莫明其妙的话：Thread.Sleep(0) 。既然是 Sleep 0 毫秒，那么他跟去掉这句代码相比，有啥区别么？Thread.S</description></item><item><title>restful最佳实践</title><link>https://blog.xiaomo.info/2019/restfulbestuse/</link><pubDate>Mon, 22 Jul 2019 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2019/restfulbestuse/</guid><description>restful 是目前最流行的 API 设计规范，用于 Web 数据接口的设计。它的大原则容易把握，但是细节不容易做对。 不要纠结于无意义的规范 在开始本文之前，我想先说这么</description></item><item><title>jdk源码系列-Java中ArrayList、LinkedList和Vector的联系与区别</title><link>https://blog.xiaomo.info/2018/jdksourcecodereadarraylistandlinkedarraylist/</link><pubDate>Mon, 11 Jun 2018 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2018/jdksourcecodereadarraylistandlinkedarraylist/</guid><description>毫无疑问，List是一种非常基础的数据结构，翻译过来就是列表。正如它的名字所示，List表示的是一个有序(插入顺序)的元素序列。在Java的</description></item><item><title>jdk源码系列-String,StringBuffer,StringBuilder</title><link>https://blog.xiaomo.info/2018/jdksourcecodereadstringdifferent/</link><pubDate>Sat, 09 Jun 2018 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2018/jdksourcecodereadstringdifferent/</guid><description>String,StringBuilder以及StringBuffer这三个类之间有什么区别? 这三个类之间的区别主要是在两个方面，即运行速度和</description></item><item><title>jdk源码系列-创建对象</title><link>https://blog.xiaomo.info/2018/jdksourcecodereadcreateobject/</link><pubDate>Sat, 09 Jun 2018 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2018/jdksourcecodereadcreateobject/</guid><description>String str=new String(&amp;quot;abc&amp;quot;);到底创建了几个对象？相信大家对这此并不陌生，答案也是众所周知的，2个。接下来我们就从这道</description></item><item><title>jdk源码系列-类的初始化顺序</title><link>https://blog.xiaomo.info/2018/jdksourcecodereadclassinitorder/</link><pubDate>Sat, 09 Jun 2018 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2018/jdksourcecodereadclassinitorder/</guid><description>大家在去参加面试的时候，经常会遇到这样的考题：给你两个类的代码，它们之间是继承的关系，每个类里只有构造器方法和一些变量，构造器里可能还有一段</description></item><item><title>jdk源码系列-AtomicInteger</title><link>https://blog.xiaomo.info/2018/jdksourcecodereadatomicinteger/</link><pubDate>Sat, 02 Jun 2018 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2018/jdksourcecodereadatomicinteger/</guid><description>JDK 里面提供的以 Atomic* 开头的类基本原理都是一致的， 都是借助了底层硬件级别的 Lock 来实现原子操作的。 本文以 AtomicInteger 为例进行讲述， 其他的类似。阅读本文前建议先阅</description></item><item><title>jdk源码系列-ConcurrentHashMap</title><link>https://blog.xiaomo.info/2018/jdksourcecodereadconcurrenthashmap/</link><pubDate>Sat, 02 Jun 2018 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2018/jdksourcecodereadconcurrenthashmap/</guid><description>ConcurrentHashMap 是将锁的范围细化来实现高效并发的。 基本策略是将数据结构分为一个一个 Segment（每一个都是一个并发可读的 hash table， 即分段锁）作为一个</description></item><item><title>jdk源码系列-Integer</title><link>https://blog.xiaomo.info/2018/jdksourcecodereadinteger/</link><pubDate>Sat, 02 Jun 2018 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2018/jdksourcecodereadinteger/</guid><description>对于 Integer 这个 Java 程序员几乎天天使用的类,使用上却可以看出普通程序员和优秀程序员区别。 深入代码 在创建数字 1 的对象时， 大多数人会使用 new Integer</description></item><item><title>jdk源码系列-ThreadLocal</title><link>https://blog.xiaomo.info/2018/jdksourcecodereadthreadlocal/</link><pubDate>Sat, 02 Jun 2018 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2018/jdksourcecodereadthreadlocal/</guid><description>这个类提供本地线程变量。不同于一般的变量，这些变量在他们各自的线程里通过 get、set 访问一个它自己的变量，这是一个独立初始化的变量副本。在</description></item><item><title>jdk源码系列-内存模型</title><link>https://blog.xiaomo.info/2018/jdksourcecodereadmemoryactor/</link><pubDate>Sat, 02 Jun 2018 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2018/jdksourcecodereadmemoryactor/</guid><description>为了让程序员忽略掉各种硬件和操作系统的内存访问差异， 也既无需关心不同架构上内存模型的差异， Java 在代码和硬件内存模型间又提供了一个 Java 内存模型。 并</description></item><item><title>jdk源码系列-深入了解IO的工作机制</title><link>https://blog.xiaomo.info/2018/jdksourcecodereadio/</link><pubDate>Sat, 02 Jun 2018 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2018/jdksourcecodereadio/</guid><description>I/O 问题是任何编程语言都无法回避的问题，可以说 I/O 问题是整个人机交互的核心问题，因为 I/O 是机器获取和交换信息的主要渠道。在当今这个数据大爆炸时代，</description></item><item><title>jdk源码系列-线程池</title><link>https://blog.xiaomo.info/2018/jdksourcecodereadthreadpool/</link><pubDate>Sat, 02 Jun 2018 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2018/jdksourcecodereadthreadpool/</guid><description>Executors 是 Executor、ExecutorService、ThreadFactory、Callable 类的工厂和工具方法。 创建一个固定大小的线程</description></item><item><title>jdk源码系列-Object</title><link>https://blog.xiaomo.info/2018/jdksourcecodereadobject/</link><pubDate>Fri, 01 Jun 2018 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2018/jdksourcecodereadobject/</guid><description>Object类是类层次结构的根，是每一个类的父类。所有的对象（包括数组）都是实现了object类的方法。 Object结构 这里有7个nativ</description></item><item><title>jdk源码系列-NIO</title><link>https://blog.xiaomo.info/2018/jdksourcecodereadnio/</link><pubDate>Thu, 31 May 2018 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2018/jdksourcecodereadnio/</guid><description>Java NIO和IO之间第一个区别是， IO是面向流的， NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节， 直至读取所有字节， 它们没</description></item><item><title>jdk源码系列-throwable和Exception的区别</title><link>https://blog.xiaomo.info/2018/throwableandexception/</link><pubDate>Tue, 29 May 2018 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2018/throwableandexception/</guid><description>在写代码的时候Exception随手就来，但是提到Throwable总觉得又熟悉又陌生。 先上图为敬 从上图可以看出,throwable是Exc</description></item><item><title>jdk源码系列-顺序索引</title><link>https://blog.xiaomo.info/2018/jdksourcecoderead/</link><pubDate>Fri, 25 May 2018 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2018/jdksourcecoderead/</guid><description>很多java开发的小伙伴都会阅读jdk源码，然而确不知道应该从哪读起。以下为通常所需阅读的源码范围。 标题为包名，后面序号为优先级1-4，优先</description></item><item><title>fastjson的key为非字符串的处理</title><link>https://blog.xiaomo.info/2018/fastjson/</link><pubDate>Wed, 03 Jan 2018 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2018/fastjson/</guid><description>fastjson己然成为最为流行的Json处理框架,今天在处理json的时候发现默认以long型为key时解析会失败,网上搜索无果但最终还是</description></item><item><title>java的oracle考试认证(OCJP)之路</title><link>https://blog.xiaomo.info/2017/oraclejavasesliver/</link><pubDate>Fri, 24 Nov 2017 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2017/oraclejavasesliver/</guid><description>&lt;p>最近几天准备了一下java的oracle认证考试(OCJP),在网上查找资料奈何国内基本没太多有用的信息,还是费了一番功夫.&lt;/p></description></item><item><title>lombok常用注解整理</title><link>https://blog.xiaomo.info/2017/javalombok/</link><pubDate>Mon, 11 Sep 2017 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2017/javalombok/</guid><description>&lt;p>2017-09-11-lombok常用注解整理&lt;/p></description></item><item><title>关于对象的一些思考</title><link>https://blog.xiaomo.info/2017/aboutobject/</link><pubDate>Tue, 07 Mar 2017 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2017/aboutobject/</guid><description>《thinking jn java》被公认为java界的圣经，没有拜读过《thinking jn java》，谈不上算是合格的java程序员。怀着这份敬</description></item><item><title>接口格式返回大小写处理.</title><link>https://blog.xiaomo.info/2017/javaapijsonformat/</link><pubDate>Tue, 17 Jan 2017 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2017/javaapijsonformat/</guid><description>前言：在写java api的时候会因业务复杂情况遇到各种棘手问题。比如说基于己有数据库开发移动端应用的时候，hibernate这种映射框架用着</description></item><item><title>swagger ui和spring boot集成生成api文档</title><link>https://blog.xiaomo.info/2016/javaspringbootswaggerui/</link><pubDate>Fri, 11 Nov 2016 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2016/javaspringbootswaggerui/</guid><description>曾经一度我一直想在做前后端分离的时间写api接口是一个痛苦的过程，虽然也在网上找了一些可以填写api的系统，但使用起来总是不尽人意。现在，终</description></item><item><title>lombok简化java代码注解的使用</title><link>https://blog.xiaomo.info/2016/javalombok/</link><pubDate>Tue, 08 Nov 2016 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2016/javalombok/</guid><description>今天在stackoverflow上回答问题的时候发现了几个不得了的注解，是我从来没有见过的。然后呢，为了回答别人的问题，我就去查资料了。。。</description></item><item><title>spring boot做前后分离时间格式化</title><link>https://blog.xiaomo.info/2016/javaspringbootdataformat/</link><pubDate>Wed, 02 Nov 2016 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2016/javaspringbootdataformat/</guid><description>最近在用spring boot 做数据接口时难免遇到时间这类的问题，接口原则：能服务端处理的别留给客户端。客户端的职责就是把服务端的数据完美的展现出来</description></item><item><title>spring boot做前后分离的跨域问题</title><link>https://blog.xiaomo.info/2016/javaspringbootcors/</link><pubDate>Tue, 01 Nov 2016 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2016/javaspringbootcors/</guid><description>最近在用spring boot 做数据接口供客户端调用时发现存在跨域问题，虽然解决问题有很多。比如用nginx处理等等。但是更方便的是服务端设置一下跨</description></item><item><title>spring boot相关资料</title><link>https://blog.xiaomo.info/2016/javaspringziliao/</link><pubDate>Sat, 29 Oct 2016 00:00:00 +0900</pubDate><guid>https://blog.xiaomo.info/2016/javaspringziliao/</guid><description>spring真是让人又爱又恨呢，好用但是难学。spring铺的又太大，不知道从哪入手。整理点资料，免得头晕。 一、spring boot 配置相关 1. 配置</description></item></channel></rss>