[["2022年年终总结(而立之年的蜕变)","2022年12月12日","/2022/summary/","hello,大家好！我是小莫，算起来今年己经是连续做年末总结的第7年了(见末总结系列 )，不知不觉工作也快10个年头了。如果要说进入到2023年是什么感觉的话，我最大的感觉就是没有实感，还没有做好任何准备2023年就己经到来了，因为此时此刻(2023年1月3日)我才刚刚开始写年末总结，年纪越大越觉得时间飞速流逝，也或者记忆力衰退，以至于2022年经过的一些事情的细节都己经不太能想起来了。年末年始放假这段时间去汤泽滑雪，很多事情都没有做，现在假期结束收一收心把2022年留下的一些尾巴给完成。回复翻看了一下2022年的年末总结 ，其实觉得总结的挺没有条理的，导致今年想根据去年的年末总结做一下复盘的时候看起来比较费力，所以今年做总结的时候尽量做的有条理一些。 2022年大事件 2022年3月-转职 从CTW 离职，4月加入U-NEXT 的CoreTeam开始了 的工作，主要技术栈是 、 、 、 、 和 。也都是大多没有接触过的东西。所以在边学习边做Task的状态下工作着，遇到了非常好的前辈在工作的时候给我很多帮助。目前后端用的技术如下： backend 工作台 闲暇之余折腾了自己的家庭影院，我像一个网络仓鼠一样把喜欢的电视剧、电影、动漫都下载到 上保存，这让我感觉到了极大的满足感。在AppleTV上安装了 然后就可以随时观看下载的电影，感觉非常的棒。 plex 2022年4月-做菜 因为换工作签证需要更新，所以4月的前半个月一直闲着比较无聊所以在研究着做新菜，感觉学会的特别喜欢吃的2个菜是 和 。 2022年5月-摩托驾照 报考了摩托车 的手动档的学习，在边工作边学习的状态下1个半月拿到驾照，学习的时候用车是 ，非常帅气的摩托且值得入手。 2022年6月-k8s直播 开始了kubernetes官网的直播讲解 ，一共录了有100多期，主要内容就是和对kubernetes感兴趣的朋友一起在 对 官网上的知识点进行系统的讲解和学习。对应笔记有 ， ， ， , , ， 共7个模块。 k8s 2022年7月-迪士尼之行 和小伙伴们一起去了东京迪士尼的 和 ，算是圆了迪士尼之梦，总体感觉来说是女孩子喜欢的类型，建筑很好看，但人也很多。 2022年8月-自学吉他 开始自学 ，坚持了大概2个月左右，录了几首弹唱。但是意识到如果不抓紧时间的话2022年的考证计划应该就没办法完成了，所以算是鸽了，2023年会重新拾起来的。 2022年9月-ROUND1 之前一直想打乒乓球，所以在住的地方约了体育馆但是经常约不上，后来在朋友的推荐下去了 ，感觉发现了新大陆。不仅有 ，还有 ， ， ， 等十几种可以玩的设施，价格还超级实惠，此后便成了我经常光顾的游玩地。 2022年10月-骑行 买了自行车开始骑行锻炼身体，从最初的 到后来能够一次骑 ，我最开始是不相信自己能有这个能力骑这么长的距离。所以不得不感慨，人的潜力是非常大的，如果自己不去尝试，永远都不知道自己的极限在哪里。 bike 2022年11月-买车 考虑了很久最终还是买了车，从杭州到日本之后把思域卖了一直是我的一块心病，所以还是在日本买了车。理智上来说买车的时机不是很好，但是能够极大的提升生活的幸福指数，人活着不就是为了能够开心一点么？ 2022年12月-滑雪 自驾去 滑雪跨年，从去年开始接触滑雪之后便对滑雪抱有很大的兴趣，自己买了全套的滑雪装备。去年学会的技巧是落叶飘，希望今年能够学会换刃。今年己经是在雪场进行的第二个跨年了，感觉跨年果然还是要吃烤肉。 2022年主要成果 考取的云计算证书 如果说2022年取得最大的成果的话，那应该是考取的云计算方面的证书了吧，涉及到 、 、 、 共7个证书 ，且大部分是在零基础的情况下学习并获得。上半年的重点是学习各种基础，下半年的重点是针对考点进行练习，所以取得证书的时间多集中在下半年。 Notion笔记展示 第2个我觉得算得上比较有成就感的就是把所有的笔记从 转移到了 上，并对之前总结的比较零散的东西进行了整理。可以说现在notion是我工作生活中必不可少的一部分，目前主要的大模块如下: frontend backend 云计算 devops 爱好 考证计划 B站Up主成果 前几年对游戏开发相关的技术比较感兴趣，于是搬运了 、 的一些视频到B站 。从2021年开始录制了一些关于 、 、 的一些视频，获得了很多好的反馈，现在总播放量破百万粉丝数也有近2万人了。 bilibili 开源了wechatgpt 在刷推的时候发现大家都在聊 ，因此突发其想能不能把它的api集成到微信上。于是进行了一番研究开源了wechatgpt 。刚开始只支持微信，后来发现微信容易封号，又加了 ，之后为了方便部署又打了docker镜像到 ，发布不到一个月没有任何推广的情况下star破百，还是比较受到大家喜欢的，如果感兴趣的朋友也可以自己玩一下，后续计划准备用flutter做一个App来使用。 wechatgpt Blog迁移到hugo 之前用 也有6年时间了，博客的主题经过我的各种魔改己经岌岌可危，但是一直犯懒就没有修复。为了能够有点新鲜感把博客迁移到了 也用上了新的主题，经过各种配置和整理现在看起来己经顺眼多了。在整理笔记的时候发现从2016开始写博客开始，数量逐年下降。原因我总结了一下：是从2018年之后开始用云笔记之后平时要记录的东西都放在笔记里，慢慢的很少写博客了。2021年更是只有一个年末总结，其实本来计划要写的内容还是有几篇的，但是给自己堆的事情太多了就搁置了，希望2023年能够多产出几篇有价值的博客。 hugo 在udemy上更新课程 目前在udemy上更新了CKAD 和CKS 的课程，有需要的小伙伴可以点击链接购买，如果优惠过期了可以联系小莫要优惠码。之后还会推出更多的课程，希望小伙伴们能够多支持。 cks ckad 坚持开源项目 从2015年注册github 开始，一直坚持参与与各种开源项目。 github 2022年遇到的机遇和挑战 机遇 塞翁失马，焉知非福。因为一些原因从CTW离职了，但是找到了现在的工作，感觉非常开心。如果有注意到，能够发现我的关键时间点是从3月份开始的，因为我也正是在3月份离职的。在CTW是没有自己的生活，一切的时间都被繁琐的工作填满，换了工作之后不仅收入增加了，而且自我提升时间变多了，整个人的生活状态都有了翻天覆地的变化，不得不说选择真的非常重要。 挑战 加入U-NEXT 之后首先要适应的就是 ，对于自控力较差的人来说 就意味着没有人监督，工作上和生活人都会产生很大懈怠。于是我为了能够和正常出勤保持一致的节奏，坚持每天7点钟起床然后直播1小时，之后吃饭休息到10点和之前同样的时间上班。也给自己增加了一些锻炼身体的项目，做了日程表来严格执行，总体来说这一年效果还是比较满意的。 U-NEXT 现在在 的排名是 ，还在 和 前面哦，喜欢看电影的朋友不妨尝试一下。 unext 2022年做的不足的地方 焦虑 在经历了而立之年后深刻的体会到了时不我待，每天都觉得时间不够用，觉得有非常多的东西需要我去学习，因此给自己定了太多的目标导致整个人很焦虑，在没有如期完成的时候会变的自我否定。 精力分散 也是因为自己定了太多的目标，导致时间太分散，最终要做的事情很多都是只做了一半。 缺乏持之以恒的精神 对什么事情都很感兴趣，但是3分钟热度过后就坚持不下去。在2022年半途而废的就是锻炼身体（举铁、跳绳、篮球、跑步）坚持了几个月就不想做了，视频分享也是录了有十几期之后就停更了，博客也是一整年都没有更新。 2023年计划 日语 一直都知道语言是自己的短板，但是因为对技术的热爱让自己把大部分时间都花在了学习新的技术上，在面试的时候吃了很大的亏。于是下定决心，从2023年开始把重心放在学习语言上，早上和晚上技术直播的时候改成用来学习日语。 japanese 英语 上半年的主要目标是学习日语，下半年的目标是学习英语，坚持每天学习2个小时左右。 english 吉他 吉他是从小就喜欢的一种乐器，因为各种原因没有机会学习。现在有了自己的时间可以学习，希望能够作为自己的一个终生爱好。 guitar 练字 我对书法兴趣不大，但是对于写一手好看的字抱有极大的渴望。也许是天生是左手惯用手被后天强行改成右手导致写字一直写不好，因为从小练字贴的数量一点都不比别人少。虽然说现在大部分时间都是用电脑打字，但是书写作为一种基础的能力还是要努力精进一下，当然也是因为去年在twitter上立下了flag，给家里寄药写了个小纸条字丑到我自己了。 tweet 锻炼身体 随着年龄的越来越大，身体不高的情况下体重在不断的增加，再加上远程工作运动的机会就更少，完全进入了一个负面循环。因此要打破这种循环就需要坚持运动，让自己保持一个健康的身体。 主要运动 独立开发者 从入行开始写 ，慢慢开始学习 相关的技术，再之后以 的职位面试并入职，顶着全桟工程师的职位己经工作了好几年，再加上云计算技术的补充，现在的我完全有能力以个人开发者的身份开发出一个能够商业性的产品，但还需要学习设计(figma)和产品(PMP)相关的能力。 我的技术栈 课程录制 主业的工作只能维持正常的生活，能够往上提的空间有限，为此要拓展新的收入方式可以通过自己擅长的能力作为讲师把技术教授给需要的人。 主要录制方向 udemy讲师资料，点击查看详细 视频剪辑 课程的录制难免需要进行后期处理，视频剪辑也是一个不可缺少的能力，因为主要用mac系统，所以打算系统学学 。 视频剪辑 一些碎碎念 2022年也真是不平凡的一年，全世界发生了很多不可思议的事情。照之前的认知都是无法想象的事情，但是大家的接受能力也是惊人的，能够在极短的时间里了解、接受并苦中作乐。 而这一年： 我终于去看了错过了几年的樱花 樱花 樱花 樱花 樱花 樱花 樱花 樱花 樱花 近距离看了东京塔、晴空塔和摩天轮 东京塔 天空树 摩天轮 认识了许多志同道合的小伙伴 朋友小心翼翼保护了一路生怕会碰到的完美蛋糕 cake 去海边看了夕阳 夕阳 去感受了圣诞的梦幻 圣诞树 圣诞树 自己开车去滑雪 第一天晚上就遇到大雪把车淹没了 snow snow 收到了新年的礼物 gift 看了心目中理想的房子 虽然这个目标有点遥远，但是：路不都是一步一步走出来的！ 我喜欢这种独栋小楼，可以安静的做自己喜欢做的事情，不用担心蹦蹦跳跳影响到楼下的邻居。 house 总结 岁月流逝如同河流奔腾，我们不停地向前奔跑却没有办法阻止它的流逝。一天又一天，一年又一年，时间一去不复返。我们的青春和年华悄悄流失，岁月的摧残无情地把我们推向老去。 但是，我们不能让岁月流逝的悲伤把我们淹没，我们要勇敢地向未来迈进。虽然我们已经迈过了许多岁月，但我们仍然有机会去实现我们的梦想。2023，Fighting!脚踏实地的去实现新的目标。 "],["2021年年终总结(又是跨界的一年)","2021年12月12日","/2021/summary/","不管愿不愿意，2022年还是如期而至。对于我来说今年是个特殊的一年，从之前的奔三到了实实在在的到了30岁，心态还是有很多变化的。年底工作上非常的忙，导致2022年都过了半个月还没有把总结写法，迟到了一个月的年终总结终于出炉了,不过截至到今天完全写完正好是农历除夕，也不算迟到吧。 建议直接看视频高清版 工作 参与的项目 游戏平台管理系统 后端 ，前端 系统新功能的开发和维护 新游戏上线流程的优化 即存Bug的修改和UI/UX的优化 支付授权、支付回调、支付方式、订单等功能的开发 添加google sso登陆方式 image-20220130182004894 游戏平台 前端 ，后端 功能的开发 线上bug的修复 image-20220130181941842 管理相关 面试 Intern发表评价 Project Tracking 技术分享：游戏开发浅析:科普向 PIC的项目 把公司官网从ctw-inc.net 迁移到ctw.inc 上 技术栈是 ，服务放在了 上 整个网站打包迁移到新的域名 配置了 和 登陆 配套的一些 维护着官网上的一些内容更新 image-20220130181907797 根据开源博客hexo二次开发了公司技术部的博客网站 从0搭建了一个技术博客 根据UI设计对博客主题进行二次开发 维护博客的一些内容更新 image-20220130174948507 上线了短连接服务 后端API用go语言开发，管理界面用vue开发，项目打docker镜像放在k8s集群上 主要功能就是在host后成生成一个随机串，比如 https://domain/mblghox8 ，访问这个地址可以跳到带有很多参数的原始链接 在平台管理工具上添加了对短连接的管理UI 开发了平台三周年庆典的活动网站 前端 ，后端 ，数据库 API接口管理 接入 拉取最新的数量 搭建前端React(vite+react+tailwind+mui)和后端Golang(go+gin+gorm)模板 公司项目越来越多，技术负债也越来越重。为了统一技术栈，搭建了前后端开发的模板，方便新起项目的时候快速搭建 golang项目模板搭建的时候参考了 开发的结构，现在实际项目中己经修改和原来结构完全不同的结构 image-20220130182536394 翻译平台 前端 ，后端 ，其他技术栈： + + + 因为平台开始做全球化，需要把游戏翻译成各个国家的语言版本，原来的三方工具crowdin 无法满足需求，所以自己写了一个翻译平台 前后端分离，项目放在了 上 image-20220130174755461 工作上的变动 一开始参加工作的时候一直做的后端开发，有的时候有一些好的想法想做一个小项目出来，但是因为只会后端所以把API都写出来了却没有前端页面，导致想法也不了了之。后来为了解决这个困扰开始学习前端，把主流的 、 、 都玩了一遍，2019年从国内游戏公司离职到日本做前端写 算是真正的开始在商业项目中参与前端的工作。2020年还是回到了心心念念的游戏行业，不过开始是 的角色参与开发。主要使用 和 ，在年底的时候开始陆续在一些微服务上用 写API，在基础设施搭建方面和同事接触了解了一些 、 、 的知识，开始产生兴趣不断的学习。于是在年底的时候从 开发组转到了 组做系统架构，期间也在用 写翻译平台的API，用React写一些前端项目。 技术 前端方面 彻底放弃 系列，开始全身心关注React技术栈相关内容，因为精力实在有限(Vue非常简单，如果以后工作有需要稍微看下最新文档就可以写业务)，把之前用 全部换到了 的写法 学习了 的使用，虽然它只是一个UI框架但是对于CSS的写法和原生React写css样式有着巨大的差异 在项目中使用 来写css，不断的在和同事讨论最佳实践，引用了 来对 进行检查 构建工具从 换到了 ，后端 前端 来打包项目。但是因为要多环境部署使用 来打包项目变量 TS的用法在前端和后端Node项目中得到了大量的练习，对于基本使用己没有太大问题。 后端方面 用Node（ + ）写了一个订单相关的项目，感觉只是在API层面上使用的话边写边查文档不用很熟写功能也问题不大。但是和熟练者相比效率会低，而且有些坑不知道会有些问题。 从开始排斥用 写新项目到积极的拥抱 ，感受到用新东西需要有一个接受过程而且如果有可以一起交流的小伙伴会更加有动力坚持下去。 写了7年的Java，照目前的计划的话以后写Java的机会会非常少，不过一点也没有觉得可惜。技术在不断的更新，人也得往前走，一直待在舒适区是一件很恐怖的事情。 Infra方面 2015年开始使用阿里云在上面买服务器折腾一些内容，直到今年10月份接触到AWS才了解到AWS的强大，因此组建了一个AWS学习小组一起学习AWS并把内容直播放在Youtube 和 bilibili 上，有兴趣的朋友可以看看我们在学习过程中如何成长，有没有踩过你踩到的坑。 IaC是近些年非常流行的一个思想，使用写代码的方式代替在网页上点点点的操作好处显而易见。比如代码的复用性，可维护性等等都是很大的优势，因此学习了Terraform如何管理我的AWS资源并以考取terraform证书为目标。当然IaC工具不光这一个，比如AWS的服务 和用不同的编程语言都可以管理你的资源的pulumi ，根据自己的需要进行学习。目前考到了Terraform的证书，HashCrop家还有2个证书后续有时间也想一起考了。 image-20220130172402266 前几年使用Docker也仅限于用Docker起一个本地测试的数据库之类的，今年系统的学习了Docker相关的知识，包括基础用法、DockerFile、Compose、网络、原理等，计划春节期间花一周的时间来开一个Docker专题当一下Docker的布道师，也巩固一下自己的Docker知识。(Podman用法基本一致，后面学下原理感觉问题不大) 使用Docker来打包项目好处很多，但是如果Docker镜像一旦多起来了如何编排呢？手工维护是一件非常头疼的事情，因此开始学习k8s如何使用，以考取 + 为目标来学习k8s 其他的一些监控系统的搭建，比如日志收集系统 ，k8s资源监控 ，项目部署系统 等等 语言 日语方面 2021年12月份的N1依旧没有通过考试，最初目标是为了想拿永驻的签证可以加分所以卯着劲想要考过，但是结果证明我的日语还只是刚刚达到N2的水平，甚至N2的语法大部分都没有掌握，勉强去考N1意义不大，因此后续计划把N2的课程系统的从头再学一遍。等基础打牢了之后再继续以N1为目标吧，经历了这几次考试我深刻的体会到结果不会欺骗你，你在它上面付出了多少心血，它就会拿同等的结果来回报你，想要顺利通过就一定得付出努力才行。 英语方面 在这次的Terraform的备考和考试的经历来说，不会英语会成为技术进步的一大阻碍。本来是想着工作中需要大量的读到英语的文档，坚持看英语很快就能提高。但是理想很美好现实不如意，平时在公司工作比较忙想静下心来细读英文文档的次数非常少，为了更快的理解经常读到一半的时候直接翻译成中文快速的过一遍然后就去写代码了。个人觉得还有一个非常重要的原因是对英语的恐惧感，目前我读日语的文章己经没有之前的那种恐惧感了，但是英语还是会有这种感觉。不是说我的英语水平理解不了文章的内容，而是看着看着突然有个不认识的词卡住再去查觉得挺难受，而且看技术文档本来就比较耗费精力，再分一部分脑细胞给理解英语上就很抵触。这是我目前最大的问题，为了克服这种障碍我计划开始从简单的非技术文章开始看起，养成看英语文章的习惯而不是打开一个网页是英文的条件反射的就给翻译成中文。以托业750+为目标来好好学习英语。 兴趣 游戏 2015年进入游戏行业后对游戏的原理和套路了解的透彻之后对游戏反而没有那么大的兴趣了。还有一种可能应该是年龄越来越大能力却配不上这个年纪的时候心里对玩游戏也没有了那么大的兴致。但是作为一个玩游戏长大的人来说，生活中如果没有了游戏生活的乐趣一定会少很多。当初一起玩网游(WOW、剑灵、DNF、LOL、PUBG)的朋友和同事一个一个的从身上消失，我也就没有了继续玩下去的动力。尝试着玩一玩别的类型的游戏，于是买了Switch OLED和一些游戏卡，尽量让自己的生活不那么无趣。 钢琴 学习钢琴是我这十几年来一直想要付诸实践的事情，但是受限于各种原因一直没有机会，趁着过年的机会买了一台kawari es110。虽然可能短期并没有机会让自己能够比较熟练的学会如何弹奏，但是也算是满足了这么多年的一个想要学习的愿望吧。 滑雪 在很偶然的机会下，同事邀请着一起去滑雪。在杭州的时候曾经有一次去滑雪玩过一次双板，但是具体什么感觉己经完全记不住了。本来并不打算去，但是后来想要挑战一下自我，是一个难得的机会于是和同事一起去了越后汤泽的滑雪场。己经数不清摔了有多少次，但是作为真正的第一次滑雪体验，成长速度还算是比较满意。后续元旦和三连休的时候又连续去了两次，目前己经算是我众多爱好里在不断追求进步的爱好之一了。毕竟花了那么多钱置办装备，如果不坚持下去怎么对得起自己的钱包，希望今年冬天我能够飘逸的滑完全程不摔跤。 动漫 小时候虽然看过各种动漫，但是电视上的动漫都汉化成了中文，体会不到看原版动漫那种感觉。应该来说真正爱上看动漫是在上大学的时候，追着当时的热门番一直就这么追了十几年，这应该是我有生之年坚持的最久且热情不减的爱好了。如果看到这里的你还怎么看过动漫，一定建议去看一看，它远比各种偶像剧、综艺那些带给我们的感触要多的多。我在Notion上维护着一个动漫列表，收集着这些年来非常推荐的一些动漫，有兴趣的可以打开看一看 。 image-20220130190235938 旅游 我的梦想就是环游世界，做着自由的工作。背着电脑在不同的国家边体会各国的风情边工作，但是近两年持续没有好转别说去别的国家旅游，连回国都变的不可能。但好的一点是很多公司己经开始接受永久远程办公了，这也算是间接的离梦想更近了一步吧。有认识的朋友在公司允许永久远程工作之后很快就从东京搬到了福冈，不必在拥挤的东京和大家抢资源是一件非常值得开心的事情。后面等疫情过去之后至少一年去一个国家旅游，领略一下不同的风景。 生活 记忆力 发现自己近两年记忆力越来越差，不仅表现在学习记东西没有之前有效率，而且很多事情头天决定的事情第二天就完全没有印象了，因此我做了一些应对方案。 笔记 我从笔记从原来的onenote迁移到了Notion，从一个youtuber(老石谈芯)那里了解到第二大脑的概念，把人不擅长长久保存在大脑的东西转到笔记里，在大脑里只有一个索引，把自己的大脑用来做思考、分析、做决策、学东西而不是记忆。 todo list 想到有什么事情需要做的时候第一件事情就是先掏出手机把记下来，然后把时间、地点、要做的事情给记下来。到点之前手机会自动给我推送消息提醒我，而不是完全靠自己的大脑去记。 开始记账 不管是在上学的时候还是开始工作之后，对于每个月要用多少钱是一点规划都没有的。想买什么一冲动就买了，月底的时候一看账单一大堆，总怀疑哪里有错，为什么会花这么多。曾经有短暂的记账，但是没坚持多久就放弃了。2021年一整年坚持下来，己经养成了记账的好习惯。个人认为记账的目的不是为了省钱，而是当看到账单时经过自己手的每一笔账，哪些是真正的对生活的提高起到了作用，哪些是冲动消费，买了从来基本上不用的东西，考虑一下以后是不是可以把把这些东西的钱用在别的地方能够让自己的生活过的更舒服。 学习 从出生到现在，我们每个人都对学习这件事情上从没有停止过，甚至学习着如何学习，学习是推动我们生活的动力。提升自我能够得到更多的报酬，可以让自己的生活变好，生活变好之后就更有动力去学习继续提升自我。如果每天只是重复的、机械性的工作，下班了就刷短视频、葛优躺追剧，那么年复一年除了年龄增长、身体越来越差之外基本上得不到别的收获。我之前几年学技术一直是自己埋头苦学，今年偶然间认识了一些网络上的朋友，每天早上一起学习Terrafrom（己经拿到证书），然后也发起组建了AWS学习会晚上在zoom上一直学习。感觉这种方式非常的不错，毕竟程序员的圈子特别小平时工作和别人沟通也不多，能够通过这种方式认识一些朋友感觉是一件非常值得高兴的事情。而且大家住在不同的国家，接触着不同的东西，能够互相学习，互相鼓励，打算把这种模式一直持续下去。 当UP主 这几年在学习的过程中把自己需要学习的视频搬运到B站上己经积攒了近2万的关注，但是没有太大成就感 。于是开始自己录制一些视频，目前开了三个系列，后面还打算有一个 ，分享看过的一些比较好的书。 莫学习 ：AWS学习小组直播录屏 莫分享 ：分享一些工作生活中接触到的觉得非常好的东西 莫生活 ：在家写代码、整理笔记或者一些碎碎念，记录日常生活的一些内容 录这些视频让我认识到我是非常喜欢分享自己知道的内容的，所以后面还是会坚持做这件事情。后面可能会花时间专门学一学 ，对录制的内容做一些剪辑给观看者一个更好的体验。后面也计划出一些免费的技术类教程，给想要学习相关技术的朋友一些帮助，私心是教别人的时候自己能够对这些内容的理解更加深刻。 心态 越学越菜 倒不是说自己的能力退步了，而是觉得不知者无畏，刚毕业的时候学会了什么东西之后就感觉自己非常的厉害，走路都能走出六亲不认的步伐。现在东西懂的越来越多，反而觉得自己和技术好的人差距很大，需要走的路还很远。 开始变的佛系 不太爱去争强好胜，看明白了有很多时间并不是争赢了就是胜利，找到一个大家都舒服的点很重要。 要稍微慢一点 现在这个时代什么都图快，快餐文化、短视频成为了目前的主流，连电影都只能看解说版，以免浪费时间。但是有很多事情快了味道就变了，只有慢慢的沉浸下去才能够体会到其中的精髓。看视频、听语音确实比看文字的速度更快一些，但是我一直有一个观点，书籍从写到校正再到发布到广为推荐，那么这么书的价值是显而易见的。对于一些非常好的书，一定要花时间去看一看，光学技术是狭隘的。技术只是工具，用工具的是人，生活中要和别人接触，学一学为人处事之道，如何高效沟通，如何让自己的时间花的更有价值，如何平衡和工作和生活。不要焦虑，找好自己的节奏，慢慢的沉下心来去思考自己未来怎么走。 反思 不管生活和工作多忙，有没有时间，我总会想办法抽出一些时间写一个年末总结。从毕业开始我坚持了有6年时间了，我觉得写总结也是一个反思的过程，给过去一年画上一个句号开始一段新的旅程。想一想这一年自己有哪些进步，有哪些做的不好，接下来一年要怎么改进，新的一年又有一些什么样的计划，个人觉得花费这个时间是值得的。因为我们的每一步行动都是大脑去控制的，如果你有合理的规划，能够对事情有一个比较好的认识，那么我们的行为一定是趋向于好的方向。在公司组织的合宿分享会上，需要我们每个人回顾自己这一年有哪些变化，如果躲在舒适区不肯踏出来，那么整个人不是活了一年，而是把上一年的生活重复了一遍，我讨厌这种一成不变。 内在 俗话说内外兼修，技术好不好能力强不强我觉得这是外在。从毕业开始这么多年，我一直在外在上面下足了功夫，我一直觉得我不是聪明的那一类人，甚至还有点拖后腿。但是我要强，越是觉得我做不成，我越是要证明给他们看我可以。另外我觉得自己能够大致按时既定计划在执行，虽然也有些计划一直在拖延，但是大方向上行动力还是很强的，所以我不能说比别人优秀，但是同一个地方出生的同一届毕业的人中我绝对不算差的。这也归功于毕业后这些年我一直把时间花在技术提升上，虽然和现在的同事相比不算优秀，但也算是能跟上大家的脚步。今年也30了，虽然不能算30而立但是需要有一些变化。不能埋头于学习技术，也要学着去提高一下自己的内在涵养。如果做好自己，如何提高情商，如何换位思考，如何与不同的人打交道都是我需要去提升的地方，因此我买了很多跟说话、情商、心理学相关的书籍，多去看看这些书让自己的内在也变的扎实起来。 1341643533603_.pic "],["从0搭建一个react开发的脚手架","2021年09月09日","/2021/reactproject/","最近这一年一直在用vue写前端，虽然一直很想用react，但是因为业务所限不可能花大量的时候去用react重写，只有在新项目的时候才有可能重新做技术选项。公司之前的技术类型比较多，最近开始统一成前端react，后端go/node，这样互相交流起来比较容易。 为了快捷的开发新项目，我维护了一套react脚手架模板 ，开新项目的时候可以快速的以此模板开始业务逻辑，它的特性有： vite作为构建工具，复杂度比webpack低，但速度却比webpack快很多 支持hmr,修改代码页面无缝更新 以typescript为开发语言，有类型约束不会写出难以查找的bug 支持别名@到根目录，@@到components目录 支持国际化，默认写了中文、英文、日语3种语言 配置了eslint，使用 可以自动修复代码格式问题 采用了tailwind作为开发的css样式框架，外加tailwind-classnames约束样式名字。 配置了多环境，默认为local、stg、prod3个环境，如果有特殊需求可根据需要扩展 状态管理采用redux-tool-kit，没有繁琐的redux流程(action、reducer等)，一个slice文件就是一个业务模块。 带一个todoList的demo，列举了react-router-dom相关用法 目录结构 依赖库介绍 核心框架 国际化 UI相关 环境相关 状态管理 css框架 eslint相关 网络相关 scripts 完整package.json 多环境 image-20210907151025364 vite配置 状态管理 image-20210907151509301 slice store 使用store fileService UI中获取数据 详细代码请查看工程 https://github.com/reactZone/vite-react-ts-template 国际化 在 下新建翻译文件 image-20210907152148011 ja-JP.json 国际化核心实现 在入口文件加载i18n image-20210907152327173 路由 如何使用 https://github.com/reactZone/vite-react-ts-template/generate 点击此链接创建属于自己的项目(需要事先登陆github账号) 以此项目为模板创建一个新的项目，然后clone到本地进行开发 "],["日本医疗制度之限度額適用認定証","2021年06月06日","/2021/japannyuyin2/","在中国做手术，从选医院到找大夫，不但要托关系送礼，还要照顾病人，一场手术下来，病人和家人都身心疲惫。在中国做个手术，绝对是个大事。但在日本做手术，心里会很踏实，日本先进的医疗水平和完善的医保制度，会让人省心。在日本看病，首先是去家附近的私人诊所。医生会根据你的病情，向你说明医治方案和可选择的医院。选用哪个方案和哪家医院，要由你自己决定，医生只是给你建议，毕竟没有最好的，只有适合自己的。一旦你决定下来，医生就会介绍你到对口的综合大医院，有了他的“介绍信和诊断资料”，不但大大缩短待诊时间，而且省去了抽血、化验和拍片等二次诊断时间，只需说明自己希望的医治方案，直接就可以预约手术时间了。 住院要办的证 在日本住院前，有一件事千万不要忘记，就是办理“限度額適用認定証”。 参加健保的工薪族，向自己所在的健保组合申请，参加国保的自由人，向区市役所的“保险年金课”申请。申请手续也非常简单，填个申请表，就可以领到这个证了。比如我加入的是関東IT保険 825 为什么要办这个证呢？不管得了什么大病，单月超过自己医疗费上限额度的部分全部报销。但报销还是手续繁杂，而且还需要你垫付医疗费。假如事先办好“限度額適用認定証”，就可以省去申请报销的过程。出院时，只需支付自己额度内的医疗费即可，超出部分医院会代你申请报销，万一自己要负担的部分还是出不起可以申请分期，如果分期都出不起就说没钱最后这部分钱会由政府负担，但是对于个人的信用的话会有很大影响。不像中国住院前需要交住院费，不交费就不给安排病房，后续如果费用续不上还有可能会被赶出病房，生命得不到保障。 个人负担额度 个人负担额度标准（69岁以下）： 如何知道自己的医疗负担上限额度呢？**“限度額適用認定証”的“適用区分”栏，就是你的认定额度了。**我的认定额度档次为“イ ”。这次手术费估算为120万円左右，所以我的费用负担9万多点。而最低档“オ”只需负担35,400円！ “负担额度”的认定月为每年的8月，根据上一年度的所得标准，来确定下个周期个人负担额度（本年8月-次年7月）。同理，8月之前的额度认可，以上一个周期为准，即上上年的所得标准认定。有点绕吧？还是举例说明：我的申请月在2021年7月，因此认定周期为上一个周期，即2021年7月~ 2022年6月，它对应的年收入为2020年1月-12月。那时是有工资收入的工薪族，所以被认定为中档的“ウ”！可见在日本“脱畜”后的一两年内，还是要面对各种税负的挑战！ 床位费和饭费 在日本“住院”和国内很不同，它不准许护工和家属陪护！ 一日三餐等生活问题全部由医院负责，家属只准在规定时间段内探望，假如是行动不便的病人，甚至连洗脸、洗脚都会由护士代劳，这极大的减轻了病人家属的负担，日式服务不服不行呀。 1）床位费 4人或6人的病房为普通病房，多人病房的床位费是免费的！ 但遇上床位紧张，不得不住单人或双人病房就有额外费用“差額ベッド代”产生了。床位费各家医院略有不同，平均每天约6000円。 2）饭费 医院根据病情调整病人三餐的饮食机构，家属完全不用操心。 之前饭费固定为每餐360円，2018年起调整为每餐460円。假如是低收入家庭“市民税非課税世帯”，或长期卧床的还有饭费的减免。 1735 申请住院饭费减免同样是在市役所的“保险年金课”，领到的是另外一个证“標準負担額減額認定証”。 记得在申请“国保限度額適用認定証”的同时申请该证。 低收入家庭住院饭费减免 ： 对象人群 住院饭费（2018年） 一般 460円/餐 市民税非課税世帯 210円/餐 市民税非課税世帯（一年内住院超过90日） 160円/餐 市民税非課税世帯（70~74岁） 100円/餐 手术住院账单 858 **1）**本次住院10天，4人房，每天7700日元，如果是6-8人间的话是房间是免费的； **2）**总费用共计120多万，医保报销70%，自己负担费用36万； **3）**高额医疗费制度保障下，实际支付账单只有9万多！ **\u0026ldquo;限度額適用認定証”连复杂的报销手续都省了，不得不感叹日本高效完善的医疗保险体系！需要注意的是：“限度額認定証”是对“月度”医疗费的限定。 ** 假如这次住院“跨月”，那么报销方面就比较吃亏了。例如同样医疗费11万円，一旦跨月就会被分为两个部分。假设2月份医疗费是5万，3月是6万，这样的报销结果就是：两个月都没有超过“红线”，“限度額認定証”完全失去作用，11万円医疗费全部需要个人负担。可见， 对于那些不太紧急的疾病，在同医生预约手术时间时，需要考虑“限度額認定証”的跨月问题，尽量避免月底住院。 最后总结 1）利用高额医疗费制度，可报销个人每月负担额度之外全部的医疗费用。 2）最低“オ”档，个人每月负担只需35,400円！普通工薪的“ウ”档，也只有每月8万円。 3）事先申请“限度額適用認定証”，可以省去繁琐的医疗费报销手续。 4）“负担额度\u0026quot;的认定为每年的8月，认定周期为每年8月至次年7月。 5）医院的饭费、床位费是属于医保范围外的费用，需要自己负担。 6)注意报销的“跨月”问题，尽量避免月底住院。 "],["我的tmux之旅（tmux使用详解）","2021年05月05日","/2021/ohmytmux/","之前在中期学习计划中将tmux列入其中，但是一直没有花时间研究。周末看番的时候有一个tmux的视频推荐 ，点开看了一下觉得讲的挺好的，感觉是时候在工作中导入这个工具了。视频也直接嵌在正文中，有需要的朋友不妨看一下。 开胃菜 视频开头的动画up主讲到这个软件名字叫 , 可以通过 命令来安装。其实没什么太大作用，就是终端中的一个动画，当作终端的屏保也不错。 退出动画 暂停动画 重置动画 tmux介绍 Tmux是一个键盘驱动的终端分屏工具，可以替代Linux下的screen。当然，如果是在Mac下使用的话，它的核心功能(例如window，分屏等)也是可以被iTerm2替代的，不过好在Tmux在*nix操作系统中足够通用，用包管理工具(apt-get, brew等)即可安装，所以了解并熟练使用它，还是能为平时终端下的工作节省不少时间的。而且最重要的功能是它可以保存会话，避免每次开机都得重复性的去开各种窗口。 session 会话，Tmux是一个C/S架构的工具，一个会话可以认为是C端和S端一次交互的上下文。我们的所有操作都属于某个session，session可以长时间存在，也可以临时退出再重进。我们可用通过session来区分不同的工作空间，比如本地操作开一个session，远程SSH操作开一个session，又或者SSH生产环境机器开一个session，SSH测试环境机器开一个session。 新建会话 第一个启动的 Tmux 窗口，编号是 ，第二个窗口的编号是 ，以此类推。这些窗口对应的会话，就是 0 号会话、1 号会话。 使用编号区分会话，不太直观，更好的方法是为会话起名。 上面命令新建一个指定名称的会话。 分离会话 在 Tmux 窗口中，按下 或者输入 命令，就会将当前会话与窗口分离。 上面命令执行后，就会退出当前 Tmux 窗口，但是会话和里面的进程仍然在后台运行。 命令可以查看当前所有的 Tmux 会话。 接入会话 命令用于重新接入某个已存在的会话。 杀死会话 命令用于杀死某个会话。 切换会话 命令用于切换会话。 重命名会话 命令用于重命名会话。 上面命令可以将会话重命名。 会话(Session)快捷键 ：分离当前会话。 ：列出所有会话。 ：重命名当前会话。 window 如果说session是个不可见的东西，那么window就是我们输入、执行命令的地方。一个session可以包含多个window。把window类比成iTerm2中的标签应该就理解了。在创建session的时候默认会创建一个以\u0026quot;数字下标+bash\u0026quot;命名的window，并且名称随着bash中执行的不同命令而变化。在新建session时可以通过-n参数指定默认打开的window名称，比如通过 tmux new -s basic -n win 命名一个win名称的window。也可以随时通过 Prefix+, 来修改window名称。 命令用来创建新窗口。 切换窗口 命令用来切换窗口，也可以用按下前置快捷键 ctrl+b ,然后按数字键切换。 重命名窗口 命令用于为当前窗口起名（或重命名），也可以按下前置快捷键 ，然后按 。 窗口(Window)快捷键 下面是一些窗口操作的快捷键。 ：创建一个新窗口，状态栏会显示多个窗口的信息。 ：从列表中选择窗口。(强烈推荐：它可以跨session选择所有的window) ：窗口重命名。 ：切换到指定编号的窗口，其中的 是状态栏上的窗口编号。 Pane 一个window可以切割成多个pane，也就是所谓的分屏，算是Tmux的核心功能之一。 划分窗格 命令用来划分窗格。 移动光标 命令用来移动光标位置， 也可以按下前置快捷键 ctrl+b，然后按方向键切换。 交换窗格位置 命令用来交换窗格位置。 窗格（Pane）快捷键 下面是一些窗格操作的快捷键,窗格相关的快捷键比较多，毕竟是我们主要的工作区，但是实际用的非常频繁的并不多。 ：划分左右两个窗格。 ：划分上下两个窗格。 ：光标切换到其他窗格。 是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键 。 ：关闭当前窗格。 ：光标切换到上一个窗格。 ：光标切换到下一个窗格。 ：当前窗格与上一个窗格交换位置。 ：当前窗格与下一个窗格交换位置。 ：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。 ：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。 ：将当前窗格拆分为一个独立窗口。 ：当前窗格全屏显示，再使用一次会变回原来大小。 ：按箭头方向调整窗格大小。 ：显示窗格编号。 安装tmux 配置tmux 做完以上配置后就有了和up演示中一样的功能。 前缀键 Tmux 窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。默认的前缀键是 ，即先按下 ，快捷键才会生效。 举例来说，帮助命令的快捷键是 。它的用法是，在 Tmux 窗口中，先按下 ，再按下 ，就会显示帮助信息。 然后，按下 ESC 键或 键，就可以退出帮助。 tmux帮助命令 tmux快捷键汇总 Ctrl+b 激活控制台；此时以下按键生效 系统操作 ? 列出所有快捷键；按q返回 d 脱离当前会话；这样可以暂时返回Shell界面，输入tmux attach能够重新进入之前的会话 D 选择要脱离的会话；在同时开启了多个会话时使用 Ctrl+z 挂起当前会话 r 强制重绘未脱离的会话 s 选择并切换会话；在同时开启了多个会话时使用 : 进入命令行模式；此时可以输入支持的命令，例如kill-server可以关闭服务器 [ 进入复制模式；此时的操作与vi/emacs相同，按q/Esc退出 ~ 列出提示信息缓存；其中包含了之前tmux返回的各种提示信息 窗口操作 c 创建新窗口 \u0026amp; 关闭当前窗口 数字键 切换至指定窗口 p 切换至上一窗口 n 切换至下一窗口 l 在前后两个窗口间互相切换 w 通过窗口列表切换窗口 , 重命名当前窗口；这样便于识别 . 修改当前窗口编号；相当于窗口重新排序 f 在所有窗口中查找指定文本 面板操作 ” 将当前面板平分为上下两块 % 将当前面板平分为左右两块 x 关闭当前面板 ! 将当前面板置于新窗口；即新建一个窗口，其中仅包含当前面板 Ctrl+方向键 以1个单元格为单位移动边缘以调整当前面板大小 Alt+方向键 以5个单元格为单位移动边缘以调整当前面板大小 Space 在预置的面板布局中循环切换；依次包括even-horizontal、even-vertical、main-horizontal、main-vertical、tiled q 显示面板编号 o 在当前窗口中选择下一面板 方向键 移动光标以选择面板 { 向前置换当前面板 } 向后置换当前面板 Alt+o 逆时针旋转当前窗口的面板 Ctrl+o 顺时针旋转当前窗口的面板 参考文章 阮一峰-Tmux 使用教程 亡灵族-tmux常用命令 "],["doTween插件使用介绍","2021年01月01日","/2021/dotween/","今天我们一起来研究一下DOTween动画插件。 对于该插件官网上的介绍是：“DOtween是一种快速，高效，完全类型安全的面向对象的动画引擎。” 将它导入Unity中，可以很方便快速地帮我们完成许多动画效果。本篇文章主要将通过一些小案例来介绍DOTween的使用方法和主要功能。 DOTween导入： 打开Unity创建一个新工程,将下载好的DOTween插件直接拖入Project面板： img 基本用法 一.移动动画 创建一个小球，位置设为世界坐标原点（0，0，0），挂上此脚本： img 我们发现，使用的DOTween插件后，transform居然能够点出DOMove方法，这是因为C#的拓展性，使其和Unity的一些类能产生链接，是不是感觉很神奇。因为这些特性，使我们在使用起来非常简单易懂，想让哪个物体动，就让它的transform组件来调用DOTWeen的方法就可以了。 DOMove相关方法： 世界坐标上移动：transform.DOMove 本地坐标上移动：transform.DOLocalMove 世界坐标的X轴上移动：transform.DOMoveX 本地坐标的X轴上移动：transform.DOLocalMoveX 通过以上的方法，我们学会了制作移动动画，但这个动画会自动播放，并且，播放完了就销毁了，不能重复使用，后面我们会通过一些设置来避免。 二.From()方法的使用 2秒时间从世界坐标（2，2，0）处回到自身当前位置： img 从以自身为原点的坐标系（2，2，0）处回到自身当前位置： img 三.动画正放与倒放 1.场景中创建两个按钮，来控制动画的播放顺序： img 2.为小球挂上脚本： 3.将两个方法分别挂在各自按钮上，运行程序： img 当点击了前放后才能倒放，也就是说不能一上来就倒放。 其它方法： Pause()： 暂停动画 SetLoops(3)： 循环3次 四.设置动画曲线 在以上我们展示的动画效果中我们，我们通过观察可以看到，物体在播放移动动画时速度是由快到慢（倒放除外），这种现象是由动画播放时的动画曲线决定的，我们是可以通过修改动画曲线来改变物体动画效果的，比如我们可以将运动效果改成由慢到快： img 而动画曲线的种类非常多，可以自己去试试看： img 五.使用动画改变颜色 既然让物体移动是通过使用transform来点出DOTWeen的方法，那改变颜色就是让材质组件来调用DOTWeen的方法即可： img 六.动画事件 img 先变红，再变蓝 动画事件相关方法: OnStart： 动画第一次播放时调用 OnPlay： 动画每次从暂停状态解除时调用(包括初次播放) Pause： 动画暂停时调用一次 OnUpdate： 动画播放过程中每帧调用 OnStepComplete： 每次动画播放结束时调用(受循环次数影响) OnComplete： 每次动画播放结束时调用(不受循环次数影响,且倒放时不适用) 七.文本动画 1.让文本逐字显示： 使用UGUI创建一个Text，挂上该脚本: img 我们可以结合刚才讲到的动画事件，来组一个连续的文字显示： img 代码如下： 2.让文本逐渐显示： 首先要让文字调成完全透明状态： img 挂上脚本运行程序： img 八.屏幕抖动动画： 很多游戏中经常会用到的效果，比如在战斗的时候，主角被攻击会伴随着一阵屏幕抖动,然后 img 以此来提高游戏打击感，其实所谓的屏幕抖动其实就是摄像机位置的抖动，还是离不开Transform动画： 将这个脚本挂摄像机上，运行程序： img 或者： img 右下角的摄像机视角可看到，在X轴上并没有发生位移。 抖动动画不仅有位置上的抖动，还有选择上的抖动和缩放上的抖动： 旋转抖动： transform.DOShakeRotation 缩放抖动： transform.DOShakeScale 我们来看下缩放抖动是什么效果： 创建一个脚本挂在一个Cube上： img 九.可视化编辑 除了使用脚本来播放DOTween动画外，该插件还拥有可视化编辑的功能。 动画编辑器 1.为需要做动画的物体添加DoTweenAnimation组件： img直接点击可以进行打开或关闭 2.选择要做动画的组件： img这里面就包括了我们之前介绍的移动，变色，抖动，文字显示等功能。 3.当要做动画的组件不存在时则报错，非常方便： img 该物体上没有Text组件。 4.各种参数： img 5.当在编辑器关闭了自动播放后，使用代码播放: 6.如果不使用代码，使用点击按钮播放,在按钮的事件窗口将物体拖进去,找到DoTweenAnimation组件,调用播放方法: img 路径编辑器 使用该组件可以做一些寻路的效果： 1.场景中创建一个Cube，添加DoTweenPath组件： img 2.运行程序： img "],["2020年年终总结和第二个长期学习计划","2020年12月12日","/2020/summary/","2021年了，离制定第一个5年计划 己经过去了将近5年， 回头再看这些内容发现有些现在己经被更好用的工具替代了, 或者被吞并了， 不禁感叹技术的发展让人眼花缭乱， gulp被webpack取代， atom被vscode收购，github被巨硬重金买下， angular2都特么混到V11了， 当时觉得牛逼的jquery纷纷被各大厂抛弃。 国民老公被记在小本本上， 国民老婆从林志玲也变成了黑泽志玲。 时间真是把杀猪刀， 被生活无情的按在地上摩擦了5年， 从一个刚入社会的小萌新变成一个大叔。 我秃了但我感觉我也变强了， 感觉是时候制定一个新的5年计划了， 合计合计下一个五年继续折磨我的头发的会是哪些东西。 最后敢问各位道友， 日本植发哪家强？ 第一个五年学习计划回顾 2016年 ​\t刚毕业的时候作为一个小萌新，对什么都充满了好奇，但什么都不懂。最开始使用FTP存代码也没有觉得有什么不对，至到后来毕业设计项目的代码再也找不到了痛苦了好一阵子。后来知道了SVN这个神奇的东西之后感概技术改变人生，如果早点知道这个代码管理工具就不至于丢失具有纪念意义的代码了。 ​\t由于大学不是计算机专业的关系，毕业之后从事技术相关岗位的同学屈指可数。或者说只有我一个人，不知道当时怎么有那么大的勇气自己一个人踏入陌生的领域。也许是因为毕业的压力吧，不得不感慨人的潜力是巨大的。大四的时候到处参加宣讲会，腾讯、百度、360、YY、九城等至今还记得的一些公司，然而都被无情的摩擦。最终进入了一家游戏研发（CP）的公司开发游戏。这一年来主要维护着一款线上的游戏，添加一些新的功能和新的活动，正常的版本更新维护等等。 ​\t这一年接触了新的开发工具SVN，新的IDE JetBrains IDEA，新的同性交友网站 gayhub ，新的NIO框架 netty,mina等，新的Java测试框架Junit。学习了html/css/js的基本页面布局开发技术，linux系统的基本操作等,算是基本上入了编程的门槛。 技术上来说： 了解了游戏开发的流程 开始使用github保存自己的代码 使用hexo搭建了自己的博客 使用vue构建了自己的主站 学习了web开发的基本知识 能够使用java开发游戏后端的功能 学会了使用linux环境进行运行环境的搭建和版本的更新维护 能够熟练的使用jetbrains家族的产品 学会了vim编辑器的功能 使用oh-my-zsh对我的终端进行了各种折腾 2017年 ​\t人生的20多年来，如果说到玩游戏我还是非常有信心的，从小学时的掌机、小霸王、街机，到初中时的电脑游戏CS、红警、流星蝴蝶结、仙剑、侠盗飞车，再到后来的网络游戏传奇、问道、诛仙、QQ飞车、QQ炫舞等比较主流的游戏都玩了个遍。但是从来没有想过自己能够开发出一款人尽皆知的游戏。但是就在这一年我开始参与开发公司的一款flash pc游戏，学到了游戏开发的各种技术。曾经神秘的游戏背后的逻辑原来都不是魔法，就像普通人观看魔术表演一样只会感叹多么神奇，而进入了游戏开发行业才发现原来游戏的制作也是那么的普通且~有趣。 ​\t这一年我解开了游戏开发神秘的面纱，让游戏制作不再遥远。像以前玩游戏的的使用道具不知道什么原理，原来逻辑是将玩家背包数据中要使用的道具删掉，再执行对应道具的功能的操作最后将道具使用通知和使用效果的通知发送给客户端，客户端收到消息后播放对应的动画刷新UI等等。再比如说原来游戏中的金币/元宝等看起来都是一样的，但是背后还分了很多种类比如充值的元宝、系统送的元宝、交易道具获得的元宝等等。虽然玩家看到的是这些种类的总数，并无感知，但是它们有各种不同的itemId，实际上是不同的东西。只不过购买道具时允许扣除多个名字都是元宝的itemId而已。这些我之前都是不了解的，进入游戏行业之前玩游戏就是单纯的玩游戏，为了快乐时光也好为了打发时间也好，目的都是很单纯的。但是入了游戏行业之后玩游戏的时候会不自觉的思考某个功能是怎么实现的，如果是我的话我会怎么设计，怎么实现这样的功能等等。这样的变化在其他行业也能体验，我有一个要好的朋友做了UI设计之后打开APP的第一件事就是研究App的设计、交互是否合理，有什么值得借鉴的地方，有什么地方有待改进等等。不自觉的会进行思考。 ​\t技术上来说： 将自己的个人网站全面切换到https 使用宝塔管理我的linux运行环境 掌握了SpringBoot连接mysql进行CURD的各种操作 掌握了markdown的语法，能够使用markdown写各种分享 购买了属于自己的服务器和域名，尝试从0到上线一款新项目的整个流程 学会了nginx服务器的基本配置和使用 学习了angular2的开发使用方法 学习了webpack的各种配置 学习了node开发相关的技术,koa/express连接mysql/mongodb开发API和网站 接触到了lombok开发插件，从此便离不开 在各种api文档同步问题了深受折磨后接触到了swagger UI，从此经手的所有项目的API都会被我集成swaggerUI 使用Java的jsonp和node的爬虫框架进行数据爬取收集技术的学习和开发 学习了maven构建工具的使用和多模块项目的配置。 深入学习了spring boot/spring data jpa等后端开发框架的技术 系统的学习了vim这个编辑器之神，能够较为熟练的使用vim进行文件编辑 折腾了黑苹果，搭建了mac上ios开发的环境。 学习了android/ios的移动端开发技术，做了直播软件和汇率换算的软件的demo。 学习了shell脚本的开发。 狠心买了mac book air丐版，不用在黑苹果系统下委屈求全了，主开发环境切换到mac os。 买了HHKB这款只有60个键位的信仰键盘，曾经很长一段时间CTO在我电脑上调试代码都无法找到快捷键。 经过了边工作边学车的半年煎熬时光（半年无休，单休+1天学车）终于拿到了驾照。 2018年 ​\t在经历了2017年近半年的无休工作，感觉到单休的工作模式己经失去了生活的意义，因此有了换一份双休工作的念头。但是在CTO的挽留下选择继续开发游戏，因为这也是我热爱的工作内容。在2017年过完年之后买了心心念念的神车思域，还做了很多攻略加装了各种配件，对它待遇相当不错。计划着2018年结婚，所以2017年计划到日本旅行，正好当时有一个小伙伴也想到日本旅行,所以便一起做攻略在10月长假进行了为期半个月的旅行并生产了一篇 日本游记 ​\t开始作为主程开发新的h5游戏，工作状态也发生了非常大的变化，原来单休的工作时间己经是不堪重负了再加上作为主程进行新项目的研发加班、通宵成了家常便饭。由于制作人(93年生)经验欠缺，技术能力不足等各种原因有着做不完的需求，乱作一团的版本规划，在原本规划好的版本里强行强入新需求等等。现在回头想想也感觉自己作为主程太逆来顺受，没有据理力争为组员争取到合理的开发时间导致大家工作内容十分繁重，后面也进行了一些反思主程职责总结和反思 。 技术上来说 考取了oracle的java gold的认证。 独立带项目，不再是做好项目功能开发就能算工作完成的状态。 协调部门之间的工作，工作内容的分配，项目进度的评估，代码的review，线上版本的更新，开发环境的维护等等工作都需要自己来做，所以对于学习工作所需之外新东西的时间就变得非常有限。 主程职责总结和反思 从之前的纯业务逻辑开发开始转向性能相关问题关注点，jvm优化等内容。 开始有计划性的阅读和学习JDK源码 JDK源码系列 开始学习docker的基本使用。 学习unity3d游戏客户端开发技术，做了坦克大战 , 愤怒的小鸟 , 2048 等小游戏和 RPG游戏Demo 学习了c#游戏服务端开发框架 photonServer的使用 PhotonServer 开源了SpringBootUnity 的template类型的项目，获得开源中国首页推荐和精品项目 gitee 2019年 如果说2018年是工作之后的人生转折点的话，那么2019年这一年就是转折之后的习惯过程。从大学远离故乡，到毕业到沿海城市就业，再到去年来到东京,这一个个的决定无不是对自我挑战的过程，这期间伴随着阵痛，同时也伴随着成长。有的人习惯了熟悉的生活非常害怕改变，怕换工作，怕搬家，怕交新朋友。各种各样的改变都会对生活带来冲击，但也带来了新鲜感，还是要看自己怎么样来看待这种改变。 进入华人派遣 来日本之前也算是搜集了不少的信息，经过了各种考量觉得进华人派遣公司是当前的最优选择。一般来说到日本做IT相关工作，如果没有日本留学经验，都会经历 这个过程，而我正处在这个初级阶段但不想长期处于这个阶段，所以为此也做了一些准备。 2017年年底通过了Oracle java认证 2019年7月考取了日语能力测试N2证书 2019年8月获取日本汽车驾照 2019年11月参加了中国国家软件考试(软件设计师)，但没有通过，以后有机会再考吧 2019年12月参加了日语能力测试N1测试（同样没过） 学习Angular/Vue前端开发框架(Javascript/Typescript) 学习Unity3D 但是，如果按照这个计划的话在日本转职至少要2次。日本是一个对跳槽容忍度比较低的国家，一份工作干不到2年就辞职会觉得不稳定，对找下份工作和申请永住签证都有一定的影响，所以打算直接进入游戏公司工作。 技术上来说 学习了sass/less/postcss等一些css增强框架 学习了bootstrapUI框架的使用 看完了 javascript 高级编程和javascript高级程序设计 看完了何品翻译的netty in action的书 初步学了一下 深入jvm原理的书 学习了代码重构、effective java等提交代码质量的内容 学习了restful风格的API开发 学习了 git flow开发工作流 折腾了zsh+iTerms的终端环境 生活上来说 女儿出生了，变正了真正的一家3口 拿到了日本的驾照 拿到了N2的日语证书 给家人办理了家族签证 面试了几家游戏开发公司，对游戏开发有的新的理解和思考。 拿到了游戏开发公司的offer，但由于被所在的华人派遣公司摆了一道没能及时入职。 这一年时间到刚到日本，工作习惯发生了不少了变化，所有新的知识学习都记录了onenote导致博客更新频率非常感人 2020年 2020年整体来说，是一个非常魔幻的一年，至今都还是像做梦一样。打乱了很多既定计划，遇到非常多困难的时刻，不过这些困难并不是我一个人碰到，全世界都笼罩在魔幻当中至今没有出来。因为2019年过年没有回老家，所以2020年决定回家过年。于是在1月20日东京飞杭州再从杭州自驾回湖北十堰。回国之前己经听说了一些相关コロナ相关的消息，同事也告诫我要注意安全，所以当时回家时刻意绕过武汉从襄阳回家。当时武汉发布消息的人被抓，央视出来背书说不要危言耸听，我竟然就这么相信了，只买了一袋5个装的口罩就回去了。导致之后的好几个月被关在家里不能出门，口罩几十块一个而且还买不到。买菜不能出门，在微信群发消息订购志愿者去采购，结果送的米发霉严重每次做饭整个家里都有很大一股霉味。说实话，那段时间真怀疑有没有轻度抑郁，莫名的非常暴躁，电脑也没带回家，什么事都做不了。一直到5月份才能回到杭州找了一份临时的工作，为了还房贷车子也卖掉了；半年没有收入，房子没交房也住不了，杭州的房租还要交，日本的房租还也得交，还有孩子要养，感觉每个月都是焦头烂额，现在想想挺过2020真的是太难太难了。一直到8月份日本才允许工作商务签证的入境，算算时间整整半年时间的计划全部打乱，家庭支出严重不足，定的学习目标全部耽搁，我和这个世界一起停摆了半年，终于在8月底回日本渡过了居家14天的隔离之后在9月份开始正式回归工作岗位，截至到11月份生活才慢慢回归正轨。虽然到现在为止整个世界依然被コロナ折磨着，但是经过了将近一年的共处，说麻木也好，习惯也好，这个世界的人们也接受了コロナ存在的事实，虽然每天还是做着正常的工作，过着正常的生活，但是心中依旧在担忧，在忍耐这场灾难什么时候能过去。 技术中来说 学习了新的开发语言 学习了新的移动端开发框架 学习了新的游戏引擎 使用 的蓝图做了一款小游戏 muffin2d 制作了一款跨平台的电商app己上线到 和 对 及相关技术的使用更加熟练了 系统了学习了 框架的用法 学会了 相关协议及开发的内容 学会了 的相关技术和使用方式 开发了 和 的新功能 开发了apple sign in 的新功能 学习了vue相关的技术（包括vue2.x,vue3.x,vuex ,element-ui等） 学习了react相关的技术 学习了aws cli 的基本命令用法 学习了node项目性能监控工具pm2的用法 学习了aws sns/sqs 和spring boot集成的用法 学习了redis的pub/sub模式 用法 学习了aws dynamoDB 的集成和CRUD相关的操作 开了一篇长期向的博客分享npm常用库的用法 学习了前端项目/后端项目集成datadog进行数据上报的用法 学习了http请求框架fetch/axios/redaxios等 生活上来说 决定长期在日本居住 更新了3年的新签证 本来打算软考的计划被耽误 为了还贷失去了小车 杭州的房子交房了，买了些家具出租出去补贴家用 和老婆孩子在日本团聚了 报名了12月份的N1考试，但是没有花太多时间学日语大概率通不过 给孩子申请了明年的保育园 第二个五年学习计划 开发语言 ※ C# 主要是针对unity3d需要用到c#语言，大概语法己经了解，和java类似使用起来没有难度。后续如果想要提升的话就需要通过项目实践来提升熟练度，打算仔细想想做一个什么样的游戏项目来提高自己的技能熟练度。 C++ Unreal engine劝退的大分部人感觉应该是c++这个开发语言，c/c++这门语言古老而稳重，学习曲线较高。从入门到放弃至少有5次以上了，但是虚幻5是真的香啊，所以必须要学习。不过因为工作上用不到，而且时间比较有限暂时还不会花费较多时间在上面。 ※ Typescript 最开始接触ts是在angular2的beta版本的时候，当时还同步推出了一个Dart分支的angular，但是基本上没什么人使用。我当时就很好奇dart是个什么东西，但是却没有深究。平时的工作中后端主要使用java，前端主要使用ts，所以ts的学习一直在进行中。目来来说公司的项目基本上都在往ts上转，所以现在对ts的掌握程度是能够应对正常的开发，但是还需要进一步的提高。 ※ Java java是我进入编程行业的入门语言，虽然它没有js和python简单，但是它是面向对象的语言，结构严谨，比较贴近自然语言，学习难度不大。截至到2020年底使用java己经有近10年时间，从jdk6到现在主要使用的版本jdk11，总体感觉java的生态比较稳定，就算不升级到java11,使用java7或者java8也完全能够胜任日常的工作。刚开始接触的ssh框架+jsp和servelet现在也不怎么听得到了。springboot/spring cloud成了后端开发的标配，后续的计划是围绕着spring boot/spring cloud深入学习。 Python 最开始接触python语言是作为游戏主程的2018年，当时需要维护一些组内的开发工具的脚本。bash的语言实在是用不习惯，所以将老的工具都用python重写了，后续的工具开发也是python开发的。虽说如此，也是对python的语法仅仅是能使用，时间久不用的话语法又忘的差不多了。如果想要深入学习的话还是需要以项目为基础进行锻炼，后续的打算是自己如果再写api的话可以用python的flask来写，而不是java。 ※ Dart 无意间接触了跨平台开发框架flutter，再次看到了熟悉的开发语言dart。这一次不会只混个脸熟了，为学习flutter为契机顺便学会了dart。这个开发言语是到目前为止所有学习的开发语言中最省力的一个，语法像是java+typescirpt的组合。所以学习flutter的时候主要精力放在框架上，语言顺带看了下语法基本上就会使用了。dart语法目前来说感觉没有太大的提升空间，移动端开发的业务也不会因为dart的语法有障碍，所以暂时没有深入研究dart的必要性。 语言 ※ 日语 算起来接触日语也有5年时间了，但是这5年来断断续续的记了些单词学了些语法，自学基本上就是这个样子。有空的时候就学学，没有系统性，所以日语的能力一直是基本能用的样子。虽然也考到了N2证书，但是感觉和日本的小学生语言能力应该差不多，所以后续的主要精力会花费在学习日语上，争取早日考过N1。不论是因为N1证书高级人才加分也好，还是在这个国家生活也好，没有理由不好好学日语。 ※ 英语 作为一个技术者，华人还是挺悲哀的，基本上所有的技术都是外国的，活在大陆还有高墙，想学个东西经常会因为网络环境异常的麻烦。所以培养自己的外语能力还是非常重要的，作为一个技术者只要还在这个圈子就要不断的学习。而中文圈子里的内容要么是无脑复制粘贴没有验证就随便往网上发的，要么搜到的资料是老的，基本上用不了。很多工具/框架的官网都只提供了英文的文档，所以英语能力的提升也是极为的重要。但是学习语言是一个非常耗费时间和精力的事情，同时学习多门语法还要兼顾工作和生活是非常困难的。所以目前主要的精力还是日语，平时工作的时候刻意多看一些英文的官方文档。不要用翻译，遇到不认识的词查了记一记提升也是很明显的。 开发工具 IDEA 从正式开发工作时就开始使用IDEA作为开发的主要的编辑器，无论是对快捷键的熟悉程度还是对工具的使用熟练度都足以应付日常的工作，所以之后我还是会继续以jetbrains系列的开发工具使用为主。 VSCode 折服于vscode的轻量和颜值，我不断的在对vscode的尝试和放弃中挣扎。被jetbrains系列工具惯坏了感觉其他开发工具都不好用，于是尝试了多次都放弃了。但是随着这么多次尝试也是有收获的，也慢慢的习惯了用vscode开发，虽然感觉有很多不顺手的地方，但是配合着IDEA使用也没什么问题。后续的计划是java开发使用IDEA，前端开发使用vscode然后以IDEA为辅助。多学习一些vscode的用法，找一找vscode好用的插件。 Android Studio 开发flutter的时候用android studio不仅能构建android应用也能够开发ios应用，这也是我我喜欢jetbrains家族的IDE的重要原因，生态非常的好，想要用到的东西基本上都有对应的功能。但是jetbrains也有不好的地方，非常的吃配置，价格昂贵等等(划掉，反正白嫖)。所以平时写flutter也可以使用vscode安装flutter插件来工具，如果需要构建android环境的话可以使用android studio打开构建。 Rider 它同样是jetbrains家族的IDE，是c#语法开发的IDE。网上都说visual studio是宇宙第一IDE。但是和rider相比，我没有觉得它有任何一点能够胜过rider，而且还是跨平台的IDE。所以我写c#的时候首选会用rider。 Pycharm 这同样是jetbrains公司的IDE，是针对python开发的IDE。从我学习python开始，大一统推荐的都是pycharm，如果你问我如果写python不用pycharm的话\u0026hellip;我应该会用vim吧。 vim vim作为linux系统的默认编辑器，想当初打开vim编辑内容后却不知道怎么退出的萌新状态现在虽然是找不回来了。但是对vim的使用也仅仅是停留了能够对文件进行编辑，并没有达到使用vim进行项目开发的熟练程序。后续可能会考虑在写前端的时候用vim练一练熟练度。 emacs emacs作为神之编辑器，还是挺神秘的。emacs的学习曲线比vim要难上很多，还要使用Lisp编程语言配置环境，适合想折腾的极客。我想我还是愿意折腾一下的。 Git git是在我短暂的使用svn后切换过来的，使用体验和当初从eclipse转到IDEA的感觉是一样的，感觉真的是太得劲了。分支系统，多任务并行 ，git flow开发模式，逻辑清晰合理，团队协作必备良方。现在对git的使用算是基本上没什么问题，但是能再深入学学当然是更好的。 tmux tmux作为分屏最终解决方案，听到了太多关于它美好的描述，但是一直是停留在传说上。据说它能够提高工作效率，保存工作环境后一键恢复，听起来还是有点小激动，也列在我的学习计划中。 前端框架 flutter 用flutter也算是做了一个完整的线上项目了，google play和apple store都己经上线且版本更新己超过10个版本。算是一个商业级的项目经验了，flutter是一个非常年轻的框架，而且野心不小。对web的支持还没有完全成熟，而且google的funsia系统也还没有发布。还算是在蛰伏期，我还是非常看好flutter的前景的。以后有什么好的想法需要做app的话我肯定会首选flutter。 vue 现在公司的项目前端技术栈还是挺多的，三大框架轮番上阵，自然vue也少不了。vue是唯一一个华人的非大公司背景的和另外2个巨头同一地位的前端框架，其工具链生态，学习成本，文档等各方面都是非常的值得学习。经过了3个后台的开发，现在基本上是对vue的使用没太大问题，但是感觉需要深入学习的东西还有很多。vue3也出来了，vue+typescript的组合肯定会更好。 SCSS 偏后端的全栈开发者应该都对css比较头疼，它不像编程语言那样不是1就是2。它像一层层形状不同的网叠在一起，最终呈现出来的样子是什么样的得在浏览器里实际查看才知道，而且它没有变量，没有条件判断，没有函数。 scss是一个css的增强框架，如果你对scss不熟，也完全可以在scss文件里写css语法。如果你很擅长scss，那也可以写变量，函数，判断各种和编程语言一样的控制css，是不是觉得很酷。 React 学习最终是要付诸实践的，没有应用于项目的学习在一定程度上来说是无用的学习。所以学习新技术当然除了兴趣使然，更重要的是以公司的实际需求出发。react是目前全世界使用最为广泛的前端开发框架，公司项目也在使用，有什么理由不学呢。 webpack 前5年的学习规划中webpack还处在版本1，还是一个非常稚嫩的框架。当时的学习目标还是browerify、grant、gulp等等构建工具，短短几年时间webapck己经实现了大一统。当时学习webpack的时候各种配置学的迷迷糊糊，现在各大框架都将webpack封装到自己的框架内部，给开发者发提供了简单友好的API配置。新入行的小萌新甚至感受不到webpack的存在，但是没有感知并不代表它不存在。在实际的项目开发中很多的配置需要根据实际情况定制，所以手动配置webpack还算是一个刚需。 nutx.js nuxt.js是vue SSR（服务端渲染）的解决方案，它集成了vue,vue-router,vuex等各种工具。按照约定的结构开发项目，便能够自动生成路由渲染出html，是一个非常值得学习的框架。 后端框架 Spring boot springboot这个框架的出现可以算是java开发者的福音，当初学习spring的时候各种xml的配置把人折腾的欲仙欲死。有了springboot，不需要下载tomcat，不需要配置xml，创建项目就可以写业务，怎么会有这么完美的框架存在。它的功能和spring全家桶大而全，基本上涵盖了所有业务所需的技术，所以学习难度也还是非常大的。现在的业务开发中虽然使用没有问题，也开源一个将近千星的springboot相关的项目，依然不敢说对springboot精通，还有很多需要学习的地方。 Hibernate hibernate和myatis是对db的不同实现，它是基于ORM的实现，可以通过实体类生成sql表。也可以在整合了spring data jpa的情况下使用自然语言代替sql进行查询，感觉非常的极客，如果自己做一些小项目用它可以提高效率。但是灵活程度比mybatis要差，至至怎么选择得看项目实际情况。既然能做选择，前提是得会用，所以学习它是必要的。 Mybatis mybatis从入行到现在乃至以后，这个框架一直是绕不过的。灵活方便，使用简单。关于mybatis自动生成xml和条件查询的使用还需要查询示例。 Django 个人感觉像是python版的express,大而全的一个web框架，个人更喜欢flask这种轻而小的框架。 express.js node版本的spring，大而全，用起来比较省心。 flask pythonp写api的首选框架 koa2 node写api的首选框架 数据库 mysql 从业以来使用最久也是业界使用最普遍的数据库，免费强大，使用方便。 graphql 比较新兴的数据库，个人很喜欢，以后有机会可以在项目中使用一下。 redis 缓存数据库的一只独秀，想在项目上加个缓存数据库的话基本上就是redis了。 游戏开发 Unity3D 之前调查过很长一段时间，不管是在中国还是在日本市场，unity的工作岗位和使用都较unreal多出很多，资料也相对较全，学习容易。所以陆陆续续用unity做了好几个小游戏，后续打算进一步的深化相关技能。 Unreal Engine 一直对unreal抱有极大的兴趣，但是因为c++不熟悉所以一直是从入门到放弃的循环。看到虚幻5发布的视频之后坚定了入了循环的阵营，又重新开始学习虚幻。发现学习blueprint入门比较简单，也使用了unreal的blueprint做了一款游戏。但是因为精力有限，有很长一段时间没有继续学习unreal了。虽然ue功能强大，但是因为学习难度大，个人开发者很少有人驾驭得了，所以后续打算还是以unity为切入点，如果有机会进入游戏开发公司再学ue吧。 高级人才 N1证书 虽然报了2020年12月的N1考试，但是因为2020年耽误了太多时间导致学习日语的时间极为有限。对于考试合格己不报希望，来年6月再战N1。 软件设计师 本来计划2020年6月考软件设计师证书的，但是被取消了之后所以计划也被打乱，看2021年有没有机会考吧。 基本情报技术者 目前日语能力太差导致不太能看懂相关试题的内容，所以暂时不打算考试基本情报。计划排在N1通过之后再考吧。 工作相关 随着公司项目的需要学习新的技术并进行总结，并发布博客。 坚持每年进行一个总的复盘，总结一年来学到的东西，之后还需要加强的地方。 前程相关 坚持学习新的知识 生活质量相关 尽快考过N1，为了更好的和别人进行沟通交流。 申请高级人才签证，因为目前证书都没有考分数达不到80，所以2021年年初就以70分为基准申请吧。 家人有关 已经申请了2021年4月孩子的保育园，2021年2月份能够得到结果能否入园，如果能够入园就送老婆去日语培训班学习日语。 "],["postman和commandline tools（newman）用法介绍","2020年12月12日","/2020/newmancommandline/","不知道大家对大批量重复性的工作内容的第一反应是怎样的，我的第一反应肯定是写脚本，还得是python的。但是发现postman对批量api调用也有了较好的支持，所以便省去了写脚本的过程，直接使用命令行就可以了。 postman介绍 postMan是一款功能强大的网页调试与发送网页HTTP请求的工具。postMan能够发送任何类型的HTTP请求(GET, HEAD, POST,PUT..)，附带任何数量的参数和HTTP headers。支持不同的认证机制（basic, digest,OAuth），接收到的响应语法高亮（HTML，JSON或XML）。 postMan既可以以chrome浏览器插件的形式存在，也可以是独立的应用程序存在。可以到https://www.getpostman.com/下载。 操作环境 postman适用于不同的操作系统，Postman Mac、Windows X32、Windows X64、Linux系统，还支持postman 浏览器扩展程序、postman chrome应用程序等。 Postman重要提示： 由于2018年初chrome停止对chrome应用程序的支持，你的postman插件可能无法正常使用了。目前chrome应用商店能使用的就是chrome扩展程序和主题背景，在这里建议大家直接下载它的应用程序进行使用。 postman界面介绍 img postman工作机制 像项目开发一样可以工程化管理 可以邀请团队成员进行协作，一次配置，多人使用 postman有工作工间和collections，workspace就是我们的工作区，collections就是我们的项目。 批量处理 可以直接在postman里跑runner,但是在这之前我们需要配置要跑的API 举例： 我们这里用twitter的api为例，它需要传auth1.0的参数和user_id来获取twitter用户的详细信息。 URL 我们需要请求的API地址，这里以https://api.twitter.com/1.1/users/show.json为例 参数 因为我们是要跑runner，所以参数肯定不是固定的，所以我们定义一个参数，用双花括号包里来 image-20201217145048523 环境 我们直接这么定义的参数名肯定会找不到，所以我们需要创建一个对应的环境 Auth(不是必须) twitter的接口访问需要我们提供对应的auth1.0的权限，所以我们要做相关配置，如果请求的是不需要auth的api则不需要配置 测试用例 完全的js语法，具体使用参考官方示例 image-20201217145602484 这样我们的准备工作就做好了，然后打开上一步的runner，就可以跑测试了。 twitter1.json文件示例，数组中有多少数据iterations会自动修改。 也可以用csv文件的格式，但是有一个文件是provider_id是数字字符串，postman会把当成数字丢失精度，比如 会变成 ,所以我将csv转成了json。在线转换工具 twitter1.csv image-20201217150118155 这里控制台打印了接口调用的详细信息和我们刚才测试用例中打印的内容 一般来说到这里就结束了，但是我们跑runner的话有可能是自己观察一下数据就好了，也有可能是需要将跑出来的结果保存下来交给市场部做分析，所以我们需要导出相关的数据，这时我们就需要postman的command line工具了。 newman postman提供了npm的包，我们可以在node环境下调用，也可以全局安装后使用命令行调用。 提供了基本的运行环境， 可以导出一个html的报告，但是很简单也很丑，我们可以安装一个 来导出文件 基本的html报告 使用 跑出来的报告，有很详细的内容报告 可以查看每个api调用的请求地址，请求头，返回头，返回体等各种信息 命令格式 , collections.json可以是一个url也可以是一个json文件 例如 基本的html报告 详细的html报告 文件获取方式 作为一个精益求精的人，怎么会就这么结束。postman导出的基础报告只有简单的多少个通过了测试，多少个失败。加强版的报告虽然内容够全，但是想看数据一个一个点开麻烦的一批，所以只能这么结束吗？当然不是 newman批量API调用结果导出到文件 twitter.log内容，包含了每次调用详细的数据和最后的总结，简直完美 "],["js/ts常用公有方法收集整理(长期向)","2020年12月12日","/2020/jscommonutilsmethods/","不管是什么语言，不管是前端还是后端，我们都有一个很重要的模块，那就是utils包。在java界有apache-commons这种出身明门的，也有像hutool这种民间的库。前端界目前还没有发现一个比应用比较频繁的库，那就出一个长期项的自己整理整一下吧。 注： 本篇文章开始于2020年12月8日，每次修改或新增时都会将时间更新时最新的时间。 动态创建meta的方法 使用 对函数只执行一次 使用 获取URL参数 注：不支持 具有锚点的URL，例如 。 只支持直接在url上拼参数的方式 动态创建script 需要安装 loadjs 邮箱格式检测 "],["npm优秀库使用收集整理(长期向)","2020年12月12日","/2020/npmpackagecollection/","虽然自栩全沾工程师，但是对于前端圈的了解还是相对缺乏的，尤其是大量的npm包。java的maven/gradle， node的npm， swift的pod,，python的pip，php的Composer，c++的Conan 等等。基本上每一种开发语言都有自己的包管理器。开源三方库汇集了全世界的智慧结晶，有了这些优秀的三方库能够让我们很容易的完成复杂的功能。所以打算开一个长期向的优秀库的使用收集博客。大部分内容是搜索到的优秀博文整理而来。 注： 本篇文章开始于2020年11月20，每次修改或新增时都会将时间更新时最新的时间，每个库的使用也会标注版本和来源。 ajv(v6.12.6) 作用 ajv 是一个非常流行的JSON Schema验证工具，并且拥有非常出众的性能表现。下方的例子中，我们使用ajv来验证用户输入的表单数据是否合法。 在上述代码中，我们声明了一个数据模式 ，这个模式要求目标数据为一个对象，对象可以有五个字段 、 、 、 、 ，并分别定义了五个字段的类型和数据格式要求，并且其中 、 、 必填。然后我们使用这个模式去验证用户输入的数据 是否满足我们的需求。 注意： JSON Schema 是一个声明模式描述对象的标准，并非一个库 ajv 是一个JSON Schema标准验证器的实现，除了ajv还有很多其他的库 代码中的 是使用 JSON Schema 生成的模式描述对象 代码中 是我们要进行检查的数据 参考资料 JSON Schema http://json-schema.org AJV https://github.com/epoberezkin/ajv 来源: https://segmentfault.com/a/1190000013265287 accounting(0.4.2) 作用 accounting是用来格式化数字的库， 主要提供的方法有 接下来我们一一介绍： formatMoney() 格式化货币 formatColumn() 格式化并按列对齐 在制表时， 方法方便我们按照表格列对齐数字和货币符号： 格式化后的效果： 图片描述 formatNumber() 格式化数字 toFixed() 保留小数位 和JavaScript内置 不同的是， 有四舍五入的效果： unformat() 解析数字 方法能够从任何格式的字符串中解析出原始数字： 参考资料 http://openexchangerates.github.io/accounting.js/ https://github.com/openexchangerates/accounting.js 来源: https://segmentfault.com/a/1190000013201803 async-retry(1.3.1) 作用 异步的执行对某个操作的重试，可以设置重试次数。 使用demo 说明： 提供的功能可以是async或不是。换句话说，它可以是返回Promise或值的函数。 提供的函数接收两个参数 将opts被传递到node-retry。阅读其文档 retries：重试该操作的最大次数。默认值为10。 factor：要使用的指数因子。默认值为2。 minTimeout：开始第一次重试之前的毫秒数。默认值为1000。 maxTimeout：两次重试之间的最大毫秒数。默认值为Infinity。 randomize：通过乘以介于之间的因数1来随机化超时2。默认值为true。 onRetry：可选Function，在执行新的重试后调用。它传递了Error触发它的参数。 chalk(4.1.0) 将在终端中输出蓝色带下划线的MCC。 chalk 虽然我们已经学会了，在终端中控制字符颜色的原理和方法，但是这种操作太过于繁琐，每一次都需要查颜色样式手册，然后写出一堆无法阅读的火星文，抓狂！ 今天介绍的NPM库chalk就是用来优雅地输出带颜色的文本，不需要记忆、查阅样式手册。 安装 Level Description All colors disabled Basic color support (16 colors) 256 color support Truecolor support (16 million colors) 使用 chalk 将各种颜色和样式修饰符实现为各个函数，并且支持链式调用。 效果 image-20201204181923326 文本样式修饰符函数 ​ 颜色函数 ​ 背景色函数 ​ 源码 https://github.com/chalk/chalk ora(5.1.0) 优雅的转圈圈,让你的等待不再煎熬～ ora 使用 https://github.com/sindresorhus/ora figlet(1.5.0) 使用 效果 image-20201204182909081 boxen(4.2.0) 给你的代码画上界限,守护自己的地盘～ 使用 效果 image-20201204183307440 https://github.com/sindresorhus/boxen classnames（2.2.6） 快速的组合class name 在前端开发中，我们经常需要JS来判断生成DOM节点CSS类，比如： 在上述代码中，我们需要判断active变量来控制生成的按钮的CSS样式是否是激活状态，在实际开发中，可能会有更多的类似这样的样式控制逻辑，从而干扰阅读业务逻辑代码，使得代码变得很“脏”。 classnames classnames 库对CSS样式类操作进行了封装，方便我们快速使用： 更多调用方式： https://github.com/JedWatson/classnames concurrently（5.3.0） 主要是方便我们写前端工程化的时候，我们可以同时启动多个命令用。 比如我的前端代码运行起来，既要有一个web工程，同时又要启动一个mock进程。这时候我们就可以使用这个并行解决方案。 文档地址：https://www.npmjs.com/package/concurrently github地址：https://github.com/kimmobrunfeldt/concurrently 全局安装 项目安装 以上果是开发阶段写工具用的时候的安装方法。 如果比如node项目在生产环境使用则用以下安装方法： 三、使用方法 3.1 命令行使用方式 语法: 比如我要启动两个node程序: 然后当我们ctrl + c后，他就会把两个进程都停止了。 方式1： 如果我们在package.json里面则要注意引号的问题: 就是将\u0026quot;变成\u0026quot;. 方式2： 然后我们要让这个进行并行有两个方式，在命令行执行: 或者: 这块-n之后的两个单词，只能用,间隔，不能加空格。 方式三： 如果我们的package.json里面有以下三个watch类型的 那可以批量执行的方式: 我们可以书写一个node程序来调用concurrently。 我们写一个main.js的代码 然后它的效果，就是 然后当我们按了ctrl + c之后，他会打出success. 上面的index和hello对应的代码是: index: 3.2.2 构建失败场景 我们修改上面的hello的代码: 然后我们在运行\u0026quot;node ./main.js\u0026quot; 我们会看到报错，但是程序不会退出。 然后当我们再按ctrl + c后，效果如下： 所以得出一个结论：当我们有一个进程返回失败的话，总体会进入fail的callback中。 应用场景 开发工具 比如当我们跑npm run start的时候，我们同时需要让sass编译，同时webpack也要跑hot 模式，则这个使用可以使用concurrently运行这两个command。 这块我们可以查看grafana里面的前端代码中，关于工具这块代码查看一下就可以看到这块的使用。 grafana地址: https://github.com/grafana/grafana 常见需求 当一个进程起来失败，整体concurrently失败? 我们可以通过killOthers这个参数来解决。 这样当我们有一个程序失败，则直接进入fail callback。也就把所有进程关闭了。 6.2 当一个进程起来失败，但是有可能是跟另外进程有关，这时候需要尝试几次？ 这种情况，如上比如npm:index能启动的，npm:hello不能启动，虽然试了三次npm:hello，一直失败，但整体最终不会退出，只有我们按ctrl + c才有用，相当于killOthers就失效了。 cors(2.8.5) CORS是一个node.js软件包，用于提供可用于通过各种选项启用CORS 的Connect / Express 中间件。 安装 开启所有的CORS 开启单路由的CORS 配置CORS 配置多个跨域白名单 如果您不想阻止REST工具或服务器到服务器的请求， 请在源函数中添加一个检查，如下所示： 异步CORS https://github.com/expressjs/cors#readme cross-env（7.0.3） 像这样设置环境变量时，大多数Windows命令提示符找不到命令，我们使用跨平台环境时能够抹平这个不同。 安装 使用 直接在原来的脚本前加上 cssnao(4.1.10) 什么是缩减（minification）？# 缩减（minification）是指利用各种方法来 减少代码体积的过程。和 gzip 之类的保留 CSS 文件的原始语义（即无损失）的技术不同，缩减（minification） 天生是一个有损失的过程，例如，其中某些值可能会被替换为更简化的 等价语法，或者选择器被合并。 缩减（minification）步骤的最终结果是生成的代码将与 原始代码行为相同，但是某些部分被修改以 尽可能减少代码体积。 将 gzip 压缩和缩减（minification）相结合，可以最大限度的减少 文件体积，但是不要耳听为虚、眼见为实，为什么不去试试 css-size ？ css-size 是一个专门对比缩减（minification）前后文件体积大小变化的模块。 cssnano 是什么？# cssnano 就是这样的一个缩减器，它使基于 Node.js 开发的。cssnano 是一个 PostCSS 插件，可以添加到你的构建流程中，用于确保最终生成的 用于生产环境的 CSS 样式表文件尽可能的小。 如果你不了解什么是构建流程，没关系，我们在 入门指南 中做了讲解。 这对我有什么好处？# 大量的代码优化# 我们提供了众多不同的优化，从简单的 清除空白符到复杂的不同名称的同一 keyframes 的合并等。 更多信息请参考 预设指南 。 统一的 CSS 处理# cssnano 基于 PostCSS 来处理 CSS 代码。因为很多 现代化的 CSS 工具都是基于 PostCSS 开发的，因此你可以把这些工具组合起来 并生成一棵单一的抽象语法树（AST）。这就意味着总的处理时间 减少了，因为 CSS 不再需要进行多次解析了。 现代化的架构以及模块化# 因为 cssnano 是基于 PostCSS 的，因此我们可以将 cssnano 的功能拆解为多个 插件，每个插件只需负责执行一项小的优化即可。并且许多优化可以限定 到某一组特定的 CSS 属性上，这就比利用正则表达式对 CSS 做全局处理更加安全。 dotenv(8.2.0) 我们经常需要Node.js程序运行时加载不同的配置，比如开发环境和生产环境的数据数据库配置就可能不一样，使process.env.DB_HOST 环境变量，可以在Node.js程序内部方便获取参数信息。但是，程序启动时，怎样将环境变量传递给程序，这可能会是一个相对麻烦的事情，因为这关系到操作系统层的配置问题。 安装 配置文件 在项目根路径下新建 文件 然后，在Node.js程序启动时运行： 接着，我们就可以在接下来的程序中方便地使用环境变量了： 因此，我们可以创建不同的配置文件并提并git，然后在开发的时候copy一份 到根路径重命名为 就可以做本地开发了，线上部署同理。 image-20201204190948866 https://github.com/motdotla/dotenv#readme ini(1.3.5) 读取ini文件 写入ini文件 https://github.com/npm/ini ip(1.1.5) ip库能够获取本机IP地址、比较、转换、掩码/子网计算等各种和网络IP相关的操作： 参考资料 https://github.com/indutny/node-ip jschardet（2.2.1） 识别字符编码 jschardet 可以识别出一个Buffer数据所使用的编码格式，具体支持的格式包括： Big5, GB2312/GB18030, EUC-TW, HZ-GB-2312, and ISO-2022-CN (Traditional and Simplified Chinese) EUC-JP, SHIFT_JIS, and ISO-2022-JP (Japanese) EUC-KR and ISO-2022-KR (Korean) KOI8-R, MacCyrillic, IBM855, IBM866, ISO-8859-5, and windows-1251 (Russian) ISO-8859-2 and windows-1250 (Hungarian) ISO-8859-5 and windows-1251 (Bulgarian) windows-1252 ISO-8859-7 and windows-1253 (Greek) ISO-8859-8 and windows-1255 (Visual and Logical Hebrew) TIS-620 (Thai) UTF-32 BE, LE, 3412-ordered, or 2143-ordered (with a BOM) UTF-16 BE or LE (with a BOM) UTF-8 (with or without a BOM) ASCII 我们能方便地使用 jschardet 库： https://github.com/aadsm/jschardet iconv-lite(0.6.2) 将转换任意的字符编码到JavaScript内置的Unicode编码，以便于我们的程序和外部系统友好对接。 所有node.js本机编码：utf8，ucs2 / utf16-le，ASCII，二进制，base64，十六进制。 其他Unicode编码：utf16，utf16-be，utf-7，utf-7-imap，utf32，utf32-le和utf32-be。 所有广泛的单字节编码：Windows 125x家族，ISO-8859家族，IBM / DOS代码页，Macintosh家族，KOI8家族，以及iconv库支持的所有其他字符。还支持“ latin1”，“ us-ascii”之类的别名。 所有广泛使用的多字节编码：CP932，CP936，CP949，CP950，GB2312，GBK，GB18030，Big5，Shift_JIS，EUC-JP。 流API js-cookie(2.2) 一个简单，轻巧的JavaScript API，用于处理Cookie demo js-yaml(3.14.1) js-yaml 是一个专门用来读写YAML格式数据的库，他可以将JS对象转换成YAML字符串，也可以将YAML字符串转换为JS对象。 example.yaml 读取yaml https://github.com/nodeca/js-yaml log4jsdd(1.0.2) 图片 图片 图片 图片 图片 图片 图片 material-ui(4.11.1) 安装material-ui 安装material icons Material-UI组件是相互独立的，自支持的，工作时仅注入当前组件所需要的样式。这些Material-UI组件并依赖于任何全局的样式表，尽管Material-UI提供了可选的CssBaseline组件。 对组件的支持 Materail-UI在努力遵循实际的指导规范时，却并不期望支持每一个组件或者组件的每一个特征。Materail-UI更希望能提供一套能帮助开发者创建引人注目的用户界面所需要的构建模块和经验。 Material-UI 支持哪些平台？ Material-UI支持所有主流的稳定的浏览器，支持IE11以上。Material-UI还支持node.js v6.x以上的服务端渲染。 在哪里可以获取到demo资源？ 参见 Material-UI 的GitHub仓库 Material-UI常见的问题列表 类名冲突时怎么处理？ 当打开Modal时，为什么fixed定位的元素会移动？ 如何禁用掉app中的波浪效果？ 必须使用JSS来控制样式？ 什么时候使用行内样式？什么时候使用类名？ 在Material项目中如何使用React-Router？ 如何合并withStyles() 和 withTheme() ？ 如何获取DOM元素？ 为什么项目中的色彩和官方效果有差异？ Material-UI令人疯狂，我该如何支持这个项目？ 与其它UI库进行优势劣势对比 Material-UI Material Design Lite (MDL) Material Components Web Materialize React Toolbox **二、**样式 什么是 CssBaseline ？ Material-UI提供了一个CssBaseline组件以建立统一的简单的样式基准。 有关Material-UI默认样式的详细说明： 元素的margin为零。 在标准设备上，使用默认的背景色。在打印时，使用白色作为背景色。 所有元素的box-sizing都被默认设置为\u0026quot;border-box\u0026quot;。所有元素都包含 ::before 和 ::after 样式，以保证元素的width 和 height 包含padding 和 border。 使用Roboto字体，以避免了打印时的字体堆叠。 打印时，不会为标签声明基准字号，但会使用浏览器支持的默认字号16px。 认识Material-UI中的色彩系统 在Material-UI中，色彩系统是非常强大的。它支持粗色调、深阴影和鲜亮的强调色彩。 色彩系统中的重要组成： Palette，主色调。 Hue / Shade 色调、色度。 Icon系统 Material-UI提供了两个组件用于icon系统。Icon组件用于渲染icons，SvgIcon用于渲染SVG路径。推荐使用SVG Material icons。 // 安装@material-ui/icons 三、布局 Material-UI的布局设计基础 Material-UI布局，使用统一的组件和间距，实现了多平台、多环境和屏幕尺寸的统一性。 1、使用 Grid / Hidden / Breakpoints 这三类组件，实现响应式UI，适配各种尺寸的屏幕。 2、组件使用 z-index属性，实现 Z 轴上的空间层次排布。 Grid 组件 Material-UI的响应式UI，是基于12列的栅格布局。Material-UI的栅格系统是由 Grid 组件实现的，它使用了 CSS 弹性盒模型，它有两种类型的布局，分别是 containers 和 items。item的宽度被设置为百分比，因此它们总是基于父元素而流动、动态地变换大小。items使用内边距padding生成元素之间的间距空间。Material-UI栅格系统支持五种断点模式，分别是 xs / sm / md / lg / xl 。 Hidden 组件 Hidden组件用于隐藏任何内容，它可以结合Grid / Breakpoints组件一起使用。它的实现原理是，基于breakpoints进行显示与隐藏。 Breakpoints 组件 一个 breakpoint 就是一组预定义的屏幕尺寸范围，它决定了特定了布局需求。为了最适宜的用户体验，material design要实现多屏幕适配。Material-UI对material design规范进行了简化实现。每一个breakpoint都会匹配一定范围的屏幕尺寸。 xs, 特别小的屏幕，0px or larger sm, 小屏幕，600px or larger md, 中等屏幕，960px or larger lg, 大屏幕， 1280px or larger xl, 超大屏幕， 1920px or larger 以上这些取值，在Material-UI中，还支持自定义。Material-UI支持媒体查询，根据屏幕尺寸变化动态地变化元素样式。有时候，仅使用 CSS 是不够的，你或许还需要在屏幕尺寸发生变化时改变DOM内容。这个时候，可以使用 Material-UI 提供的 withWidth() 来实现。 四、工具 Modal 组件 用于创建对话框、lightbox 和 popover。 Popover 组件 用于给元素提供额外的展示/提示信息，类似于html元素的title属性。 Portal 组件 The portal component renders its children into a new \u0026ldquo;subtree\u0026rdquo; outside of current component hierarchy. Transitions 过渡效果 Transition提供了一系列的动画效果。如折叠效果、渐显渐现、Grow效果、Slide效果、Zoom效果等。 Click away listener 监听DOM页面上的所有事件，元素之内、元素之外。比如，在元素之外点击页面时，应该让弹框消失等。 五、Component Demos / Api 如何使用Material-UI组件？ 代码演示如下： 在使用 Material-UI 组件时，常需要参考组件的api文档 ，可查看相关属性的使用。 六、定制化 概览 由于组件会被用于各种不同的环境中，Material-UI支持不同类型的定制化需求，从最特殊的到最普通的场景。 定制一次性样式 在一些特别的场景下，你或许需要改变一个组件的样式。定制方案有：覆盖组件的类名，重写组件样式，使用内联样式等。 定制动态样式 在一些场景下，你需要使用动态的样式。可选的方案有：使用withStyles，类名切换，CSS变量，行内样式，主题嵌套等。 为某个组件定制样式 Material Design 样式 全局的主题样式 主题 主题特指组件的主体颜色、组件表面的墨色、阴影的级别和元素适合的透明度等。主题使得你的应用具有统一的色调。它允许你定制所有的设计方面，以满足你的商业或品牌需求。为了促进应用更高的统一性，Material-UI提供了 light 和 dark 两种主题类型。默认情况下，组件使用 light 主题类型。 什么时候使用 MuiThemeProvider 组件？ 如果你想定制主题样式，你需要使用 MuiThemeProvider 组件来包裹那些需要定制样式的组件，用以把主题注入到你的应用中。然而这是可选的，当不使用 MuiThemeProvider 组件时，Material-UI 会使用默认主题。 如何使用主题配置变量？ 改变主题配置变量，是匹配Material-UI定制样式最高效的方式。如下几个配置变量是非常重要的： Palette Type ( light / dark ) Typography Other varialbles Custom variables 查看 Material-UI 的默认主题样式 CSS in JS https://material-ui.com/zh/getting-started/installation/ nodemon（2.0.6） nodemon用来监视node.js应用程序中的任何更改并自动重启服务,非常适合用在开发环境中。nodemon将监视启动目录中的文件，如果有任何文件更改，nodemon将自动重新启动node应用程序。 nodemon不需要对代码或开发方式进行任何更改。 nodemon只是简单的包装你的node应用程序，并监控任何已经改变的文件。nodemon只是node的替换包，只是在运行脚本时将其替换命令行上的node。 在项目目录下创建 nodemon.json 文件 修改app.js文件 记得注释最后一行的：module.exports = app; 在package.json中添加脚本 pkg-dir(5.0.0) 返回Promise项目根路径或undefined找不到的根路径。 返回项目的根路径，或者undefined找不到它。 类型：string 默认值：process.cwd() 起始目录。 pkg-dir-cli- 此模块的CLI pkg- up-查找最近的package.json文件 查找 -通过上级父目录查找文件 qs(6.9.4) Node.js 标准库中有一个库叫querystring，这个库用来处理URL查询字符串： 但是很遗憾，querystring 不支持内嵌对象和数组： 如果我们程序的前端界面form表单中存在数组，标准库的querystring就无法满足我们的需求了。 qs 是querystring的增强版本，最重要的特性就是支持内嵌对象和数组： https://github.com/ljharb/qs redux-toolkit(1.5.0) 如果你的React项目中使用react hook、redux、redux-thunk，可能你需要用 redux-toolkit （以下简称RTK）优化你的项目结构，它看起来可以这么清爽 Redux 使用常见问题 配置复杂，devtool\u0026hellip; 模板代码太多，创建constant，action，reducer\u0026hellip; 需要添加很多依赖包，如redux-thunk、immer\u0026hellip; RTK干了哪些事？ configureStore() 包裹createStore，并集成了redux-thunk、Redux DevTools Extension，默认开启 createReducer() 创建一个reducer，action type 映射到 case reducer 函数中，不用写switch-case，并集成immer createAction() 创建一个action，传入动作类型字符串，返回动作函数 createSlice() 创建一个slice，包含 createReducer、createAction的所有功能 createAsyncThunk() 创建一个thunk，接受一个动作类型字符串和一个Promise的函数 新的项目 create-react-app 初始化项目，最受欢迎的脚手架之一 老的项目 安装 @reduxjs/toolkit configureStore 替换 createStore 创建action 以上看起比原来结构上好一些，创建action、reducer方便了，但是看着还是不爽，action也可以去掉 创建Slice counterSlice 看起起来像 只需要createSlice，包含着 action，reducer的创建 创建 selecter 完整 slice文件 "],["spring cloud集成spring security","2020年11月11日","/2020/springbootwithspringsecurity/","在spring boot/spring cloud成为java生态中绝对主流的开发框架时，spring家族其他的框架也开始变得越来越流行。对于认证授权的方案也有更多的小伙伴选择从shrio过渡到spring security。但是spring security的难度确实要比shiro高出不少，需要花费较多精力学习。 1.原理 img Spring Security 内置了一些过滤器，他们各有各的本事。如果你掌握了这些过滤器，很多实际开发中的需求和问题都很容易解决。今天我们来见识一下这些内置的过滤器。 2. 内置过滤器初始化 在 Spring Security 初始化核心过滤器时 会通过将 Spring Security 内置的一些过滤器以 提供的规则进行比较按照比较结果进行排序注册。 2.1 排序规则 维护了一个顺序的注册表 。 这些就是所有内置的过滤器。 他们是通过下面的方法获取自己的序号： 通过过滤器的类全限定名从注册表 中获取自己的序号，如果没有直接获取到序号通过递归获取父类在注册表中的序号作为自己的序号，序号越小优先级越高。上面的过滤器并非全部会被初始化。有的需要额外引入一些功能包，有的看 的配置情况。 在上一篇文章 中。我们禁用了 功能，就意味着 不会被注册。 3. 内置过滤器讲解 接下来我们就对这些内置过滤器进行一个系统的认识。我们将按照默认顺序进行讲解。 3.1 ChannelProcessingFilter 通常是用来过滤哪些请求必须用 协议， 哪些请求必须用 协议， 哪些请求随便用哪个协议都行。它主要有两个属性： 用来判断请求是否符合既定的协议规则。它维护了一个 列表 这些 是具体用来执行 策略 （任何通道都可以）, 策略 （只能通过 通道）, 策略 （只能通过 通道）。 用来存储 url 与 对应的 、 、 的映射关系。 通过 等相关方法引入其配置对象 来进行配置。 3.2 ConcurrentSessionFilter 主要用来判断 是否过期以及更新最新的访问时间。其流程为： 检测，如果不存在直接放行去执行下一个过滤器。存在则进行下一步。 根据 从 中获取 ，从 中获取 是否过期；没有过期则更新 中的访问日期； 如果过期，则执行 方法，这个方法会将 无效，并将 中的 中的权限置空，同时在 中清除 然后查看是否有跳转的 ，如果有就跳转，没有就输出提示信息。 通过 来进行配置。 3.3 WebAsyncManagerIntegrationFilter 用于集成SecurityContext到Spring异步执行机制中的WebAsyncManager。用来处理异步请求的安全上下文。具体逻辑为： 从请求属性上获取所绑定的 ，如果尚未绑定，先做绑定。 从 中获取 为 的安全上下文多线程处理器 , 如果获取到的为 ， 新建一个 并绑定 注册到 中。 这里简单说一下 。它实现了接口 ， 当它被应用于一次异步执行时， 方法会在调用者线程执行，该方法会相应地从当前线程获取 ,然后被调用者线程中执行逻辑时，会使用这个 ，从而实现安全上下文从调用者线程到被调用者线程的传输。 通过 方法添加到 中成为 的一个链节。 3.4 SecurityContextPersistenceFilter 主要控制 的在一次请求中的生命周期 。 请求来临时，创建 安全上下文信息，请求结束时清空 。 通过 及相关方法引入其配置对象 来进行配置。 3.5 HeaderWriterFilter 用来给 响应添加一些 ,比如 , ， 。 你可以通过 来定制请求 。 3.6 CorsFilter 跨域相关的过滤器。这是 配置和 命名空间 配置的替代方法， 仅对依赖于 的应用程序有用（不适用于 ）或 要求在 级别进行CORS检查的安全约束链接。这个是目前官方的一些解读，但是我还是不太清楚实际机制。 你可以通过 来定制。 3.7 CsrfFilter 用于防止 攻击，前后端使用json交互需要注意的一个问题。 你可以通过 来开启或者关闭它。在你使用 等 技术时，是不需要这个的。 3.8 LogoutFilter 很明显这是处理注销的过滤器。 你可以通过 来定制注销逻辑，非常有用。 3.9 OAuth2AuthorizationRequestRedirectFilter 和上面的有所不同，这个需要依赖 相关的模块。该过滤器是处理 请求首选重定向相关逻辑的。以后会我会带你们认识它，请多多关注公众号： 。 3.10 Saml2WebSsoAuthenticationRequestFilter 这个需要用到 模块，这是一个基于 的 单点登录请求认证过滤器。 关于SAML 即安全断言标记语言，英文全称是 。它是一个基于 的标准，用于在不同的安全域（ ）之间交换认证和授权数据。在 标准定义了身份提供者 ( ) 和服务提供者 ( )，这两者构成了前面所说的不同的安全域。 是 组织安全服务技术委员会(Security Services Technical Committee) 的产品。 （Security Assertion Markup Language）是一个 框架，也就是一组协议，可以用来传输安全声明。比如，两台远程机器之间要通讯，为了保证安全，我们可以采用加密等措施，也可以采用 来传输，传输的数据以 形式，符合 规范，这样我们就可以不要求两台机器采用什么样的系统，只要求能理解 规范即可，显然比传统的方式更好。 规范是一组 定义。 可以这么说，在 领域， 就是规范，在 领域， 就是规范 3.11 X509AuthenticationFilter 认证过滤器。你可以通过 来启用和配置相关功能。 3.12 AbstractPreAuthenticatedProcessingFilter 处理处理经过预先认证的身份验证请求的过滤器的基类，其中认证主体已经由外部系统进行了身份验证。 目的只是从传入请求中提取主体上的必要信息，而不是对它们进行身份验证。 你可以继承该类进行具体实现并通过 方法来添加个性化的 。 3.13 CasAuthenticationFilter 单点登录认证过滤器 。依赖 Spring Security CAS 模块 3.14 OAuth2LoginAuthenticationFilter 这个需要依赖 相关的模块。 登录认证过滤器。处理通过 进行认证登录的逻辑。 3.15 Saml2WebSsoAuthenticationFilter 这个需要用到 模块，这是一个基于 的 单点登录认证过滤器。 关于SAML 3.16 UsernamePasswordAuthenticationFilter 这个看过我相关文章的应该不陌生了。处理用户以及密码认证的核心过滤器。认证请求提交的 和 ，被封装成 进行一系列的认证，便是主要通过这个过滤器完成的，在表单认证的方法中，这是最最关键的过滤器。 你可以通过 及相关方法引入其配置对象 来进行配置。 我们在 Spring Security 实战干货： 玩转自定义登录 已经对其进行过个性化的配置和魔改。 3.17 ConcurrentSessionFilter 参见 3.2 ConcurrentSessionFilter 。 该过滤器可能会被多次执行。 3.18 OpenIDAuthenticationFilter 基于 认证协议的认证过滤器。 你需要在依赖中依赖额外的相关模块才能启用它。 3.19 DefaultLoginPageGeneratingFilter 生成默认的登录页。默认 。 3.20 DefaultLogoutPageGeneratingFilter 生成默认的退出页。 默认 。 3.21 ConcurrentSessionFilter 参见 3.2 ConcurrentSessionFilter 。 该过滤器可能会被多次执行。 3.23 DigestAuthenticationFilter 身份验证是 应用程序中流行的可选的身份验证机制 。 能够处理 头中显示的摘要式身份验证凭据。你可以通过 来启用和配置相关功能。 3.24 BasicAuthenticationFilter 和 身份验证一样都是 应用程序中流行的可选的身份验证机制 。 负责处理 头中显示的基本身份验证凭据。这个 Spring Security 的 Spring Boot 自动配置默认是启用的 。 通过 及相关方法引入其配置对象 来进行配置。 3.25 RequestCacheAwareFilter 用于用户认证成功后，重新恢复因为登录被打断的请求。当匿名访问一个需要授权的资源时。会跳转到认证处理逻辑，此时请求被缓存。在认证逻辑处理完毕后，从缓存中获取最开始的资源请求进行再次请求。 通过 及相关方法引入其配置对象 来进行配置。 3.26 SecurityContextHolderAwareRequestFilter 用来 实现 中 一些接口方法, 比如 方法、 方法，在使用 Spring Security 时其实就是通过这个过滤器来实现的。 通过 及相关方法引入其配置对象 来进行配置。 3.27 JaasApiIntegrationFilter 适用于 （ 认证授权服务）。 如果 中拥有的 是一个 ，那么该 将使用包含在 中的 继续执行 。 3.28 RememberMeAuthenticationFilter 处理 ** ** 功能的过滤器。 通过 及相关方法引入其配置对象 来进行配置。 3.29 AnonymousAuthenticationFilter 匿名认证过滤器。对于 来说，所有对资源的访问都是有 的。对于无需登录（ ）直接可以访问的资源，会授予其匿名用户身份。 通过 及相关方法引入其配置对象 来进行配置。 3.30 SessionManagementFilter 管理器过滤器，内部维护了一个 用于管理 。 通过 及相关方法引入其配置对象 来进行配置。 3.31 ExceptionTranslationFilter 主要来传输异常事件，还记得之前我们见过的 吗？ 3.32 FilterSecurityInterceptor 这个过滤器决定了访问特定路径应该具备的权限，访问的用户的角色，权限是什么？访问的路径需要什么样的角色和权限？这些判断和处理都是由该类进行的。如果你要实现动态权限控制就必须研究该类 。 3.33 SwitchUserFilter 是用来做账户切换的。默认的切换账号的 为 ，默认注销切换账号的 为 ，默认的账号参数为 。 你可以通过此类实现自定义的账户切换。 "],["使用flyway版本控制工具维护数据库表","2020年11月11日","/2020/flyway/","最近的公司项目需求需要在现有的项目中集成spring-security，鉴于对spring security的知识较为零散，虽然之前集中学习了一段时间的spring security，但没有实践还需要多学习。今天在查看spring security资料的时候接触到了flyway这个东西，感觉用起来还是挺方便，打算学习学习也一起集成到项目中。 我们为什么需要数据库迁移管理 比如第一个版本的产品只包含了最基本的功能，而第二版本就需要增加评论功能，这就涉及到数据结构的修改（包括创建新表，修改旧表的列，增加已有表的列等等）。直接进入产品数据库修改数据库并不适合快速的开发节奏，不仅仅不安全，更多的情况下数据库可能并不对外或者并不适合对外直接暴露连接，比如PAAS平台的数据库以服务的形式直接提供。 对比代码管理的一些实践，很明显在数据库方面做的还欠缺很多。比如代码管理中我们有 版本管理（svn，git等等） 持续集成技术 良好的发布工具和流程 而在数据库方面会遇到很多问题 某台数据库现在是什么状态 修改变更的脚本是否已经应用 对于生产环境的紧急修复有没有被应用在测试环境 如何创建一个新的数据库实例 数据库迁移工具可以很好的管理这些问题，并提供了以下特性 从迁移脚本中创建新的数据库 检查数据库状态 从一个版本快速到达另外一个版本 什么是 Flyway 我们在做开发时，由于项目需求的变化，或者前期设计缺陷，导致在后期需要修改数据库，这应该是一个比较常见的事情，如果项目还没上线，你可能把表删除了重新创建，但是如果项目已经上线了，就不能这样简单粗暴了，我们需要通过 SQL 脚本在已有数据表的基础上进行升级。 目前 Java 这块，想要对数据库的版本进行管理主要有两个工具： Flyway，Liquibase两个工具各有千秋，但是核心功能都是数据库的版本管理，这里主要来看 Flyway。就像我们使用 Git 来管理代码版本一样，Flyway 可以用来管理数据库版本。 Flyway 的特点 Flyway 大受欢迎是因为它具有以下优点： 简单 非常容易安装和学习，同时迁移的方式也很容易被开发者接受。 专一 Flyway 专注于搞数据库迁移、版本控制而并没有其它副作用。 强大 专为连续交付而设计。让Flyway在应用程序启动时迁移数据库。 Flyway 的工作机制 Flyway 需要在 中先创建一个 表 (缺省表名为 ), 在该表中保存着每次 （迁移）的记录, 记录包含 脚本的版本号和 SQL 脚本的 值。下图表示了多个数据库版本。 img 对应的 表记录： installed_rank version description type script checksum installed_by installed_on execution_time success 1 1 Initial Setup SQL V1__Initial_Setup.sql 1996767037 axel 2016-02-04 22:23:00.0 546 true 2 2 First Changes SQL V2__First_Changes.sql 1279644856 axel 2016-02-06 09:18:00.0 127 true Flyway 的规则 Flyway 是如何比较两个 SQL 文件的先后顺序呢？它采用 采用左对齐原则, 缺位用 0 代替 。举几个例子： 1.0.1.1 比 1.0.1 版本高。 1.0.10 比 1.0.9.4 版本高。 1.0.10 和 1.0.010 版本号一样高, 每个版本号部分的前导 0 会被忽略。 Flyway 将 SQL 文件分为 Versioned 、Repeatable 和 Undo 三种： Versioned 用于版本升级, 每个版本有唯一的版本号并只能执行一次. Repeatable 可重复执行, 当 Flyway检测到 Repeatable 类型的 SQL 脚本的 有变动, Flyway 就会重新应用该脚本. 它并不用于版本更新, 这类的 总是在 Versioned 执行之后才被执行。 Undo 用于撤销具有相同版本的版本化迁移带来的影响。但是该回滚过于粗暴，过于机械化，一般不推荐使用。一般建议使用 Versioned 模式来解决。 这三种的命名规则如下图： naming.png Prefix 可配置，前缀标识，默认值 表示 Versioned, 表示 Repeatable, 表示 Undo Version 标识版本号, 由一个或多个数字构成, 数字之间的分隔符可用点 或下划线 Separator 可配置, 用于分隔版本标识与描述信息, 默认为两个下划线 Description 描述信息, 文字之间可以用下划线 或空格 ``分隔 Suffix 可配置, 后续标识, 默认为 集成到项目中 如果是在一个全新的项目中使用 Flyway，那么在新建一个 Spring Boot 项目时，就有 Flyway 的选项，如下图： img 项目创建成功后，resources目录下也会多出来一个db/migration目录，这个目录用来存放数据库脚本，如下： img 注意 img 这个如果创建项目时就选择了 Flyway 依赖，就会有这个目录。现在我要在已经做好的项目中加入 Flyway，这个目录就需要我手动创建了。 首先在pom中添加 flyway 依赖： gradle 然后在项目的 resources 目录下，手动创建 db/migration 目录 然后在该目录下创建数据库脚本，数据库脚本的命名方式如下： V__.sql首先是大写字母 V，然后是版本号，要是有小版本可以用下划线隔开，例如 2_1，版本号后面是两个下划线，然后是脚本名称，文件后缀是 .sql。 例如我这里创建我的第一个数据库脚本，取名为 V1.20.1__gp.sql。 可以不用添加额外配置，大家只需要在本地 MySQL 中创建一个空的 gp数据库即可，然后直接启动项目，项目启动成功后，我们查看启动日志： img 从这段启动日志中，我们可以看到 Flyway 的执行信息，数据库脚本的执行执行，同时这里还说了，Flyway 还给创建了一个 flyway_schema_history 表，这个表用来记录数据库的更新历史。 这个时候，打开本地数据库，我们发现 gp库中该有的表都有了。同时还发现了 flyway_schema_history 表，如下： img 有了这条记录，下次再启动项目，这个sql脚本文件就不会执行了，因为系统知道这个脚本已经执行过了，如果你还想让脚本再执行一遍，需要手动删除 flyway_schema_history 表中的对应记录，那么项目启动时，这个脚本就会被执行了。 3.执行细节 我们在定义脚本的时候，除了 V 字开头的脚本之外，还有一种 R 字开头的脚本，V 字开头的脚本只会执行一次，而 R 字开头的脚本，只要脚本内容发生了变化，启动时候就会执行。使用了 Flyway 之后，如果再想进行数据库版本升级，就不用改以前的数据库脚本了，直接创建新的数据库脚本，项目在启动时检测了有新的更高版本的脚本，就会自动执行，这样，在和其他同事配合工作时，也会方便很多。因为正常我们都是从 Git 上拉代码下来，不拉数据库脚本，这样要是有人更新了数据库，其他同事不一定能够收到最新的通知，使用了 Flyway 就可以有效避免这个问题了。所有的脚本，一旦执行了，就会在 flyway_schema_history 表中有记录，如果你不小心搞错了，可以手动从 flyway_schema_history 表中删除记录，然后修改 SQL 脚本后再重新启动（生产环境不建议）。 4.其他配置 在 Spring Boot 中，关于 Flyway 也有不少配置，这些配置都在 application.properties 中进行配置，常用的几个来和大家说下： spring.flyway.enabled：是否开启 flyway，默认就是开启的 spring.flyway.encoding：flyway 字符编码 spring.flyway.locations：sql 脚本的目录，默认是 classpath:db/migration，如果有多个，用 , 隔开 spring.flyway.clean-disabled：这个属性非常关键，它表示是否要清除已有库下的表，如果执行的脚本是 V1__xxx.sql，那么会先清除已有库下的表，然后再执行脚本，这在开发环境下还挺方便，但是在生产环境下就要命了，而且它默认就是要清除，生产环境一定要自己配置设置为 true。 spring.flyway.table：配置数据库信息表的名称，默认是 flyway_schema_history。 Flyway 最佳实践 通过上面的介绍相信你很快就会使用 Flyway 进行数据库版本控制了。这里总结了一些在实际开发中的使用经验： 生产务必禁 。 尽量避免使用 Undo 模式。 开发版本号尽量根据团队来进行多层次的命名避免混乱。比如 ，这种命名同时也可以获取更多脚本的开发者和相关功能的信息。 取值 生产上使用 ，开发中使用 。 多个系统公用一个 数据库 时配置 为不同的系统设置不同的 表名而不使用缺省值 。 附录: Flyway配置详解 参考 [Flyway 简单入门教程 ](https://www.cnblogs.com/moonlightL/p/10576844.html ) Spring Boot 2 实战：使用 Flyway 管理你数据库的版本变更 Spring Boot 使用 Flyway "],["使用IDEA保存时自动格式化代码配置","2020年11月11日","/2020/autoformatonsave/","公司的Java项目在提交代码时会自动执行CI。为了统一代码风格，CI中配置了使用google-java-format来检查代码格式，所以IDEA默认的格式化风格会和google的风格不一样，最终提交代码时需要执行 来再次format,经常会遇到在提交代码时会忘记执行脚本会导致CI构建失败。所以研究了一下如何让IDEA应用google的风格自动进行格式化。 安装google-java-format preferences -\u0026gt; plugins -\u0026gt; Browse repositories… 搜索google-java-format安装插件 启用google-java-format（AOSP） 安装save actions preferences -\u0026gt; plugins -\u0026gt; Browse repositories… 安装save actions 启用save actions 保存时自动格式化 image-20201126110813221 其他配置 关于formatting、build action和quick fix的部分根据需要开启 "],["node项目监控工具之pm2","2020年11月11日","/2020/pm2useapi/","用了好几年的宝塔，不知道什么时候出了个pm2管理器，才开始以为它是对node版本切换管理的，直到今天看到有一篇文章才发现理解错了。研究了一下pm2的作用和用法，也顺便玩一玩宝塔中的pm2。 pm2官方文档：http://pm2.keymetrics.io/docs/usage/quick-start/ 简单教程 首先需要安装pm2： 运行： 开机自动运行： 开机自启: 初次安装并运行，会有一个高大上的界面： img 那么pm2与forever 相比，比较有哪些高大上的功能呢？我们看一下对比表格： Feature Forever PM2 Keep Alive ✔ ✔ Coffeescript ✔ Log aggregation ✔ API ✔ Terminal monitoring ✔ Clustering ✔ JSON configuration ✔ 我们可以很直观的看出，pm2相比较Forever，功能更加强大一些。 查看运行状态 我们可以通过简单的命令查看应用的运行状态： 效果如下： img ANodeBlog应用正在运行，pid为31480，并且占用内存为89.113 MB。 追踪资源运行情况 会看到应用资源的实时运行情况 img 查看应用详细部署状态 如果我们想要查看一个应用详细的运行状态，比如 的状态，可以运行： \u0026ldquo;3\u0026quot;是指App Id。 结果如下： img 查看日志 系统会打印出详细的logs。 重启应用 停止应用 想要终止应用，只需要运行： 强健的API 在项目中运行： 然后浏览器访问http://localhost:9615 你会有惊喜！ 预定义运行配置文件 我们可以预定义一个配置文件，然后制定运行这个配置文件，比如我们定义一个文件 ，内容如下： 然后可以通过 运行这个App。 总结 常用命令总结如下： 安装pm2 启动应用 列出所有应用 查看资源消耗 查看某一个应用状态 查看所有日志 重启应用 停止应用 开启api访问 更多pm2内容请参考官方文档：http://pm2.keymetrics.io/docs/usage/quick-start 宝塔中的pm2管理器使用方法 1、安装版本 windows默认支持3个版本（8.x/9.x/10.x），选择任意一个版本安装即可 安装时间可能会比较久，请耐心等待.. img img 2、添加项目 如果添加项目后无法启动，可能是当前环境变量未生效，需要重启面板或者服务器后，重新添加项目 img img 3、给项目绑定一个域名 如图点击映射，出现绑定域名窗口，绑定完成之后，可在网站管理查看到对应的网站 img 4、访问网站 浏览器输入刚刚绑定的域名如图：http://node.ffce.cn 至此第一个node.js搭建成功 img 5、添加模块 如果项目需要安装其他模块，则通过模块管理安装，如图我需要安装express img img 6、查看日志 img 测试js img app.js (423 Bytes, 下载次数: 1191) 在mac上安装bt 安装Docker 在Docker里安装CentOS Docker Hub：https://hub.docker.com/_/centos 映射宝塔端口 创建一个CentOS容器并映射 端口，复制返回的 img 进入CentOS安装宝塔 进入容器终端 __在CentOS中__执行宝塔安装命令 在宝塔论坛 中打开安装教程，找到最新的版本安装命令，像以下这样的命令。 安装完成后，提示给的外网IP是用不了的，所以这里需要用 访问面板 img docker相关命令 Docker 命令大全 列出正在运行的容器信息 列出所有容器信息 停止所有容器 或者通过docker-compose安装 3. 进入项目根目录 4. 生成配置文件 5. 启动宝塔镜像，在项目根目录下执行命令 6. 查看默认登录信息 如果自己修改过env中的端口配置，那么访问的时候就需要写自己修改的端口 image-20201106174751622 比如我这里填的是18888，那我的访问地址就是 http://localhost:18888/63c795f5 ，后面的随机码可以用 查看 "],["nuxt.js使用介绍","2020年11月11日","/2020/vuessrnuxt/","vue全家桶还算是比较全面的，从构建工具vue-cli、vite，到vue-router、vuex、element-ui，vue-dev-tools，最后服务器渲染方案nuxt.js等等构成了一个完整的开发生态，用着还是比较省心的。总结一下nux.js用法以供参考。 什么是SSR 服务端渲染（Server Side Render），即：网页是通过服务端渲染生成后输出给客户端。 在 SPA(Single Page Application，即单页面应用) 之前的时代，我们的Web架构大都是 SSR，如：Wordpress（PHP）、JSP技术、JavaWeb\u0026hellip;或者 DEDE CMS、Discuz! 等这些程序都是传统典型的 SSR 架构， 即：服务端取出数据和模板组合生成 html 输出给前端，前端发生请求时，重新向服务端请求 html 资源，路由也由服务端来控制。 其次，有个概念叫预渲染（Prerendering）。 如果你只是用服务端渲染来改善一个少数的营销页面（如 首页，关于，联系 等等）的 SEO，那你可以用预渲染来实现。 预渲染不像服务器渲染那样即时编译 HTML，它只在构建时为了特定的路由生成特定的几个静态页面，等于我们可以通过 Webpack 插件将一些特定页面组件 build 时就编译为 html 文件，直接以静态资源的形式输出给搜索引擎。 但实际的商业应用中，大部分时候我们需要的是即时渲染，这也是我们今天讨论的主题。 为什么需要SSR 为了兼容性 虽然现在大部分的浏览器对单页面应用支持优化，但还有一少部分浏览器比较古老。对于世界上的一些地区人，可能只能用1998年产的电脑访问互联网的方式使用计算机。 而 Vue 只能运行在 IE9 以上的浏览器，你可能也想为那些老式浏览器提供基础内容 - 或者是在命令行中使用 Lynx 的时髦的黑客。 为了SEO SEO是流量是变现的快车道，SEO 是低成本获取流量的最佳方法。 目前大部分的搜索引擎仅能抓取URI直接输出的数据资源，对于 Ajax 类的异步请求的数据无法抓取；Google 除外，Google 有自己的[Google’s Webmaster AJAX Crawling Guidelines.](https://developers.google.com/webmasters/ajax-crawling/)技术支持。在大部分的商业应用中，我们有 SEO 的需求，我们需要搜索引擎更多地抓取到我们的内容，更详细地认识到我们的网页结构，而不是仅对首页或特定静态页进行索引，这是 SSR 最重要的意义。 简单说就是，我们需要搜素引擎看到这样的代码： ![image-20201106154440746](https://image.xiaomo.info//blog/image-20201106154440746.png) 而不是这样的代码： ![image-20201106154506477](https://image.xiaomo.info//blog/image-20201106154506477.png) 3. 为了数据安全 现在基本上B/S架构的应用都是前后端分离方式开发的，即前端使用XHR异步获取数据并渲染到页面上，如果我们不使用SSR的话，用户可以直接在调试控制台拿到我们的接口数据。但如果是我们使用的是SSR渲染的话，浏览器收到的就是一个填充好数据的HTML，如果别有用心的人想拿我们的数据。要么人肉复制，要么使用jsonp等技术定位我们的元素。当我们发现有spider在偷我们的数据的时候，稍微换下html的dom结构，偷数据的人就得吭赤吭赤的更新他们的爬虫代码。 此外，我们还需要在 SSR 的基础上实现 SPA，即：**首屏渲染**。 基本流程是： 在浏览器第一次访问某个 URI 资源的时候（首屏），Web 服务器根据路由拿到对应数据渲染并输出，且输出的数据中包含两部分： 路由页对应的页面及已渲染好的数据 完整的SPA程序代码 在客户端首屏渲染完成之后，此时我们看到的其实已经是一个和之前的 SPA 相差无几的应用程序了，接下来我们进行的任何操作都只是客户端的应用进行交互， 页面/组件由Web端渲染，路由也由浏览器控制，用户只需要和当前浏览器内的应用打交道就可以了。 之前在各大 SPA 框架还未正式官方支持 SSR 时，有一些第三方的解决方案，如：prerender.io ， 它们做的事情就是建立HTTP一个中间层，在判断到访问来源是蜘蛛时，输出已缓存好的html数据，此数据若不存在，则调用第三方服务对 html 进行缓存，往复进行。 另一方法是自行构建蜘蛛渲染逻辑，当识别 UA 为搜索引擎时，拿服务端已准备好的模板和数据进行渲染输出 html 数据，反之，则输出 SPA 应用代码； 我当时也考虑过此方法，但有很多弊端，如： 需要针对蜘蛛编写一套独立的渲染模板，因为大部分情况下 SPA 的代码是没法直接在服务端使用的 搜索引擎若检测到蜘蛛抓取数据和真实访问数据不一致，会做降权惩罚，也就意味着渲染模板还必须和SPA预期输出一模一样 所以，最好的方法是 SPA 能和服务端使用同一套模板，且使用同一个服务端逻辑分支，再简单说：最好 Vue、Ng2\u0026hellip; 能直接在服务端跑起来。 于是，陆续诞生了基于 React 的Next.js 、基于 Vue 的Nuxt.js 、Ng2 诞生之日便支持。 VUE的SSR方案(nuxt) Nuxt.js是使用 Webpack 和 Node.js 进行封装的基于Vue的SSR框架，使用它，你可以不需要自己搭建一套 SSR 程序，而是通过其约定好的文件结构和API就可以实现一个首屏渲染的 Web 应用。之所以叫 Nuxt.js 也是因为受到了 Next.js 的启发。作者是法国的兄弟俩，EvenYou 在微博多次提到，也在欧洲见过哥俩。 在此之前，国内有一些对 Vue SSR 的整合尝试，但都没有成功，主要在于 Webpack 和 Node 的结合上没有实践出最佳方案， 当我看到 Nuxt.js 以约束文件夹和配置文件 的方式来管理多个程序组件之间的关系时，就觉得，很酷！ Nuxt.js 是一个 Node 程序，就像上面说的，我们是要把 Vue 跑在服务端，所以必须使用 Node 环境。我们对 Nuxt.js 应用的访问，实际上是在访问这个 Node.js 程序的路由，程序输出首屏渲染内容 + 用以重新渲染的 SPA 的脚本代码，而路由是由 Nuxt.js 约定好的 pages 文件夹生成的。 所以，整体上，Nuxt.js 通过各个文件夹和配置文件的约束来管理我们的程序，而又不失扩展性，其有自己的插件机制 。 Nuxt项目的创建 npx yarn npm 启动 yarn npm nuxt项目结构介绍 按照目前的版本，Nuxt.js 的程序的文件结构大概分为以下部分： pages：各页面组件，用于生成对应路由，支持嵌套，支持动态路由 components：各组件，用于你自己管理公共组件或非公共组件 layouts：宿主布局页面模板组件，用于你可以把不同的页面指定使用不同的布局 assets：用于 Webpack 编译的各类资源，通常是一些小的资源，如代替雪碧图之类的图片等东西 middleware：中间件，首屏渲染和路由跳转前均执行对应中间件，可以返回promise或直接next（像是一个网关，很实用！） plugins：插件，SPA中用的各类第三方组件和一些node模块都可以在这引入，甚至可以引入自己编写的第三方库 store：内置了vuex，可以直接返回数据模块或返回一个自建vuex根对象，具体要翻文档 其他：你可以自定义文件夹和别名映射，文档都有提及，这里有配置代码 nuxt.js 配置文件介绍 对程序的扩展管理可大概分为以下类： build：主要对应 Webpack 中的各配置项，可以对默认的 Webpack 配置进行扩展，如这里代码 cache：主要对应内置的组件缓存模块 的配置对象，有默认值，可选关闭 css：对应我们在SPA随处引用样式文件的 语句 dev：用于自定义配置环境变量，对应之前 相关文件中的变量语句 env：同上息息相关 generate：对 命令执行时的行为做一些定制 head：对应 插件的全局配置， 用于VUE/SSR程序的文档元信息的管理 loading：用于定制化Nuxt.js内置的进度条组件 performance：用于配置Node.js服务器性能上的配置 plugins：用于管理和应用对应 文件夹中的插件 rootdir：用于设置 Nuxt.js 应用的根目录（这俩api有很大合并的意义） srcdir：用于设置 Nuxt.js 应用的源码目录（这俩api有很大合并的意义） router：用于对 的扩展和定制，其中还包括了中间件的配置，但并不完美（后面说） transition：用于定制Nuxt.js内置的页面切换过渡效果的默认属性值 watchers：用于定制Nuxt.js内置的文件监听模块 和 Webpack 的相关配置项 路由 nuxt的没有固定配置路由的文件，它是根据约定自动生成的路由，所有的页面都在pages目录下。 首页 （url:port） 对应 pages/index.vue 订单列表( url:port/order) 对应 pages/order/index.vue 使用时 动态路由 在 Nuxt.js 里面定义带参数的动态路由，需要创建对应的以下划线作为前缀的 Vue 文件 或 目录。 在 Nuxt.js 里面定义带参数的动态路由，需要创建对应的以下划线作为前缀的 Vue 文件 或 目录。 以下目录结构： Nuxt.js 生成对应的路由配置表为： 你会发现名称为 的路由路径带有 参数，表示该路由是可选的。如果你想将它设置为必选的路由，需要在 目录内创建一个 文件。 举例： 嵌套路由 创建内嵌子路由，你需要添加一个 Vue 文件，同时添加一个与该文件同名的目录用来存放子视图组件。别忘了在父组件( 文件) 内增加 用于显示子视图内容。 父路由 2个子路由 404 页面 意思是无限次嵌套，因此在pages下创建如下文件 中间件 使用中间件做权限认证 使用插件 ts扩展 修改端口号 异步加载数据的hook(nuxt自动调用) 需要添加nuxt的http模块 ` image-20201124160222403 "],["web端接入apple Sign in流程","2020年11月11日","/2020/webapplesignin/","前一段时间接入了google sign in的功能，现在继续接入apple sign in。待apple sign in 正式上线之后，我们的游戏支持 line、Facebook、twitter、google、apple5种三方登陆，基本上涵盖了主流sns。apple和google虽然是不同的平台，但是都是采用上oauth2.0的协议，所以接入流程大同小异。 知识储备 jwt相关知识（apple采用的是jwt的验证方式） js/ts/java基础编程技能 前提准备 登陆apple开发者中心 在identifidr注册一个App ID image-20201111175510479 image-20201111175553237 image-20201111175741824 注册之后可以得到3个内容 ：对app的描述 : 注册时第2步填的反向域名（也就是client_id） : 也就是teamId，apple自动生成的随机唯一标识(init的时候不需要) 注册在identifier中注册service ID, 有几个环境就可以注册几个service ID,绑定同一个App Id就可以了。 image-20201111180250556 注册好之后打开apple sign in 并配置 image-20201111180330148 image-20201111180600392 image-20201111180815110 代码演示 下载声明 初始化 loadScript 用于动态加载js 触发登陆 监听按钮点击事件 监听成功/失败（可选） 实例 服务端代码(主要验证idToken的合法性和自己的用户系统关联起来) build.gradle application.yml 配置的实体类 配置文件和实体类关联 验证jwt 参考 Sign with in Apple，网站配置 Apple 登录 Sign in with Apple NODE，web端接入苹果第三方登录 java-如何在Nimbus JOSE JWT中验证令牌签名 后记 文章中贴的实例代码只是提供一个开发思路，实际业务开发中牵扯的内容比较多。像是一些零散的util方法、css样式、业务耦合较重的内容等等没有一一提及，所以直接拷贝代码的话肯定会有不少的依赖文件找不到。 "],["vue框架状态管理之vuex","2020年10月10日","/2020/vueframeworkvuex/","作为一个全沾攻城狮，需要会的东西实在太多了。虽然思路都大同小异，但是对于不同的框架，架构和使用的api都有着不小的区别，还是需要花费点时间学习一下，今天要记录的是便是管理vue状态的框架vuex。 vuex是什么 vuex 是一个状态管理框架，也可以叫做数据共享框架。它能够创建一个独立于组件之外的一个共享数据仓储，将需要的数据放在store当中，当需要用到数据的组件通过this.$store.state.xxx获取 。 不使用vuex的现状 父向子传值: v-bind，子组件通过props接收。 子向父传值: $emit()发射自定义事件, 父组件用v-on监听事件。 不相干组件传值，eventbus实现。 接收方用$on,传递方用$emit() 此种方式只能在小型项目中使用，当需要大量组件需要传值时，会通过其他不相干的组件层层传递，导致组件之间耦合严重,维护相当吃力。 使用vuex有什么好处 vuex创建的state是独立于组件的，能够解藕组件。 集中管理数据，易于维护。 共享数据,存储和获取都非常便捷。 state中的数据都是响应式的，引用state的组件能够实时同步UI 存储原则：一般来说将需要共享的数据放在state中，私有的数据放在组件的data中。但是也可以将所有数据都放在state中，这要看个人和项目组的的开发习惯。 vuex组成部分 解构注意事项： state和getter本质上是属性，所以解构的时候是放在computed中，actions和mutactions是方法，所以解构是要放在methods中。 state（公共数据源，需要共享的数据都放在这里面） 使用的时候: this.$store.state.count (this可以省略) 或者使用mapState解构为computed属性,使用哪种方法都可以 mutations(同步的修改state，mutations中不能使用异步操作) 用setTimeoutt等异步操作会出错 ,异步操作需要放在action中 好处：在统一的地方对应，方便管理和维护 使用时 第一种 如果想传递参数 第二种mapMutations (注意要放在 中) actions(异步的修改state，它不能直接操作state，需要调用mucations中的方法来操作) 使用时:方式一 写一个方法，通过$store.dispatch这个action,想要传参数和mucation中写法一样 第二种使用方法,解构出来直接使用(注意要放在 中) getters(用于对store中的数据进行加工形成新的数据，但不会影响store中的数据) store的数据变化之后，getter中的数据也会变化 使用时 第二种使用方法(注意要放在 中) 使用时 modules(对store进行模块划分) 使用场景：当项目组中有多个人同时开发时，如果放在一个文件里面则会出现修改冲突，这里需要使用modules进行文件切分再组合。 目录结构： 使用的时候，解构的时候写法有区别。commit的时候需要加上模块名 使用注解方式 只有使用ts的环境才能使用注解方式,通过调研有以下两种方案。至于怎么选择，看实际项目的情况下，有的时候不一定有发言权，leader定哪个就用哪个吧。 vuex-module-decorators ： vue-typescript-admin-template 使用的解决方案 vuex-class ：非官方维护，在 vue-class-component 基础上补充一定 支持（支持有限） vuex-module-decorators 用法 vuex-class用法 参考文章： Vue \u0026amp; TypeScript 初体验 - 使用Vuex (vuex-module-decorators) "],["疫情下的回日坎坷路","2020年08月08日","/2020/backtojapan/","背景介绍：熟悉小莫的应该知道，小莫在日本依旧从事着掉头发的工作。在去年过年前打算重温一下家乡，毅然决然请了半个月假（当时已经知道疫情，但是没想到的是这次影响居然大到我等凡人不可想象之境）。盼望着，盼望着，脱掉冬装换成春装，却依旧像一只只老鼠在这个魔幻的鼠年蹲在各自的小房子里。盼望着盼望着，历经重重艰难，回到了杭州，然而入馆限制却越来越厉害，一直持续到了8月。终于！！！！！可以迈上回日的坎坷之路了。 众所周知，日本入馆局从7.29日宣布：4.3号之前出境的长期签证可以回去了。但是！他是有条件滴\u0026hellip;. 护照在留卡不可或缺 需要再入国确认书 日本规定格式的核酸检测证明 以上 再入国确认书 去当地的入馆局申请，带上护照和签证 200大洋，8个工作日左右，可以邮寄（浙江地区，其他地区不详） 核酸检测证明（72小时以内） 重要！！！！！ 必须开日本大使馆提供的证明格式，有很多人到了日本因为证明格式不行导致相当大麻烦，具体参考 徐静波的文章 中国的核酸检测证明到了日本机场为啥不管用？ 乘机经验分享 众所周知：目前国际航班价格升天，非富即贵者望票兴叹而不可得。但是！国内的机票是便宜的，并且！大连飞东京的票也是相对万元票也是便宜的。因此！从你在的地方飞大连周水子国际机场，出来找小黑店马杀鸡一晚，第二天神清气爽飞东京，NICE！ 乘机过程 特别提醒！ 因为特殊时期检查繁琐，内容众多，效率低下，下，下不为例。反正就是提醒你早点去机场排队队队队队队队！！！ 上灰机 排队出示绿码 排队出示国务院行程卡 排队填写健康申报单 排队安检 排队办登机 排队测体温 排队再安检 排队登机 排队……算了上灰机了坐一会儿不排了 下灰机 经历了天上3个小时的短暂休息，艰难的过程还在后面。如果国内的总结起来是排队排到怀疑人生，那么日本这边就是小板凳坐到欲哭无泪 下鸡后经过长长的望眼欲不穿的走廊，坐上那整齐而又优雅的小板凳，一波一波的等待检阅（拿上证件过检时出示调查表，确认信息后等待核酸检测，这个表之后很长一段时间都用它） 到新的地方坐上那心爱的小板凳，等待检察官给你发一个小管管，到属于自己的小格子疯狂喷水。啊不好意思，是吐吐沫。吐半管管之后拿去确认没问题就可以继续下一步 拿上绿色的回执小卡片，在新的检察官的引导下来到新的小板凳聚集地，坐上那茫茫众多属于你的你的小板凳开始漫长的等待，这篇攻略便是在小板凳上用我的爪机写出来的 听到叫号之后拿上小卡去取结果，会在一个结果受付房间拿结果，阴性可以得一张红色小卡片，拿到直接就可以去办入境审查了。 办入境审查的时候把阴性成就卡片，护照，在留卡，再入国确认书，国内开的阴性证明交到审查管，然后在一个小房间等待，大概15分钟可以即可出关拿行李。 最后 之前听说出来之后会有审查官陪你到一直送上车并记录车牌号之后才会离开，我实际遇到的情况是审查管会问有没有人来接你，并不会跟着你。从你拿行李开始就和以前入境没有任何区别，但是有规定不能坐公共交通，万一查到，后果自负。 转载请注明原文地址 https://blog.xiaomo.info/2020/backToJapan/ "],["unity常见面试题","2020年01月01日","/2020/unityinterviewquestions/","算起来到现在为止面试的大多是游戏服务端或者web前端相关的类容，没有经历过一次正儿八经的Unity面试，通过面试题也可以侧面了解到Unity开发中有哪些常用的需要掌握的知识，因此搬运一篇号称“屎上最全”的博客当作备份。 一．什么是渲染管道？ 是指在显示器上为了显示出图像而经过的一系列必要操作。 渲染管道中的很多步骤，都要将几何物体从一个坐标系中变换到另一个坐标系中去。 主要步骤有： 本地坐标-\u0026gt;视图坐标-\u0026gt;背面裁剪-\u0026gt;光照-\u0026gt;裁剪-\u0026gt;投影-\u0026gt;视图变换-\u0026gt;光栅化。 二．如何优化内存？ 有很多种方式，例如 1.压缩自带类库； 2.将暂时不用的以后还需要使用的物体隐藏起来而不是直接Destroy掉； 3.释放AssetBundle占用的资源； 4.降低模型的片面数，降低模型的骨骼数量，降低贴图的大小； 5.使用光照贴图，使用多层次细节(LOD)，使用着色器(Shader)，使用预设(Prefab)。 三、动态加载资源的方式？(有时候也问区别，具体请百度) 1.Resources.Load(); 2.AssetBundle 四：什么是协同程序？ 在主线程运行的同时开启另一段逻辑处理，来协助当前程序的执行，协程很像多线程，但是不是多线程，Unity的协程实在每帧结束之后去检测yield的条件是否满足。 五：Unity3d中的碰撞器和触发器的区别？ 碰撞器是触发器的载体，而触发器只是碰撞器身上的一个属性。当Is Trigger=false时，碰撞器根据物理引擎引发碰撞，产生碰撞的效果，可以调用OnCollisionEnter/Stay/Exit函数；当Is Trigger=true时，碰撞器被物理引擎所忽略，没有碰撞效果，可以调用OnTriggerEnter/Stay/Exit函数。如果既要检测到物体的接触又不想让碰撞检测影响物体移动或要检测一个物件是否经过空间中的某个区域这时就可以用到触发器 六：物体发生碰撞的必要条件？ 两个物体都必须带有碰撞器（Collider），其中一个物体还必须带有Rigidbody刚体，而且必须是运动的物体带有Rigidbody脚本才能检测到碰撞。 七：请简述ArrayList和List的主要区别？ ArrayList存在不安全类型（ArrayList会把所有插入其中的数据都当做Object来处理）\u2028装箱拆箱的操作（费时）\u2028List是接口，ArrayList是一个实现了该接口的类，可以被实例化 八：如何安全的在不同工程间安全地迁移asset数据？三种方法 1.将Assets目录和Library目录一起迁移 2.导出包，export Package 3.用unity自带的assets Server功能 九：OnEnable、Awake、Start运行时的发生顺序？哪些可能在同一个对象周期中反复的发生 Awake –\u0026gt;OnEnable-\u0026gt;Start，OnEnable在同一周期中可以反复地发生。 十：MeshRender中material和sharedmaterial的区别？ 修改sharedMaterial将改变所有物体使用这个材质的外观，并且也改变储存在工程里的材质设置。不推荐修改由sharedMaterial返回的材质。如果你想修改渲染器的材质，使用material替代。 十一：Unity提供了几种光源，分别是什么 四种。 平行光：Directional Light 点光源：Point Light 聚光灯：Spot Light 区域光源：Area Light 十二：简述一下对象池，你觉得在FPS里哪些东西适合使用对象池 对象池就存放需要被反复调用资源的一个空间，当一个对象回大量生成的时候如果每次都销毁创建会很费时间，通过对象池把暂时不用的对象放到一个池中（也就是一个集合），当下次要重新生成这个对象的时候先去池中查找一下是否有可用的对象，如果有的话就直接拿出来使用，不需要再创建，如果池中没有可用的对象，才需要重新创建，利用空间换时间来达到游戏的高速运行效果，在FPS游戏中要常被大量复制的对象包括子弹，敌人，粒子等 十三：CharacterController和Rigidbody的区别 Rigidbody具有完全真实物理的特性，Unity中物理系统最基本的一个组件，包含了常用的物理特性，而CharacterController可以说是受限的的Rigidbody，具有一定的物理效果但不是完全真实的，是Unity为了使开发者能方便的开发第一人称视角的游戏而封装的一个组件 十四：简述prefab的用处 在游戏运行时实例化，prefab相当于一个模板，对你已经有的素材、脚本、参数做一个默认的配置，以便于以后的修改，同时prefab打包的内容简化了导出的操作，便于团队的交流。 十五：请简述sealed关键字用在类声明时与函数声明时的作用 sealed修饰的类为密封类，类声明时可防止其他类继承此类，在方法中声明则可防止派生类重写此方法。 十六：请简述private，public，protected，internal的区别 public：对任何类和成员都公开，无限制访问 private：仅对该类公开 protected：对该类和其派生类公开 internal：只能在包含该类的程序集中访问该类 十七：使用Unity3d实现2d游戏，有几种方式？ 1.使用本身的GUI，在Unity4.6以后出现的UGUI 2.把摄像机的Projection(投影)值调为Orthographic(正交投影)，不考虑z轴； 3.使用2d插件，如：2DToolKit，和NGUI 十八：在物体发生碰撞的整个过程中，有几个阶段，分别列出对应的函数 三个阶段，1.OnCollisionEnter 2.OnCollisionStay 3.OnCollisionExit 十九：Unity3d的物理引擎中，有几种施加力的方式，分别描述出来 rigidbody.AddForce/AddForceAtPosition，都在rigidbody系列函数中。大家可以自己去查看一下rigidbody的API 二十：什么叫做链条关节？ Hinge Joint，可以模拟两个物体间用一根链条连接在一起的情况，能保持两个物体在一个固定距离内部相互移动而不产生作用力，但是达到固定距离后就会产生拉力。 二十一：物体自身旋转使用的函数？ Transform.Rotate() 二十二：Unity3d提供了一个用于保存和读取数据的类(PlayerPrefs)，请列出保存和读取整形数据的函数 PlayerPrefs.SetInt() PlayerPrefs.GetInt() 二十三：Unity3d脚本从唤醒到销毁有着一套比较完整的生命周期，请列出系统自带的几个重要的方法。 Awake——\u0026gt;OnEnable–\u0026gt;Start——\u0026gt;Update——\u0026gt;FixedUpdate——\u0026gt;LateUpdate——\u0026gt;OnGUI——\u0026gt;OnDisable——\u0026gt;OnDestroy 二十四：物理更新一般放在哪个系统函数里？ FixedUpdate，每固定帧绘制时执行一次，和Update不同的是FixedUpdate是渲染帧执行，如果你的渲染效率低下的时候FixedUpdate调用次数就会跟着下降。FixedUpdate比较适用于物理引擎的计算，因为是跟每帧渲染有关。Update就比较适合做控制。 二十五：在场景中放置多个Camera并同时处于活动状态会发生什么？ 游戏界面可以看到很多摄像机的混合。 二十六：如何销毁一个UnityEngine.Object及其子类？ 使用Destroy()方法; 二十七：请描述为什么Unity3d中会发生在组件上出现数据丢失的情况 一般是组件上绑定的物体对象被删除了 二十八：LOD是什么，优缺点是什么？ LOD(Level of detail)多层次细节，是最常用的游戏优化技术。它按照模型的位置和重要程度决定物体渲染的资源分配，降低非重要物体的面数和细节度，从而获得高效率的渲染运算。缺点是增加了内存。 二十九：MipMap是什么，作用？ MipMapping：在三维计算机图形的贴图渲染中有常用的技术，为加快渲染进度和减少图像锯齿，贴图被处理成由一系列被预先计算和优化过的图片组成的文件，这样的贴图被称为MipMap。 三十：请描述Interface与抽象类之间的不同 抽象类表示该类中可能已经有一些方法的具体定义，但接口就是公公只能定义各个方法的界面 ，不能具体的实现代码在成员方法中。类是子类用来继承的，当父类已经有实际功能的方法时该方法在子类中可以不必实现，直接引用父类的方法，子类也可以重写该父类的方法。实现接口的时候必须要实现接口中所有的方法，不能遗漏任何一个。 三十一：.Net与Mono的关系？ mono是.net的一个开源跨平台工具，就类似java虚拟机，java本身不是跨平台语言，但运行在虚拟机上就能够实现了跨平台。.net只能在windows下运行，mono可以实现跨平台跑，可以运行于linux，Unix，Mac OS等。 三十二：简述Unity3D支持的作为脚本的语言的名称 Unity的脚本语言基于Mono的.Net平台上运行，可以使用.NET库，这也为XML、数据库、正则表达式等问题提供了很好的解决方案。Unity里的脚本都会经过编译，他们的运行速度也很快。这三种语言实际上的功能和运行速度是一样的，区别主要体现在语言特性上。JavaScript、 C#、Boo 三十三：U3D中用于记录节点空间几何信息的组件名称，及其父类名称 Transform 父类是 Component 三十四：向量的点乘、叉乘以及归一化的意义？ 1.点乘描述了两个向量的相似程度，结果越大两向量越相似，还可表示投影 2.叉乘得到的向量垂直于原来的两个向量 3.标准化向量：用在只关系方向，不关心大小的时候 三十五：为何大家都在移动设备上寻求U3D原生GUI的替代方案 不美观，OnGUI很耗费时间，效率不高，使用不方便 三十六：请简述如何在不同分辨率下保持UI的一致性 NGUI很好的解决了这一点，屏幕分辨率的自适应性，原理就是计算出屏幕的宽高比跟原来的预设的屏幕分辨率求出一个对比值，然后修改摄像机的size。UGUI通过锚点和中心点和分辨率也解决这个问题 三十七：什么是LightMap？ LightMap:就是指在三维软件里实现打好光，然后渲染把场景各表面的光照输出到贴图上，最后又通过引擎贴到场景上，这样就使物体有了光照的感觉。 三十八：Unity和cocos2d的区别 Unity3D支持C#、javascript等，cocos2d-x 支持c++、Html5、Lua等。 cocos2d 开源 并且免费 Unity3D支持iOS、Android、Flash、Windows、Mac、Wii等平台的游戏开发，cocos2d-x支持iOS、Android、WP等。 三十九：C#和C++的区别？ 简单的说：C### 与C++ 比较的话，最重要的特性就是C### 是一种完全面向对象的语言，而C++ 不是，另外C### 是基于IL 中间语言和.NET Framework CLR 的，在可移植性，可维护性和强壮性都比C++ 有很大的改进。C### 的设计目标是用来开发快速稳定可扩展的应用程序，当然也可以通过Interop 和Pinvoke 完成一些底层操作。更详细的区别大家可以参考这里 四十：结构体和类有何区别？ 结构体是一种值类型，而类是引用类型。（值类型、引用类型是根据数据存储的角度来分的）就是值类型用于存储数据的值，引用类型用于存储对实际数据的引用。那么结构体就是当成值来使用的，类则通过引用来对实际数据操作 四十一：ref参数和out参数是什么？有什么区别？ ref和out参数的效果一样，都是通过关键字找到定义在主函数里面的变量的内存地址，并通过方法体内的语法改变它的大小。不同点就是输出参数必须对参数进行初始化。ref必须初始化，out 参数必须在函数里赋值。ref参数是引用，out参数为输出参数。 四十二：C#的委托是什么？有何用处？ 委托类似于一种安全的指针引用，在使用它时是当做类来看待而不是一个方法，相当于对一组方法的列表的引用。用处：使用委托使程序员可以将方法引用封装在委托对象内。然后可以将该委托对象传递给可调用所引用方法的代码，而不必在编译时知道将调用哪个方法。与C或C++中的函数指针不同，委托是面向对象，而且是类型安全的。 四十三：C#中的排序方式有哪些？ 选择排序，冒泡排序，快速排序，插入排序，希尔排序，归并排序 四十四：射线检测碰撞物的原理是？ 射线是3D世界中一个点向一个方向发射的一条无终点的线，在发射轨迹中与其他物体发生碰撞时，它将停止发射 。 四十五：Unity中，照相机的Clipping Planes的作用是什么？调整Near、Fare两个值时，应该注意什么？ 剪裁平面 。从相机到开始渲染和停止渲染之间的距离。 四十六：如何让已经存在的GameObject在LoadLevel后不被卸载掉？ 四十七：请简述GC（垃圾回收）产生的原因，并描述如何避免？ GC回收堆上的内存 避免： 1.减少new产生对象的次数 2.使用公用的对象（静态成员） 3.将String换为StringBuilder 四十八：反射的实现原理？ 审查元数据并收集关于它的类型信息的能力。实现原理：在运行时根据程序集及其中的类型得到元数据。下面是实现步骤： 导入using System.Reflection; Assembly.Load(“程序集”)加载程序集,返回类型是一个Assembly 得到程序集中所有类的名称 Type type = assembly.GetType(“程序集.类名”);获取当前类的类型 Activator.CreateInstance(type); 创建此类型实例 MethodInfo mInfo = type.GetMethod(“方法名”);获取当前方法 m.Info.Invoke(null,方法参数); 四十九：简述四元数的作用，四元数对欧拉角的优点？ 四元数用于表示旋转 相对欧拉角的优点： 1.能进行增量旋转 2.避免万向锁 3.给定方位的表达方式有两种，互为负（欧拉角有无数种表达方式） 五十：移动相机动作在哪个函数里，为什么在这个函数里？ LateUpdate，是在所有的update结束后才调用，比较适合用于命令脚本的执行。官网上例子是摄像机的跟随，都是所有的update操作完才进行摄像机的跟进，不然就有可能出现摄像机已经推进了，但是视角里还未有角色的空帧出现。 五十一：GPU的工作原理 简而言之，GPU的图形（处理）流水线完成如下的工作：（并不一定是按照如下顺序） 顶点处理：这阶段GPU读取描述3D图形外观的顶点数据并根据顶点数据确定3D图形的形状及位置关系，建立起3D图形的骨架。在支持DX8和DX9规格的GPU中，这些工作由硬件实现的Vertex Shader（定点着色器）完成。 光栅化计算：显示器实际显示的图像是由像素组成的，我们需要将上面生成的图形上的点和线通过一定的算法转换到相应的像素点。把一个矢量图形转换为一系列像素点的过程就称为光栅化。例如，一条数学表示的斜线段，最终被转化成阶梯状的连续像素点。 纹理帖图：顶点单元生成的多边形只构成了3D物体的轮廓，而纹理映射（texture mapping）工作完成对多变形表面的帖图，通俗的说，就是将多边形的表面贴上相应的图片，从而生成“真实”的图形。TMU（Texture mapping unit）即是用来完成此项工作。 像素处理：这阶段（在对每个像素进行光栅化处理期间）GPU完成对像素的计算和处理，从而确定每个像素的最终属性。在支持DX8和DX9规格的GPU中，这些工作由硬件实现的Pixel Shader（像素着色器）完成。 最终输出：由ROP（光栅化引擎）最终完成像素的输出，1帧渲染完毕后，被送到显存帧缓冲区。 总结：GPU的工作通俗的来说就是完成3D图形的生成，将图形映射到相应的像素点上，对每个像素进行计算确定最终颜色并完成输出。 五十二：什么是渲染管道？ 是指在显示器上为了显示出图像而经过的一系列必要操作。 渲染管道中的很多步骤，都要将几何物体从一个坐标系中变换到另一个坐标系中去。主要步骤有： 本地坐标-\u0026gt;视图坐标-\u0026gt;背面裁剪-\u0026gt;光照-\u0026gt;裁剪-\u0026gt;投影-\u0026gt;视图变换-\u0026gt;光栅化 五十三：如何优化内存？ 有很多种方式，例如 1.压缩自带类库； 2.将暂时不用的以后还需要使用的物体隐藏起来而不是直接Destroy掉； 3.释放AssetBundle占用的资源； 4.降低模型的片面数，降低模型的骨骼数量，降低贴图的大小； 5.使用光照贴图，使用多层次细节(LOD)，使用着色器(Shader)，使用预设(Prefab)。 6.代码中少产生临时变量 五十四：动态加载资源的方式？他们之间的区别 1.Resources.Load(); 2.AssetBundle 区别参考 五十五：请描述游戏动画有哪几种，以及其原理？ 主要有关节动画、骨骼动画、单一网格模型动画(关键帧动画)。 关节动画：把角色分成若干独立部分，一个部分对应一个网格模型，部分的动画连接成一个整体的动画，角色比较灵活，Quake2中使用这种动画； 骨骼动画，广泛应用的动画方式，集成了以上两个方式的优点，骨骼按角色特点组成一定的层次结构，有关节相连，可做相对运动，皮肤作为单一网格蒙在骨骼之外，决定角色的外观； 单一网格模型动画由一个完整的网格模型构成，在动画序列的关键帧里记录各个顶点的原位置及其改变量，然后插值运算实现动画效果，角色动画较真实。 五十六：alpha blend工作原理 Alpha Blend 实现透明效果，不过只能针对某块区域进行alpha操作，透明度可设。 五十七：写出光照计算中的diffuse的计算公式 五十八：两种阴影判断的方法、工作原理。 本影和半影：参考本影和半影 本影：景物表面上那些没有被光源直接照射的区域（全黑的轮廓分明的区域）。 半影：景物表面上那些被某些特定光源直接照射但并非被所有特定光源直接照射的区域（半明半暗区域） 工作原理：从光源处向物体的所有可见面投射光线，将这些面投影到场景中得到投影面，再将这些投影面与场景中的其他平面求交得出阴影多边形，保存这些阴影多边形信息，然后再按视点位置对场景进行相应处理得到所要求的视图（利用空间换时间，每次只需依据视点位置进行一次阴影计算即可，省去了一次消隐过程） 五十九：Vertex Shader是什么，怎么计算？ 顶点着色器是一段执行在GPU上的程序，用来取代fixed pipeline中的transformation和lighting，Vertex Shader主要操作顶点。 Vertex Shader对输入顶点完成了从local space到homogeneous space（齐次空间）的变换过程，homogeneous space即projection space的下一个space。在这其间共有world transformation, view transformation和projection transformation及lighting几个过程。 六十：下列代码在运行中会产生几个临时对象？ 答案为：5个临时对象 六十一：下列代码在运行中会发生什么问题？如何避免？ 产生运行时错误，在 ls.Remove(item)这行，因为foreach是只读的。不能一边遍历一边修改。 六十二：Unity3D是否支持写成多线程程序？如果支持的话需要注意什么？ 仅能从主线程中访问Unity3D的组件，对象和Unity3D系统调用 支持：如果同时你要处理很多事情或者与Unity的对象互动小可以用thread,否则使用coroutine。 注意：C#中有lock这个关键字,以确保只有一个线程可以在特定时间内访问特定的对象 六十三：Unity3D的协程和C#线程之间的区别是什么？ 多线程程序同时运行多个线程 ，而在任一指定时刻只有一个协程在运行，并且这个正在运行的协同程序只在必要时才被挂起。除主线程之外的线程无法访问Unity3D的对象、组件、方法。 Unity3d没有多线程的概念，不过unity也给我们提供了StartCoroutine（协同程序）和LoadLevelAsync（异步加载关卡）后台加载场景的方法。 StartCoroutine为什么叫协同程序呢，所谓协同，就是当你在StartCoroutine的函数体里处理一段代码时，利用yield语句等待执行结果，这期间不影响主程序的继续执行，可以协同工作。 六十四：矩阵相乘的意义及注意点 用于表示线性变换：旋转、缩放、投影、平移、仿射 注意矩阵的蠕变：误差的积累 六十五：为什么dynamic font在unicode环境下优于static font Unicode是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。 使用动态字体时，Unity将不会预先生成一个与所有字体的字符纹理。当需要支持亚洲语言或者较大的字体的时候，若使用正常纹理，则字体的纹理将非常大。 六十六：当一个细小的高速物体撞向另一个较大的物体时，会出现什么情况？如何避免？ 穿透（碰撞检测失败） 六十七：请简述OnBecameVisible及OnBecameInvisible的发生时机，以及这一对回调函数的意义？ 当物体是否可见切换之时。可以用于只需要在物体可见时才进行的计算。 六十八：什么叫动态合批？跟静态合批有什么区别？ 如果动态物体共用着相同的材质，那么Unity会自动对这些物体进行批处理。动态批处理操作是自动完成的，并不需要你进行额外的操作。 区别：动态批处理一切都是自动的，不需要做任何操作，而且物体是可以移动的，但是限制很多。静态批处理：自由度很高，限制很少，缺点可能会占用更多的内存，而且经过静态批处理后的所有物体都不可以再移动了。 参考 六十九：简述StringBuilder和String的区别？ String是字符串常量。 StringBuffer是字符串变量 ，线程安全。 StringBuilder是字符串变量，线程不安全。 String类型是个不可变的对象，当每次对String进行改变时都需要生成一个新的String对象，然后将指针指向一个新的对象，如果在一个循环里面，不断的改变一个对象，就要不断的生成新的对象，所以效率很低，建议在不断更改String对象的地方不要使用String类型。 StringBuilder对象在做字符串连接操作时是在原来的字符串上进行修改，改善了性能。这一点我们平时使用中也许都知道，连接操作频繁的时候，使用StringBuilder对象。 七十：Unity3D Shader分哪几种，有什么区别？ 表面着色器的抽象层次比较高，它可以轻松地以简洁方式实现复杂着色。表面着色器可同时在前向渲染及延迟渲染模式下正常工作。 顶点片段着色器可以非常灵活地实现需要的效果，但是需要编写更多的代码，并且很难与Unity的渲染管线完美集成。 固定功能管线着色器可以作为前两种着色器的备用选择，当硬件无法运行那些酷炫Shader的时，还可以通过固定功能管线着色器来绘制出一些基本的内容。 七十一：已知strcpy函数的原型是：char * strcpy(char * strDest,const char * strSrc); 1.不调用库函数，实现strcpy函数。2.解释为什么要返回char * 七十二：C#中四种访问修饰符是哪些？各有什么区别？ 1.属性修饰符 2.存取修饰符 3.类修饰符 4.成员修饰符。 属性修饰符： Serializable：按值将对象封送到远程服务器。 STATread：是单线程套间的意思，是一种线程模型。 MATAThread：是多线程套间的意思，也是一种线程模型。 存取修饰符： public：存取不受限制。 private：只有包含该成员的类可以存取。 internal：只有当前工程可以存取。 protected：只有包含该成员的类以及派生类可以存取。 类修饰符： abstract：抽象类。指示一个类只能作为其它类的基类。 sealed：密封类。指示一个类不能被继承。理所当然，密封类不能同时又是抽象类，因为抽象总是希望被继承的。 成员修饰符： abstract：指示该方法或属性没有实现。 sealed：密封方法。可以防止在派生类中对该方法的override（重载）。不是类的每个成员方法都可以作为密封方法密封方法，必须对基类的虚方法进行重载，提供具体的实现方法。所以，在方法的声明中，sealed修饰符总是和override修饰符同时使用。 delegate：委托。用来定义一个函数指针。C#中的事件驱动是基于delegate + event的。 const：指定该成员的值只读不允许修改。 event：声明一个事件。 extern：指示方法在外部实现。 override：重写。对由基类继承成员的新实现。 readonly：指示一个域只能在声明时以及相同类的内部被赋值。 static：指示一个成员属于类型本身，而不是属于特定的对象。即在定义后可不经实例化，就可使用。 virtual：指示一个方法或存取器的实现可以在继承类中被覆盖。 new：在派生类中隐藏指定的基类成员，从而实现重写的功能。 若要隐藏继承类的成员，请使用相同名称在派生类中声明该成员，并用 new 修饰符修饰它。 七十三：Heap与Stack有何区别？ 1.heap是堆，stack是栈。 2.stack的空间由操作系统自动分配和释放，heap的空间是手动申请和释放的，heap常用new关键字来分配。 3.stack空间有限，heap的空间是很大的自由区。 七十四：值类型和引用类型有何区别？ 1.值类型的数据存储在内存的栈中；引用类型的数据存储在内存的堆中，而内存单元中只存放堆中对象的地址。 2.值类型存取速度快，引用类型存取速度慢。 3.值类型表示实际数据，引用类型表示指向存储在内存堆中的数据的指针或引用 4.值类型继承自System.ValueType，引用类型继承自System.Object 5.栈的内存分配是自动释放；而堆在.NET中会有GC来释放 6.值类型的变量直接存放实际的数据，而引用类型的变量存放的则是数据的地址，即对象的引用。 七十五：协同程序的执行代码是什么？有何用处，有何缺点？ 作用：一个协同程序在执行过程中,可以在任意位置使用yield语句。yield的返回值控制何时恢复协同程序向下执行。协同程序在对象自有帧执行过程中堪称优秀。协同程序在性能上没有更多的开销。 缺点：协同程序并非真线程，可能会发生堵塞。 "],["2019年年终总结（作为前端开发这一年）","2019年12月12日","/2019/summary/","如果说2018年是工作之后的人生转折点的话，那么2019年这一年就是转折之后的习惯过程。从大学远离故乡，到毕业到沿海城市就业，再到去年来到东京,这一个个的决定无不是对自我挑战的过程，这期间伴随着阵痛，同时也伴随着成长。有的人习惯了熟悉的生活非常害怕改变，怕换工作，怕搬家，怕交新朋友。各种各样的改变都会对生活带来冲击，但也带来了新鲜感，还是要看自己怎么样来看待这种改变。 进入华人派遣 来日本之前也算是搜集了不少的信息，经过了各种考量觉得进华人派遣公司是不是最优但当前的唯一选择。一般来说到日本做IT相关工作，如果没有日本留学经验，都会经历 这个过程，而我正处在这个初级阶段但不想长期处于初级阶段，所以为此也做了一些准备。 2017年年底通过了Oracle java认证 2019年7月考取了日语能力测试N2证书 2019年8月获取日本自动车驾照 2019年11月参加了中国国家软件考试（软件设计师），但不幸没有通过，准备报2020年5月的软考 2019年12月参加了日语能力测试N1测试（2020年3月公布成绩） 学习Angular/Vue前端开发框架(Javascript/Typescript) 学习Unity3D 但是，如果按照这个计划的话在日本转职至少要2次。日本是一个对跳槽容忍度比较低的国家，一份工作干不到2年就辞职会觉得相当不稳定，对找下份工作和申请永住签证都有一定的影响，所以之后可能会有一些不同的打算。 接下来的计划 打算2020年参加日本IT考试 基本情報技術者試験 打算参加2020年5月的软考 学习Python以便于开发脚本工具/效率工具/游戏逻辑/AI/爬虫等 带老婆孩子在日本定居 申请高级人才签证之后转永住者签证（中国软考和日本IT考试获取证书有助于申请高级人才） 学习英语之后参加托业英语考试进入英语系外企游戏公司 面试游戏公司 在做了11个月的前端开发之后（首次从事前端商业项目开发，但受到领导好评），所在的项目也接近尾声。在寻找下个项目时优先挑选游戏行业的项目，因为在自己离开游戏行业后发现自己不是不喜欢游戏行业，反而是特别喜欢游戏行业所以越发的厌恶中国的圈钱式垃圾游戏。我从来不觉得贪玩蓝月是一个好玩的游戏，只是被资本运作圈钱的一个工具。从小接触到红白机和各种游戏充满了回忆，而这些游戏基本上都是日本开发出来的。所以我离开了待了3年的游戏公司，毅然来到日本。当时也的确厌倦了给垃圾页游换皮的工作内容，再加上自己工作这么多年自己无法独立开发出一个完整的应用（只会后端但前端技术不是很擅长），为了锻炼自己所以找了一个前端开发的工作。到现在来看，我丝毫不觉得这个决定有任何坏的影响。在这近一年的时间中学到了非常非常多前端开发的知识，弥补了自己不会前端的遗憾，也增强了自己的信心。接下来如果运气好能够遇到做游戏客户端开发的工作的话，那就太好了。 面试日本自社公司 申请了 , , 的面谈，希望匹配到合适的自社游戏公司。听在日本做HR的朋友说，日本的游戏行业待遇相当不尽人意，他的一个应届毕业的朋友在做《只狼》的超牛逼的公司年收才给300万+，这着实有点打击了我，不过先面试看看情况吧。 不同契约的区别 刚到日本的时候因为没有什么底气为了保险起见签了正社员的契约，它的区别就是在派遣公司如果一个项目结束之后第二个项目没接上（也就是说没有找到新项目）工资也照常发，但如果是契约社员的话待机的话每个月大概只有12万的待机费。个人当时感觉有点慌，所以选择了正社。但是之后在日本熟悉了，也拿到了N2的证书就转了契约社员。有人肯定会好奇我的动机，因为正社员公司会交保险和年金，各负担一半。但是我在的公司没有交年金，保险也是自己负担，契约的话到手的工资会高一些，所以就转成了契约。后来听前辈说契约社员的话签证更新的话比较难拿到3年以上的，这个我也找别的朋友确认过，没有统一的说话，但是长期待在华人派遣公司不是办法。至少也要向日本大手派遣公司努力，签个正社待遇也是不错的。 "],["经历了几场面试后的全球同服架构思考","2019年12月12日","/2019/worldservergame/","从自己的游戏从业经验来看，一直做的是滚服机制的游戏，当然也是因为我游戏从业经历不多。中国的网络游戏喜欢开小服，制造玩家矛盾，引起战斗，进而让用户心甘情愿充钱的氪金模式。日本的大部分游戏是做内容，所以基本上都是同服机制，但是因为知识水平受限面试表现并不尽如意，之后专门查资料研究了一番。 首先，游戏服务器是IO密集型服务器，它的主要瓶颈在网络IO，而不是CPU，这点要记住了。所以经常服务器问题都会出现在网络IO，带宽，数据库磁盘读写上面，而非CPU上面。 其实全球同服也就是大量在线，只是你看起来同服，而不是他本身就在同一个服务器上，或者同一个进程上，这是完全不现实的。一个好的服务器进程，能同时承载10k的游戏玩家(还依赖于游戏逻辑复杂度)已经不错了。其实要全球同服，就是堆服务器进程嘛。 1.Gate: 首先要有一个(多个)Gate(网关)服务器，负责客户端连接及消息转发到GameServer(游戏服)（选服逻辑）,保持客户端到服务端的连接。没有任何逻辑，只做消息加密和解密，以及客户端和服务器消息的转发(相当于两者之间的桥梁). 2.GameServer: GameServer是主要的游戏进程,提供游戏逻辑功能(采用单进程(或者单线程)模型,游戏服务器的瓶颈从来不在CPU,所以只做逻辑功能的话单线程足够了,在这里没必要用多线程或多进程)。 3.DBManager: 实现数据库的读写，方便Game服务器异步读写数据库的数据(有些把数据库读写放在游戏服，没有单独的服务器，那恐怕游戏服单进程就不够用了)。 4.GameManager: 负责管理所有的GameServer，GameServer之间消息转发，提供广播到所有Game的功能。 客户端连Gate，Gate连GameServer，GameServer连DBManager，GameManager管理所有的GameServer并通知所有的Gate。 除了GameManager只有一个，理论上Gate，GameServer，DBManager都可以扩展到多个实例，你要实现全球唯一服，理论上就是扩展GameServer，那么怎么让他们看起来在一个服呢？其实很简单，COC大多数都是单服玩法，只有交互玩法的时候你才能感受到它是同一个服。 主要讲讲GameServer，这是主要的处理服务器逻辑的地方，一般单进程就可以了，一个epoll_wait hold住全场，然后做分发，理论上cpu都能承载的住，而epoll能处理的上限，一般跟机器的内存有关，远大于1024，正常的也达到100k，当然考虑到逻辑的复杂度，一个实例一般处理的连接接近10k就可以了。 那怎么处理100k，1000k甚至更多了，那就多个实例，那这样还是唯一服吗？是的，至少可以看起来是，游戏自然有单人玩法和多人玩法，单人玩法自然自己在自己的服就可以了，谁也不知道是不是跟别人一个服。 当然有全服的排行榜，好友系统之类的怎么办呢，其实很简单，我们不是有GameManager吗，它就是负责做这事的，每当你发个好友请求，GameManager广播一条消息，然后如果有某个GameServer存在这个玩家，那就回应你，你们就可以相互通信了，更简单的想办法获取玩家的服务器ID号，直接通过GameManager转发给那个服务器，自然就可以通信了，就像在同一个服务器一样。 排行榜呢，最简单的，指定一个服务器，或者单独开辟一个服务器做排行榜，所有数据变动都通知这个服务器，然后服务器自然就能排行了，然后再广播。 双人战斗或者多人副本呢？ 像COC这样的，掠夺战，我们当时的做法就是，直接搜到敌方，然后把自己的玩家，士兵军队等需要的数据序列化之后，传到对面的服务器去，反序列化，然后直接开打，打完再把数据传回来。 更多人的呢，那就方便点，再开辟一类服务器，叫BattleServer，专门负责多人玩法，副本玩法之类的，多人的时候，把所有的多人数据迁移到BattleServer，然后多人（副本玩法）结束的时候，再通过GameManager把数据迁移回原来的服务器。 这样看，其实全球唯一服也就没有那么高大上了。 "],["签证总结大全（工作签、在留卡加汉字、工作签证更新、家族签证等）","2019年10月10日","/2019/aboutallvisa/","今天办理了家族签证和工作签更新，突然发现自己接触的签证相关的也有4种类型了，所以差不多可以做个总结性blog了。今天办签证遇到的坑很多，感觉真是难以言说。先是公司资料没有寄到，自己去公司拿了一趟。之后告知需要去区役所开非课税证明，而去了之后说是未满一年开不了。各种种的坑，觉得需要记录下来，给需要的朋友少走弯路。 东京入管局概述 东京入管局一共有5个区，分别是A（红色）留学类、更新再交付 B（橘黄色）签证更新、C（蓝色）就劳相谈、D（绿色）永驻/再交付/再入国、E（1楼）家族签证。ABCD在二楼，E在1楼。 首次工作签 理论上来说大专以上的学历都是可以到日本工作的，只要在日本的公司给offer就可以。所以首先是在招聘App上更新简历，我是通过猎聘app上拿到的offer。日本IT相关工作非常缺人，一般来说单纯在上面更新一下简历不需要投递就会有一大波猎头主动过去找你。然后就是精挑细选，挑出觉得比较合适的公司和猎头沟通进行面试安排。一般来说首次来日工作的话都是进的华人外派公司作为跳板，待1-2年之后有合适的机会再换。所以远程面试可能会用wechat视频等不是很正规的方式。等offer确定后就可以和公司沟通办理签证相关事项了，工作签证需要3个月左右。给大家一个提醒，还没给你发工资就要找你要钱的果断拉黑，都9102了相信也不会有人会被这种骗术骗到了吧。 需要的资料 毕业证 学位证（专科不需要） 护照 将1-3资料国际快递给公司，之后剩下的时间就是等待了。如果这期间日语不是很好，而经济又不是很紧张的话可以报个班学习一下，这点投入是很值得的。 去日本需要准备的东西 这些内容一般来说公司会交代，但是不一定会很详细，在此列举一下。 印章（12mm左右），日本社会对印章信任度大过签字 一张visa或jcb的信用卡，银联不可。因为不支持绑定手机卡消费 西瓜卡（可以在淘宝上买，也可以下飞机了再买，不过提前准备我觉得更好，坐车吃饭都可以用） 现金若干，不用太多，刷卡一样的，主要用来应急用。 手机卡（或者在支付宝买一个国际流量包） 家族关系公正书（公正处可以办），主要用来年底申请抚养时退税用，如果不在乎这点钱就直接忽略吧 一些小东西，比如指甲钳、挖耳勺之类的刚到日本可能都不知道在哪买，自备一个挺方便。（推荐一个日本的百元连锁店Daiso，生活用品又全又便宜） 以上是1年前来日本时准备的东西的回忆版，可能有所遗漏，想到再补充吧。 在留卡加汉字 初次工作签到日本的话，拿着在留资格认定书在入关换在留卡的时候给的卡是只有拼音名字。如果觉得不方便的话可以之后去入管局申请加一下汉字，当天就能拿到。 需要的资料 护照 在留卡 申请表（可以到入管了再拿申请表填） 照片*1 1500日币 去拿新的在留卡的时候他们会把你原来的在留卡挖个洞再还给你。老的在留卡虽然不知道还有没有用，但是最好不要丢，拿回去放着，也不会吃你家大米不是？ 工作签到期更新 在签证快到期时就在留意去入管更新了，一般在到期前3个月都可以去。要跑两趟的，第一趟去申请更新，会拿到回执。之后会寄通知单过来，再去一趟拿新的在留卡，需要4000日币的更新费用。拿到新的在留卡之后记得把填的老的在留卡的信息的地方全部更新一下，然后拍一张电子照留存。 办理更新是在B区，也是人最多的一个区，拿号都得排队。B1-B4是资料提交区，B5-B6是回执交付区。也就是说在B1-B4递送资料，然后在B5-B6等着。B7是排队拿号的地方，也是噩梦的开始。在等候区有个日本老头找我们聊天说以后如果来入管尽量避开周一和周四，说这2天人超级多。感觉日本的老头老太太都好優しい啊，来日本没多久已经被很多老头老太太关照，暖心的不得了。 这是从公司拿到的资料 2019年11月25追记： 时隔整整一个月，入管终于把通知去拿在留卡的明信片送过来了，然后带上必要的资料去换卡就好了。我早上7点左右出发，11点拿到在留卡（2楼A1区），天还下着雨。但是拿到3年的签证还是很开心的，同事更新后还是一年，虽然不知道有什么讲究。 护照 在留卡 回执 通知卡 4000円（到入管后的全家便利店买4000的邮票） 需要的资料 在留期间申请更新表 照片 4*3 白底 无帽 正面（3个月内，如果不在3个月内也不要用和上一个在留卡一样的照片，这不是明明白白的告诉他们你的照片是1年前的么） 在留卡 护照 住民税证明（不满1年不需要，因为也开不出来。日本不会出现踢皮球式的刁难，一边不给开另一边非得要） 以下资料公司准备 雇用契约书 （公司准备） 登记薄滕本（公司准备） 决算报告书（公司准备） 法定调书合计表（公司准备） 在留期间更新许可申请书（公司准备） 这个是拿到的回执单，一把辛酸泪。 家族签证 这次的家族签证是给老婆孩子办的，家族签证可以在日本生活但没有就劳资格。申请所需要时间在1-3个月之间。据说提交的资料越全下签越快，通过率越高，所以我也是尽可能的多准备些资料。换到在留卡之后可以去区役所申请补助，一个月1万5000日元，一直补贴到16岁。1岁半之后就可以免费送去保育园上学，3岁后可以免费上幼儿园。如果抚养者交了社保或者国民健康保险的话老婆孩子都可以享受福利。一家3口，孩子全免，大人负担30%，一个月上限8万日元。以下是所需的资料： 申请书 家族签证申请书（有几个人就需要填几份） 复印件 护照复印件 在留卡复印件 结婚证复印件 出生证明复印件（没有孩子就不需要） 公正书 家族关系公正书 结婚证公正书 出生证明公正书（没有孩子就不需要） 其他 夫妻交往照片*10 证件照*1（小孩的也需要，我在官网查的资料写16岁以下不要，去了又说要可急坏了我，最后拍了一张护照上的照片应急搞定了） 在职证明 未来半年的收入证明 去1楼的全家花417买简易书留的信封 工具 剪刀（打照片剪照片用） 固体胶（贴照片用） 笔和本子 订书机（固定资料） 在留卡（申请者身份证明） 护照（提前都复印好了可以不用带） 这是个自己做的一些记录 这个是家族签证的回执单 永住者签证 目前暂未涉及，留坑以后补充 "],["jdk源码系列-Java到底是值传递还是引用传递？","2019年08月08日","/2019/javapassbyvalueandreference/","首先，不要纠结于 Pass By Value 和 Pass By Reference 的字面上的意义，否则很容易陷入所谓的“一切传引用其实本质上是传值”这种并不能解决问题无意义论战中。更何况，要想知道Java到底是传值还是传引用，起码你要先知道传值和传引用的准确含义吧？可是如果你已经知道了这两个名字的准确含义，那么你自己就能判断Java到底是传值还是传引用。这就好像用大学的名词来解释高中的题目，对于初学者根本没有任何意义。 一、搞清楚 基本类型 和 引用类型的不同之处 如图所示，num是基本类型，值就直接保存在变量中。而str是引用类型，变量中保存的只是实际对象的地址。一般称这种变量为\u0026quot;引用\u0026quot;，引用指向实际对象，实际对象中保存着内容。 二、搞清楚赋值运算符（=）的作用 对于基本类型 num ，赋值运算符会直接改变变量的值，原来的值被覆盖掉。对于引用类型 str，赋值运算符会改变引用中所保存的地址，原来的地址被覆盖掉。 如上图所示，\u0026ldquo;hello\u0026rdquo; 字符串对象没有被改变。（没有被任何引用所指向的对象是垃圾，会被垃圾回收器回收） 三、调用方法时发生了什么？参数传递基本上就是赋值操作。 重点理解为什么，第三个例子和第四个例子结果不同？ 下面是第三个例子的图解： 下面是第四个例子的图解： 之后 从局部变量/方法参数开始讲起 局部变量和方法参数在jvm中的储存方法是相同的，都是在栈上开辟空间来储存的，随着进入方法开辟，退出方法回收。以32位JVM为例，boolean/byte/short/char/int/float以及引用都是分配4字节空间，long/double分配8字节空间。对于每个方法来说，最多占用多少空间是一定的，这在编译时就可以计算好。 我们都知道JVM内存模型中有，stack和heap的存在，但是更准确的说，是每个线程都分配一个独享的stack，所有线程共享一个heap。对于每个方法的局部变量来说，是绝对无法被其他方法，甚至其他线程的同一方法所访问到的，更遑论修改。当我们在方法中声明一个 int i = 0，或者 Object obj = null 时，仅仅涉及stack，不影响到heap，当我们 new Object() 时，会在heap中开辟一段内存并初始化Object对象。 当我们将这个对象赋予obj变量时，仅仅是stack中代表obj的那4个字节变更为这个对象的地址。 数组类型引用和对象： 当我们声明一个数组时，如int[] arr = new int[10]，因为数组也是对象，arr实际上是引用，stack上仅仅占用4字节空间，new int[10]会在heap中开辟一个数组对象，然后arr指向它。 当我们声明一个二维数组时，如 int[][] arr2 = new int[2][4]，arr2同样仅在stack中占用4个字节，会在内存中开辟一个长度为2的，类型为int[]的数组，然后arr2指向这个数组。这个数组内部有两个引用（大小为4字节），分别指向两个长度为4的类型为int的数组。 所以当我们传递一个数组引用给一个方法时，数组的元素是可以被改变的，但是无法让数组引用指向新的数组。 你还可以这样声明：int[][] arr3 = new int[3][]，这时内存情况如下图 你还可以这样 arr3[0] = new int [5]; arr3[1] = arr2[0]; 关于String String对象内部仅需要维护三个变量，char[] chars, int startIndex, int length。而chars在某些情况下是可以共用的。但是因为String被设计成为了不可变类型，所以你思考时把String对象简化考虑也是可以的。String str = new String(\u0026ldquo;hello\u0026rdquo;) 当然某些JVM实现会把\u0026quot;hello\u0026quot;字面量生成的String对象放到常量池中，而常量池中的对象可以实际分配在heap中，有些实现也许会分配在方法区，当然这对我们理解影响不大。 "],["jdk源码系列-Thread.sleep(0)和Thread.sleep(1)的区别","2019年07月07日","/2019/jdksourcecodereadthreadsleep/","某人的代码中用了一句看似莫明其妙的话：Thread.Sleep(0) 。既然是 Sleep 0 毫秒，那么他跟去掉这句代码相比，有啥区别么？Thread.Sleep(0) 表示挂起0毫秒，你可能觉得没作用，你要写Thread.Sleep(1000) 就有感觉了。 Thread.Sleep(0) 并非是真的要线程挂起0毫秒，意义在于这次调用Thread.Sleep(0)的当前线程确实的被冻结了一下，让其他线程有机会优先执行。Thread.Sleep(0) 是你的线程暂时放弃cpu，也就是释放一些未用的时间片给其他线程或进程使用，就相当于一个让位动作。 在线程中，调用sleep（0）可以释放cpu时间，让线程马上重新回到就绪队列而非等待队列，sleep(0)释放当前线程所剩余的时间片（如果有剩余的话），这样可以让操作系统切换其他线程来执行，提升效率。 我们可能经常会用到 Thread.Sleep 函数来使线程挂起一段时间。那么你有没有正确的理解这个函数的用法呢？ 回顾一下操作系统原理 操作系统中，CPU竞争有很多种策略。Unix系统使用的是时间片算法，而Windows则属于抢占式的。 在时间片算法中，所有的进程排成一个队列。操作系统按照他们的顺序，给每个进程分配一段时间，即该进程允许运行的时间。如果在 时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。调度程 序所要做的就是维护一张就绪进程列表，，当进程用完它的时间片后，它被移到队列的末尾。 所谓抢占式操作系统，就是说如果一个进程得到了 CPU 时间，除非它自己放弃使用 CPU ，否则将完全霸占 CPU 。因此可以看出，在抢 占式操作系统中，操作系统假设所有的进程都是“人品很好”的，会主动退出 CPU 。在抢占式操作系统中，假设有若干进程，操作系统会根据他们的优先级、饥饿时间（已经多长时间没有使用过 CPU 了），给他们算出一 个总的优先级来。操作系统就会把 CPU 交给总优先级最高的这个进程。当进程执行完毕或者自己主动挂起后，操作系统就会重新计算一 次所有进程的总优先级，然后再挑一个优先级最高的把 CPU 控制权交给他。 我们用分蛋糕的场景来描述这两种算法。假设有源源不断的蛋糕（源源不断的时间），一副刀叉（一个CPU），10个等待吃蛋糕的人（10 个进程）。 如果是 Unix操作系统来负责分蛋糕，那么他会这样定规矩：每个人上来吃 1 分钟，时间到了换下一个。最后一个人吃完了就再从头开始。于是，不管这10个人是不是优先级不同、饥饿程度不同、饭量不同，每个人上来的时候都可以吃 1 分钟。当然，如果有人本来不太饿，或者饭量小，吃了30秒钟之后就吃饱了，那么他可以跟操作系统说：我已经吃饱了（挂起）。于是操作系统就会让下一个人接着来。 如果是 Windows 操作系统来负责分蛋糕的，那么场面就很有意思了。他会这样定规矩：我会根据你们的优先级、饥饿程度去给你们每个人计算一个优先级。优先级最高的那个人，可以上来吃蛋糕——吃到你不想吃为止。等这个人吃完了，我再重新根据优先级、饥饿程度来计算每个人的优先级，然后再分给优先级最高的那个人。 这样看来，这个场面就有意思了——可能有些人是PPMM，因此具有高优先级，于是她就可以经常来吃蛋糕。可能另外一个人是个丑男，而去很ws，所以优先级特别低，于是好半天了才轮到他一次（因为随着时间的推移，他会越来越饥饿，因此算出来的总优先级就会越来越高，因此总有一天会轮到他的）。而且，如果一不小心让一个大胖子得到了刀叉，因为他饭量大，可能他会霸占着蛋糕连续吃很久很久，导致旁边的人在那里咽口水。。。 而且，还可能会有这种情况出现：操作系统现在计算出来的结果，5号PPMM总优先级最高，而且高出别人一大截。因此就叫5号来吃蛋糕。5号吃了一小会儿，觉得没那么饿了，于是说“我不吃了”（挂起）。因此操作系统就会重新计算所有人的优先级。因为5号刚刚吃过，因此她的饥饿程度变小了，于是总优先级变小了；而其他人因为多等了一会儿，饥饿程度都变大了，所以总优先级也变大了。不过这时候仍然有可能5号的优先级比别的都高，只不过现在只比其他的高一点点——但她仍然是总优先级最高的啊。因此操作系统就会说：5号mm上来吃蛋糕……（5号mm心里郁闷，这不刚吃过嘛……人家要减肥……谁叫你长那么漂亮，获得了那么高的优先级）。 那么，Thread.Sleep 函数是干吗的呢？还用刚才的分蛋糕的场景来描述。上面的场景里面，5号MM在吃了一次蛋糕之后，觉得已经有8分饱了，她觉得在未来的半个小时之内都不想再来吃蛋糕了，那么她就会跟操作系统说：在未来的半个小时之内不要再叫我上来吃蛋糕了。这样，操作系统在随后的半个小时里面重新计算所有人总优先级的时候，就会忽略5号mm。Sleep函数就是干这事的，他告诉操作系统“在未来的多少毫秒内我不参与CPU竞争”。 看完了 Thread.Sleep 的作用，我们再来想想文章开头的两个问题。 对于第一个问题，答案是：不一定。因为你只是告诉操作系统：在未来的1000毫秒内我不想再参与到CPU竞争。那么1000毫秒过去之后，这时候也许另外一个线程正在使用CPU，那么这时候操作系统是不会重新分配CPU的，直到那个线程挂起或结束；况且，即使这个时候恰巧轮到操作系统进行CPU 分配，那么当前线程也不一定就是总优先级最高的那个，CPU还是可能被其他线程抢占去。与此相似的，Thread有个Resume函数，是用来唤醒挂起的线程的。好像上面所说的一样，这个函数只是“告诉操作系统我从现在起开始参与CPU竞争了”，这个函数的调用并不能马上使得这个线程获得CPU控制权。 对于第二个问题，答案是：有，而且区别很明显。假设我们刚才的分蛋糕场景里面，有另外一个PPMM 7号，她的优先级也非常非常高（因为非常非常漂亮），所以操作系统总是会叫道她来吃蛋糕。而且，7号也非常喜欢吃蛋糕，而且饭量也很大。不过，7号人品很好，她很善良，她没吃几口就会想：如果现在有别人比我更需要吃蛋糕，那么我就让给他。因此，她可以每吃几口就跟操作系统说：我们来重新计算一下所有人的总优先级吧。不过，操作系统不接受这个建议——因为操作系统不提供这个接口。于是7号mm就换了个说法：“在未来的0毫秒之内不要再叫我上来吃蛋糕了”。这个指令操作系统是接受的，于是此时操作系统就会重新计算大家的总优先级——注意这个时候是连7号一起计算的，因为“0毫秒已经过去了”嘛。因此如果没有比7号更需要吃蛋糕的人出现，那么下一次7号还是会被叫上来吃蛋糕。 因此，Thread.Sleep(0)的作用，就是“触发操作系统立刻重新进行一次CPU竞争”。竞争的结果也许是当前线程仍然获得CPU控制权，也许会换成别的线程获得CPU控制权。这也是我们在大循环里面经常会写一句Thread.Sleep(0) ，因为这样就给了其他线程比如Paint线程获得CPU控制权的权力，这样界面就不会假死在那里。 末了说明一下，虽然上面提到说“除非它自己放弃使用 CPU ，否则将完全霸占 CPU”，但这个行为仍然是受到制约的——操作系统会监控你霸占CPU的情况，如果发现某个线程长时间霸占CPU，会强制使这个线程挂起，因此在实际上不会出现“一个线程一直霸占着 CPU 不放”的情况。至于我们的大循环造成程序假死，并不是因为这个线程一直在霸占着CPU。实际上在这段时间操作系统已经进行过多次CPU竞争了，只不过其他线程在获得CPU控制权之后很短时间内马上就退出了，于是就又轮到了这个线程继续执行循环，于是就又用了很久才被操作系统强制挂起。。。因此反应到界面上，看起来就好像这个线程一直在霸占着CPU一样。 末了再说明一下，文中线程、进程有点混乱，其实在Windows原理层面，CPU竞争都是线程级的，本文中把这里的进程、线程看成同一个东西就好了。 问题：主动的放弃运行让系统调度的意义是什么呢？ 为了等待资源、事件，那么你需要进入等待队列。如果你已经拥有运行所需资源，却让系统调度，这是资源的浪费，并且调度也是要浪费资源的 解释：对的，你要等待资源，你确实需要排队，假如AB两个线程为合作关系，A线程处理一些原始数据，数据处理到一定程度，交给B线程处理，在A处理原始数据的时候，B也要做一些准备工作，所以，AB是并发的，但是B做好准备之后，需要等待A处理好那些数据，接过A的数据，继续处理，因此，这个等待，如果A不使用信号或者等待条件来通知B的话，那么B必须一直轮询，查看A是否已完成，B线程所做的这个轮询是否会一直占用CPU来做无用的循环查看呢？因此B这个时候占用的cpu时间片做的是无用功，因此，这里sleep(0)就有作用，当B查看A没处理完数据的时候，B马上sleep(0)交出B的时间片，让操作系统调度A来运行(假设只有AB两个线程），那么这个时候，A就会得到充分的时间来处理它的数据，这个不是一个应用了吗？我猜测pthread_conn_wait()内部阻塞就是使用这个机制 没有sleep(0)版： 如果说是轮询，那它就是一种高效、节约、谦虚的轮询，如果没有sleep(0)，那么B线程可能会执行上万次的while循环，直至它的时间片消耗完，做这些都是无用功，而是用了sleep(0)后，B线程每一次执行就只做一次while循环就把剩余的时间片让出给A，能让A得到更多的执行次数,利用率更高 总结： 在线程没退出之前，线程有三个状态，就绪态，运行态，等待态。sleep(n)之所以在n秒内不会参与CPU竞争，是因为，当线程调用sleep(n)的时候，线程是由运行态转入等待态，线程被放入等待队列中，等待定时器n秒后的中断事件，当到达n秒计时后，线程才重新由等待态转入就绪态，被放入就绪队列中，等待队列中的线程是不参与cpu竞争的，只有就绪队列中的线程才会参与cpu竞争，所谓的cpu调度，就是根据一定的算法（优先级，FIFO等。。。），从就绪队列中选择一个线程来分配cpu时间。 而sleep(0)之所以马上回去参与cpu竞争，是因为调用sleep(0)后，因为0的原因，线程直接回到就绪队列，而非进入等待队列，只要进入就绪队列，那么它就参与cpu竞争。 "],["restful最佳实践","2019年07月07日","/2019/restfulbestuse/","restful 是目前最流行的 API 设计规范，用于 Web 数据接口的设计。它的大原则容易把握，但是细节不容易做对。 不要纠结于无意义的规范 在开始本文之前，我想先说这么一句：RESTful 真的很好，但它只是一种软件架构风格，过度纠结如何遵守规范只是徒增烦恼，也违背了使用它的初衷。 就像 Elasticsearch 的 API 会在 GET 请求中直接传 JSON，但这是它的业务需要，因为普通的 Query Param 根本无法构造如此复杂的查询 DSL。Github 的 V3 API 中也有很多不符合标准的地方，这也并不会妨碍它成为业界 RESTful API 的参考标准。 我接下来要介绍的一些东西也会跟标准不符，但这是我在实际开发中遇到过、困扰过、思考过所得出的结论，所以才是我所认为的RESTful API 最佳实践。 为什么要用 RESTful RESTful 给我的最大感觉就是规范、易懂和优雅，一个结构清晰、易于理解的 API 完全可以省去许多无意义的沟通和文档。并且 RESTful 现在越来越流行，也有越来越多优秀的周边工具（例如文档工具 Swagger）。 协议 如果能全站 HTTPS 当然是最好的，不能的话也请尽量将登录、注册等涉及密码的接口使用 HTTPS。 版本 API 的版本号和客户端 APP 的版本号是毫无关系的，不要让 APP 将它们用于提交应用市场的版本号传递到服务器，而是提供类似于 、 之类的 API 版本号。版本号只允许枚举，不允许判断区间。 版本号拼接在 URL 中或是放在 Header 中都可以。例如： 或： URL 设计 动词+宾语 RESTful 的核心思想就是，客户端发出的数据操作指令都是\u0026quot;动词 + 宾语\u0026quot;的结构。比如，GET /articles这个命令，GET是动词，/articles是宾语。 动词通常就是五种 HTTP 方法，对应 CRUD 操作。 动词的覆盖 有些客户端只能使用GET和POST这两种方法。服务器必须接受POST模拟其他三个方法（PUT、PATCH、DELETE）。 这时，客户端发出的 HTTP 请求，要加上X-HTTP-Method-Override属性，告诉服务器应该使用哪一个动词，覆盖POST方法。 宾语必须是名词 宾语就是 API 的 URL，是 HTTP 动词作用的对象。它应该是名词，不能是动词。比如，/articles这个 URL 就是正确的，而下面的 URL 不是名词，所以都是错误的。 复数 URL 既然 URL 是名词，那么应该使用复数，还是单数？ 这没有统一的规定，但是常见的操作是读取一个集合，比如GET /articles（读取所有文章），这里明显应该是复数。 为了统一起见，建议都使用复数 URL，比如GET /articles/2要好于GET /article/2。 避免多级 URL 常见的情况是，资源需要多级分类，因此很容易写出多级的 URL，比如获取某个作者的某一类文章。 这种 URL 不利于扩展，语义也不明确，往往要想一会，才能明白含义。 更好的做法是，除了第一级，其他级别都用查询字符串表达。 请求 一般来说 API 的外在形式无非就是增删改查（当然具体的业务逻辑肯定要复杂得多），而查询又分为详情和列表两种，在 RESTful 中这就相当于通用的模板。例如针对文章（Article）设计 API，那么最基础的 URL 就是这几种： RESTful 中使用 GET、POST、PUT 和 DELETE 来表示资源的查询、创建、更改、删除，并且除了 POST 其他三种请求都具备幂等性（多次请求的效果相同）。需要注意的是 POST 和 PUT 最大的区别就是幂等性，所以 PUT 也可以用于创建操作，只要在创建前就可以确定资源的 id。 将 id 放在 URL 中而不是 Query Param 的其中一个好处是可以表示资源之间的层级关系，例如文章下面会有评论（Comment）和点赞（Like），这两项资源必然会属于一篇文章，所以它们的 URL 应该是这样的： 评论： 这里有一点比较特殊，永远去使用可以指向资源的的最短 URL 路径，也就是说既然 已经可以指向一条评论了，就不需要再用 特意的指出所属文章了。 点赞： 由于大部分的关系查询都与当前的登录用户有关，所以也可以直接在关系所属的资源中返回关系状态。例如点赞状态就可以直接在获取文章详情时返回。注意这里我选择了 PUT 而不是 POST，因为我觉得点赞这种行为应该是幂等的，多次操作的结果应该相同。 Token 和 Sign API 需要设计成无状态，所以客户端在每次请求时都需要提供有效的 Token 和 Sign，在我看来它们的用途分别是： Token 用于证明请求所属的用户，一般都是服务端在登录后随机生成一段字符串（UUID）和登录用户进行绑定，再将其返回给客户端。Token 的状态保持一般有两种方式实现：一种是在用户每次操作都会延长或重置 TOKEN 的生存时间（类似于缓存的机制），另一种是 Token 的生存时间固定不变，但是同时返回一个刷新用的 Token，当 Token 过期时可以将其刷新而不是重新登录。 Sign 用于证明该次请求合理，所以一般客户端会把请求参数拼接后并加密作为 Sign 传给服务端，这样即使被抓包了，对方只修改参数而无法生成对应的 Sign 也会被服务端识破。当然也可以将时间戳、请求地址和 Token 也混入 Sign，这样 Sign 也拥有了所属人、时效性和目的地。 统计性参数 我不太清楚这类参数具体该被称为什么，总之就是用户的各种隐私【误。类似于经纬度、手机系统、型号、IMEI、网络状态、客户端版本、渠道等，这些参数会经常收集然后用作运营、统计等平台，但是在大部分情况下他们是与业务无关的。这类参数变化不频繁的可以在登录时提交，变化比较频繁的可以用轮训或是在其他请求中附加提交。 业务参数 在 RESTful 的标准中，PUT 和 PATCH 都可以用于修改操作，它们的区别是 PUT 需要提交整个对象，而 PATCH 只需要提交修改的信息。但是在我看来实际应用中不需要这么麻烦，所以我一律使用 PUT，并且只提交修改的信息。 另一个问题是在 POST 创建对象时，究竟该用表单提交更好些还是用 JSON 提交更好些。其实两者都可以，在我看来它们唯一的区别是 JSON 可以比较方便的表示更为复杂的结构（有嵌套对象）。另外无论使用哪种，请保持统一，不要两者混用。 还有一个建议是最好将过滤、分页和排序的相关信息全权交给客户端，包括过滤条件、页数或是游标、每页的数量、排序方式、升降序等，这样可以使 API 更加灵活。但是对于过滤条件、排序方式等，不需要支持所有方式，只需要支持目前用得上的和以后可能会用上的方式即可，并通过字符串枚举解析，这样可见性要更好些。例如： 搜索，客户端只提供关键词，具体搜索的字段，和搜索方式（前缀、全文、精确）由服务端决定： 过滤，只需要对已有的情况进行支持： 对于某些特定且复杂的业务逻辑，不要试图让客户端用复杂的查询参数表示，而是在 URL 使用别名： 分页： 排序，只需要对已有的情况进行支持： PS：我很喜欢这种在字段名前面加 表示降序排列的方式。 响应 HTTP 状态码就是一个三位数，分成五个类别。 这五大类总共包含100多种状态码，覆盖了绝大部分可能遇到的情况。每一种状态码都有标准的（或者约定的）解释，客户端只需查看状态码，就可以判断出发生了什么情况，所以服务器应该返回尽可能精确的状态码。 API 不需要1xx状态码，下面介绍其他四类状态码的精确含义。 2xx 状态码 200状态码表示操作成功，但是不同的方法可以返回更精确的状态码。 上面代码中，POST返回201状态码，表示生成了新的资源；DELETE返回204状态码，表示资源已经不存在。 此外，202 Accepted状态码表示服务器已经收到请求，但还未进行处理，会在未来再处理，通常用于异步操作。下面是一个例子 3xx 状态码 API 用不到301状态码（永久重定向）和302状态码（暂时重定向，307也是这个含义），因为它们可以由应用级别返回，浏览器会直接跳转，API 级别可以不考虑这两种情况。 API 用到的3xx状态码，主要是303 See Other，表示参考另一个 URL。它与302和307的含义一样，也是\u0026quot;暂时重定向\u0026quot;，区别在于302和307用于GET请求，而303用于POST、PUT和DELETE请求。收到303以后，浏览器不会自动跳转，而会让用户 4xx 状态码 5xx 状态码 但是有些时候仅仅使用 HTTP 状态码没有办法明确的表达错误信息，所以我倾向于在里面再包一层自定义的返回码，例如： 成功时： 失败时： 是真正需要返回的数据，并且只会在请求成功时才存在， 只用在开发环境，并且只为了开发人员识别。客户端逻辑只允许识别 ，并且不允许直接将 的内容展示给用户。如果这个错误很复杂，无法使用一段话描述清楚，也可以在添加一个 字段，包含指向该错误的文档的链接。 返回数据 不要返回纯本文 API 返回的数据格式，不应该是纯文本，而应该是一个 JSON 对象，因为这样才能返回标准的结构化数据。所以，服务器回应的 HTTP 头的Content-Type属性要设为application/json。 客户端请求时，也要明确告诉服务器，可以接受 JSON 格式，即请求的 HTTP 头的ACCEPT属性也要设成application/json。下面是一个例子。 发生错误时，不要返回 200 状态码 有一种不恰当的做法是，即使发生错误，也返回200状态码，把错误信息放在数据体里面，就像下面这样。 上面代码中，解析数据体以后，才能得知操作失败。 这张做法实际上取消了状态码，这是完全不可取的。正确的做法是，状态码反映发生的错误，具体的错误信息放在数据体里面返回。下面是一个例子。 提供链接 API 的使用者未必知道，URL 是怎么设计的。一个解决方法就是，在回应中，给出相关链接，便于下一步操作。这样的话，用户只要记住一个 URL，就可以发现其他的 URL。这种方法叫做 HATEOAS。 举例来说，GitHub 的 API 都在 api.github.com 这个域名。访问它，就可以得到其他 URL。 上面的回应中，挑一个 URL 访问，又可以得到别的 URL。对于用户来说，不需要记住 URL 设计，只要从 api.github.com 一步步查找就可以了。 HATEOAS 的格式没有统一规定，上面例子中，GitHub 将它们与其他属性放在一起。更好的做法应该是，将相关链接与其他属性分开。 JSON 比 XML 可视化更好，也更加节约流量，所以尽量不要使用 XML。 创建和修改操作成功后，需要返回该资源的全部信息。 返回数据不要和客户端界面强耦合，不要在设计 API 时就考虑少查询一张关联表或是少查询 / 返回几个字段能带来多大的性能提升。并且一定要以资源为单位，即使客户端一个页面需要展示多个资源，也不要在一个接口中全部返回，而是让客户端分别请求多个接口。 最好将返回数据进行加密和压缩，尤其是压缩在移动应用中还是比较重要的。 分页 在 APP 后端分页设计 中提到过，分页布局一般分为两种，一种是在 Web 端比较常见的有底部分页栏的电梯式分页，另一种是在 APP 中比较常见的上拉加载更多的流式分页。这两种分页的 API 到底该如何设计呢？ 电梯式分页需要提供 （页数）和 （每页的数量）。例如： 而服务端则需要额外返回 （总记录数），以及可选的当前页数、每页的数量（这两个与客户端提交的相同）、总页数、是否有下一页、是否有上一页（这三个都可以通过总记录数计算出）。例如： 流式布局也完全可以使用这种方式，并且不需要查询总记录数（好处是减少一次数据库操作，坏处时客户端需要多请求一次才能判断是否到最后一页）。但是会出现数据重复和缺失的情况，所以更推荐使用游标分页。 游标分页需要提供 (下一页的起点游标) 和 (数量) 参数。例如： 如果文章列表默认是以创建时间为倒序排列的，那么 就是当前列表最后一条的创建时间（第一页为当前时间）。 服务端需要返回的数据也很简单，只需要以此游标为起点的总记录数和下一个起点游标就可以了。例如： 如果 小于 ，就说明已经没有数据了。 流式布局的分页 API 还有一种情况很常见，就是下拉刷新的增量更新。它的业务逻辑正好和游标分页相反，但是参数基本一样： 返回数据有两种可能，一种是增量更新的数据小于指定的数量，就直接将全部数据返回（这个数量可以设置的相对大一些），客户端会将这些增量更新的数据添加在已有列表的顶部。但是如果增量更新的数据要大于指定的数量，就会只返回最新的 n 条数据作为第一页，这时候客户端需要清空之前的列表。例如： 如果 大于 ，说明增量的数据太多所以只返回了第一页，需要清空旧的列表。 "],["小莫的日本换驾照攻略","2019年05月05日","/2019/nihonnmennkyo/","虽然没有100%确定要在日本定居，但是也不能像咸鱼一样度日。而且日本的驾照可以作为身份证明使用（有些日企在填资料时有一项是填：是否有驾照），所以便有准备考驾照，当然以后自驾游啥的也是很方便。在准备考试的过程中经过多方了解和调查获取了许多相关知识，所以准备以blog的形式记录下来。一是把内容整理出来方便自己更好的通过考试，也可以方便在日本想要换驾照的朋友提供个参照。（本篇文章历时2周，花费时间5个小时左右） 换驾照和住所有关 因为我住在琦玉，所以换驾照是去 警察署，具体移步琦玉警察署 ，还有一种不需要和住所绑定，也就是报一个华人驾校，费用在3-4万左右。由于我准备硬刚，所以没有做这种方式的相关攻略，我同事选的这个方式目前己拿到驾照。如果万一对自己没有信心的话可以找个技能学习中心学几节课，费用在2万左右。不管怎么说换驾照都比直接考要便宜，我有个朋友10连休去学的驾照花了20多万，12天拿到驾照。 注意事项 资料审核时间是工作日的早上9:30-10:30,和下午的1:30-2:00，各半小时（政府单位就是这么任性）。如果要当天考视力和笔试必须得上午去，下午1点钟考。 在国内拿到驾照之后需要待满3个月以上才能过来换。 如果日语不好需要有人陪同，会问一些简单的情况。 如果戴眼镜的话会被做标记限制只能戴眼镜开车，很在意这个测视力的时候可以戴隐形假装自己不近视。（看的别人的攻略，个人觉得没必要这样弄虚作假） 考试内容的话概括是视力测试;10道题的理论测试，7道以上合格;类似国内科二跑一圈。扣分制，70分以下考官会叫停。 日本是右舵，跟国内相反。不过看到这个攻略的人应该都知道这个情况。 台湾护照可以不经过考试直接换日本驾照。 费用 报名费 2550　（意味着挂几次就要出几次2550） 领取驾照 2050 （工本费，考过后出一次） 需要的资料 在留卡原件 护照。用来确认在居留期限及出入国境的记录。 1寸照片（3X2.4），两张或以上。日本的车站里的写真机器或者便利店里的打印机都可以弄。 登录所有信息的住民票 中国驾驶证。（原件。JAF及各县交通局会拿去复印。需要在取证之后的3个月内没有出中国的记录。） JAF（Japan Automobile Federation日本汽车联盟）翻译件，可以去JAF窗口也可以邮寄。费用 3500，具体请移步JAF 国内的成绩单和个人信息表，不需要翻译件 中文PDF说明文件 外国驾照更换日本驾照 考试经过 坐电梯上2楼右转再右转，到 门口排队，等待资料审核。会问一些国内考驾照的细节，需要有一定的日语基础。（不会日语需要自带翻译） 下午1点前到1楼大厅左侧3-4号排队检查视力，然后考10道理论题，7道以上合格。（正常人都能通过） 通过之后就会被带到场地上车考试，场地有很多小牌子，考官会提前发出指令。对牌子的位置不熟的话很快就会挂掉！！！参考 我在考到一半的时候被叫停挂掉，最大原因就是对场地不熟悉（毕竟没练过），开车的时候不停的在找牌子就这样挂掉了，预约在半个月后（6/24）再次考试。 参考考试结果觉得不练一下还是比较难考过，果断找了一家驾校准备去练几节课。 练车心得 2019/6/10去驾校练车，由于平日练车的人不多所以直接一次性练了3节课（ ），练车后觉得还是挺有帮助的。 上车前：从副驾侧绕到车头中间后退3步蹲下看车底和轮胎，然后从副驾侧绕道车尾后退3步蹲下看车底和轮胎 检查有没有小动物，儿童，或障碍物，有没有漏油，变形，车轮是否回正等。确认无误后，从后面绕到车右侧开门上车。。（不能从车头直接绕到驾驶室） 上车时：先看后方，无人时把车门开一个缝，然后再扭头观察后方。无车情况下打开车门进入驾驶室。坐下后关车门：关车门分两段，先虚掩一下车门，确认不会夹到东西，再用力关上，关上后顺便锁车门！不锁车门会扣分。然后向考官问好：こんにちは，留个好印象。 打火前准备：调节座椅位置，调节车内后视镜（就算合适也要调整，要有这个动作），系上安全带，并告诉考官 シートベルト(seat belt)お願いいたします。如果车轮没有回正的话，把车轮回正。依次摸一下档位和手刹，确认手刹已经拉上，档位在P档，雨刮，灯光拨杆位置都正确。确认的时候可以用手指一个一个点过去做确认状。然后踩着刹车，发动引擎，启动后确认车况和指示灯无异常。 打火后准备：调节左右2个后视镜，如果下雨情况下要打开雨刷。（没打火调不了左右后视镜）准备完之后告诉考官 準備終わりました。 当考官告诉你 出発，回答　はい。然后挂D档，松手刹，打右转灯。依次扭头确认后方，左后视镜，车内后视镜，右后视镜，右侧，扭头看右向方（记住一定要回头！不然会扣分！扣分！分！），没车的情况下松开刹车起步。 进入主道前要停车，依次观察车内后视镜，右方后视镜，右后方，无车情况下方可进入。 过弯道后进入直道要加速至35-40码，进入弯道前减速。 此时考官会说 番：右，到 号附近（提前30米）打右转灯。确认车内后视镜，右方后视镜，右后方。无车开始向右并线，到 再次3点确认后右转到左道上，然后此直道上要加速到35-40码。 此时考官会说 番：右，打右转灯，右方3点确认。可在上一步的基础上贴近右侧线，到 前再次右方3次确认进入 。 此时考官会说 番：右，打右转灯，在路口停车以此确认左后视镜，车内后视镜，右后视镜，右方，然后看着左方没车的时候拐入左侧道路。 此时考官会说 番：左，此时离2号还隔着一个 ，不要急着打灯。正常通过红绿灯后，打左转灯。然后依次左方3点确认后开始向左并线。在2号时停车看右方，右后视镜，车内后视镜，左边后视镜，左前方，然后看下右方没车转向左道。 此时考官会说 番：左，打左转打。左方3点确认，没车的话往左并线。到了 后停车左方3点确认没车的话进入左道，前方直接要加速到35-40码。前方十字路口 ，要降速至10码以下到达路口时要前倾以右左右的顺序确认缓慢通过。 此时考官会说 番：左，打左转灯，左方3点确认，向左并线。到达50号时再次左方3点确认，没车时开始进入 。 此时考官会说 番：右，在路口时要停车看右前方，车内后视镜，左前方，没车时右转到左道。 此时考官会说 番：左，打左转灯，左方3点确认，并线至左边。然后到达 号时 ,不停会挂掉。看右前，车内后视镜，左侧后视镜，扭头看后方。然后看下右方没车的话开始左转。前方有一个路口，减速通过。然后有一个人行道，减速通过。 此时考官会说 番：左，打左转灯。左方3点确认，开始向左并线。到达 号再次3点确认，没车时开始左转。前人有一个红绿灯，注意看灯。通过后加速到35-40码。 此时考官会说 番：右，打右转打，右方3点确认，并线到右边。到达4号后再次右方3点确认，看下左边没车的话开始进入左道。 此时考官会说 番：右，打右转打，右方3点确认，向右侧并线。同样也要反复左右偏头确认后再进入左侧道路。前方 ，要路口前要减速到10码以下，以右左右的顺序确认缓慢通过。 此时考官会说 番：右，打右转灯，右方3点确认，然后向右侧并线。到达10号再次右方3点确认，并进入左道。此时加速至40-50， 前方有 ，还有50米左右时打右转灯，然后右方3点确认，打30度方向盘加速进入右道，车子摆正后打左转灯，到达障碍物时左方3点确认，没车时打30度方向盘并入左侧。前方过弯道后打左转灯，左方3点确认。没车时进入左道。 此时考官会说 终点停車,减速，打左灯，回头看，贴边，在指定的位置慢慢停住。（左侧30CM以内，左前方铁栏杆50CM以内）。 先拉手刹（不用按），然后挂P档。如果雨刷打开着的话要向前推关掉雨刷，熄火。把座椅推到最后，然后解掉安全带。把车门打开一个缝，观察后方安全推开车门，一只脚踏出去后告诉考官 終わりました。 从车的后方绕到考官的左侧车窗，听候发落。。 车开到终点，考官会根据你的表现告诉你及不及格，合格的话归还号码牌，不合格的话会还你申请资料。有时候考官会问你两句，比如说你之前练了多久的车，在哪个驾校练的，这是第几次考试了之类的，有时候结果介于及格和不及格之间的话，回答没怎么练过，或者驾校的名声比较臭的话容易给不及格。不及格的话一般考官会告诉你扣分点在哪里，你是怎么错的，不过一般也就说一两个地方，如果错的比较多的话考官不会全部都告诉你，但是如果教官完全没说的话你可以开口问，考官是有义务告知你的，问的话不会不说。等说完之后就按照指示去约下一次的考试。及格的话，去换证窗口办手续，按照指示等两三个小时，就可以领到驾照了。最后祝换证的朋友们都能一切顺利！ 注意事项 打方向盘不要太急，不稳会扣分。 打方向盘一次不要太多，回盘一次扣5分。 止まれ 不停车会被直接踩停挂掉考试;红灯不停会被踩停挂掉考试;逆行会被踩停挂掉考试。 考试前拿着路线图实地进场走一走，再熟悉一遍(11:45~12:45)。 要先打灯后确认，到达目的地点后再次确认方可动盘。 确认的时候要保持方向盘水平且不能动盘。 有树的地方（見通し悪い場所）一定要减速并左右观察确定。 路线一定要熟记，在哪往哪转提前心里要有谱。 友情提示 日本驾照的扣分是：每个月有3分。各种违章，按轻重扣分不同。比如15号，你的3分扣完了，那么你这个月就不能再开车了。但下个月自动还是有3分的。 开车的时候，一定不要喝酒，一口都不行，因为你考回来的驾照会被吊销！另外，安全带，上车后必须系上！必须！包括副驾驶的！如果副驾驶没有系安全带，警察看到后，司机的驾照仍旧会被扣分。 普通道路的时候，可以稍微超速，80km/h的限速，开到120km/h的也大有人在，只是有被扣分罚钱的危险。 最后配一张琦玉考试的平面路线图 更加真实一点的地图 2019/08/20 更新 在昨天，终于拿到了驾照，不负这段付出的时光，希望每个努力的人都有一个好结果。 参考资料 中国驾照转日本驾照超详细攻略！ 东京换驾照记 日本留学 ｜ 如何在日本换驾照 YMG教你中国驾照如何换日本驾照 "],["2018年终总结（从杭州到日本工作的心路历程）","2018年12月12日","/2018/summary/","这篇内容实际产出时间己经是2019年的3月了，但由于事情比较多就把18年的总结给补上。来日本也差不多有2个月啦，这2个月时间也一直没有更新博客,本来是在元旦就应该开始写的，但是一直拖到了现在。主要是因为换了新环境很多事情需要做，很多地方需要适应，所以没时间也没法静下心来写写博客记录一下生活。现在终于有时间坐下来记录一下在日本的生活日常。 我为什么要来日本 大学的时候一直对动漫特别感觉趣，毕业后在杭州偶然接触到对日的软件开发，开始萌发了学日语的想法。后来看动漫的量越来越多，听力也慢慢好起来，开始有了到日本看一看的念头，但是因为能力受限一直没有到日本，但是在2015年~2018年期间有断断续续的背日语单词。17年国庆节的时候和老婆一起来日本自由行12天，亲眼见证了日本的自然和人文，便把到日本工作作为自己的下一个计划。大家应该都知道2018年是互联网很不好的一年，裁员风暴一波又一波，但是我的前公司并没有因此裁员反而吸收了大量被裁员的人。我15年进那家公司的时候不到60人，我18年离职的时候己经快1000人了，我亲眼见证了这家公司的飞速成长。但是为我什么离职呢，我在这家公司3年了也想换换新的环境，但是国内的环境不好自己带的那个项目表现不是很好又经常通宵加班所以趁此机会开始找日本的工作机会。从6月份开始通过猎头远程面试到7月份确定工作，然后就是各种证件EMS给公司办在留资格证。 我来日本多久了 2018年8月份开始申请在留，2019年11月拿到手，但是很快到日本的新年了。所以我在农历的腊月中旬（2019.1.16）来到日本东京，2019年在日本度过了的第一个中国新年，正好今年东京塔在春节当晚亮起了中国红，刷爆了朋友圈,突然也有了一点恋家的感觉。我老家在非常偏僻的农村，后来了为读书我们搬到了镇上。考上了县城高中然后在县城买了房子。到后来读大学，去了武汉。毕业后和朋友一起到杭州谋生。现在都各自成家立业，朋友正在注册着属于自己的公司，而我飘扬过海来到日本工作。我一直不信星座，但是作为射手座的我，星座解释说射手座向往自由和远方，这一点我倒是深信不疑,从一个小村庄到出国，是射手座给我的勇气。截至到目前为止，我在日本待了大概有2个月，可能还会待很多个两个月。今年天皇退位,所以黄金周放10天假可以回杭州休息一段时间了。 在日本住的房子是什么样的 公司提供了3种方案：1、住公司宿舍——价格最便宜，也最省心，但是环境不是很好，地方也比较小。 2、在公司合租的中介那边自租房间——个人感觉价格比较贵，而且有朋友在日本工作，问我愿不愿意合租。 3、自理——我选择了自己搞定，在日本和朋友合租了UR团地，9万一个月，总面积54平，3DK。在房子上没有走很多才来日本的朋友的坑，这一点比较省心。但是由于住的地方比较远，所以上班时间得花1个多小时。不过和北上广比较来，也差不了太多。既然选择在大城市，就得有这个觉悟。 在日本做什么样的工作 我是2019年1月17号到达日本，来了之后公司催着去上班（我还以为是2.1号开始）。所以在17号当天急急忙忙办了各种手续。包括住民登记、办手机卡、办银行卡、去公司签协议等等。于是，在2019年2月18号，我正式开始了在日本的第一天社畜生活。我是在 在日华人在日本开的公司，属于派遣形式。第一个现场是在浦田，公司名字是日立制作所，我对日立印象最深的就是中国很多电梯都是三菱和日立的品牌。做的工作内容并没有什么技术性，短暂的做了一些测试的工作，在这期间我开始疯狂的记单词，没有工作任务的时候就记。好在这个现场的工作时间不长，2019年2月底就结束了，所以我开始面试新的项目，从3.1号开始到下个现场上班。说实话，因为自己日语口语太差，加上基本上没有对日开发经验，所以一度非常受挫。第一个面试的项目是在SoftBank，第二个是日本NSD,第三个是ricoh(理光)。第三个面上了，我特意去了解了一下是个世界500强的公司，还算是不错。工作内容是使用Angular6做网站开发，因为我经常不务正业研究一些乱七八糟的技术，包括但不限于Angular,React之类。在面试的时候虽然口语表达的不好，但是把自己Angular会的部分展示出来成功的获得了工作机会。还有最后2天就要开始做这个项目了，希望会是一个开心的过程。 在日本的通讯方式 来日本的第一天匆匆忙忙办了一张Y！Mobile的手机卡，一个月2000日元，3GB流量。由于考虑手机用的比较久，电池不耐用，32G内存也不够用等等花了8万日元入手了一台256G的iphoneXR，办了一个SoftBank的卡，因为室友也用的SoftBank的卡，所以每个月还可以额外优惠1000日元。 在日本吃什么 首先，我出生在内陆，很少吃海鲜，偶尔吃虾和鱼。来了日本之后看到鱼特别便宜但是却没有想吃的欲望觉得还是挺浪费的。正所谓入乡随俗，所以我也开始尝试一些日本料理，但是吃了一次生鱼片我确实还没法习惯。再加上店里吃饭比较贵，我一般都是自己做饭吃，带便当去现场中午吃。住的地方超市、便利店、物产店都很方便，想吃什么基本上都能买到。 打算在日本待多久 目前来说还没有确定，只能说走一步看一步。刚来日本各种东西不熟悉、语言不通、环境不适应等等各种因素我也打过退堂鼓，但是觉得自己努力了这么久才来了不到2个月，还得需要更多的时间去适应。 日本的工作加班吗 做IT行业我说不加班你会信吗？ 你肯定会说：我信你鬼哟，你个糟老头子坏的很！ 确实，IT行业不需要和人打交道，有内容一直都可以做。但是日本确定很少加班，日本和中国不一样，日本是按照出勤时间算。比如说一天上班8小时，一个月上20天。所以日本普遍月出勤时间在150-160之间。到了下班时间还在公司墨迹领导会催着回去，而且有些公司规定周三、周五强制6点离场。在现在这个现场我偶尔也有加班，但是最晚是到8点钟，这样的话我出勤时间就有10个小时。我之后如果有事情要办，可以调休去办自己的事情，只要总工时达到了规定时间就能发全工资，所以我觉得这一点还是比较人性化。 日本的社保 日本有社保和厚生年金，年金和国内的一金非常类似，自己的公司各负担一半。社保可以不交，但是国民健康保险最好交一下，我现在每个月是2700日元。日本纳税是按照上一年度纳税，我第一年来日本所以比较低，明年的话可能一个月要交8000左右的保险金。这个国民健康保险看病自己只用负担30%，家人也可以用，小孩子是全免费的。有些不分大人小孩可吃的药医生出会多开一些剂量，不用出钱大人也可以用，比如说日本人春天物别容易犯的花粉症的抗过敏药。我到现在为止拿到了国民健康保险卡，这个月也刚交了2700的保险金，但是没有到医院去过，所以具体什么样子得等以后再实践。 日本IT行业的那些规矩 在日本做IT没有灵活可言，要用什么工具，什么版本基本上都是定好的，给什么用什么。有问题一定要及时和上级沟通，上级会很认真的帮忙解决，自己想当然做到最后出问题会很严重，一直出错最终会失去领导的信任。在工位上可以玩手机，可以充电啥的，但是绝对不要把USB插到电脑上，也不要在办公室拍照。日本人上班工作喝水基本上都是在自动贩卖机上买各种饮料或矿泉水，目前只有我一个人会抱着个大大的保温杯去接开水喝，而且日本人食量很小，我每天中午都吃的是我们领导的2倍多，才开始还觉得有点羞耻，后来脸厚了也就无畏无惧了。我现在工作的地方允许在工位上吃饭，可能有些地方会不让。 在日本的中国人可信吗 来日本之前看过很多文章说中国人坑中国人，首先我觉得比较丢脸，因为我也是中国人，但是我觉得事实上并没有说的那么严重。至少我来日本遇到的中国人都还是挺好的，包括我现在公司的社长、公司营业、办手机卡的中国营业员、项目组的中国人，感觉都还挺好的。目前没有出现被坑的情况，也希望以后不要遇到，不要让我也觉得国人坑国人是那么普遍。 日本的卫生间 可能有朋友有觉得我把这个单独提出来是不是有点变态，其实我觉得是有些可以拿出来说的。首先，日本的卫生间干净的让人觉得十分舒服，完全没有味道。每个水龙头都有热水，旁边摆的洗手液永远都不会成空瓶子。有风干机，有镜子，每个马桶边上的纸从来不会空。总之，这些小细节真的是让人非常喜欢。 办公室工作结构 我目前所在的项目是6个人，4个中国人和2个日本人。为了练日语，我会经常厚脸皮的和其中一个日本人发消息聊天，在没有工作内容的时候经常会一聊 聊半天时间。从开始打字都不知道打什么，到现在能长篇大论，从吃的谈到用的，从家庭谈到工作。我觉得我进步还是挺大的，但是目标最弱的还是口语，所以在接下来的时候我会努力的去读去练发声。 非工作时间我一般在做什么 来日本一个多月了，除了上班我感觉别的事情我真的什么都没做，但是总觉得时间一晃就非常晚了。一般来说，花1个多小时回家，再花1个小时做饭吃饭，再玩玩电脑玩玩手机不知不觉都己经过了12点。从高中开始一直对钢琴比较有兴趣，所以买了雅马哈的电钢琴但是也没什么时间练，但是它也是我以后其中计划的一环，总有一天我会流利的弹出我喜欢的钢琴曲。周六固定在日本政府办的免费日语教室上课，然后和朋友一起吃个晚饭。周末做家里蹲一睡一整天，其实我觉得这样很不好，这个我会尽量改掉。我一直计划想去海边去玩，但是因为温度比较低一直没有去，等天气暖和一点了去海边玩。在国内的时候玩着来日本了一有时间我就要出去各种浪，但是真正来了日本快2个月了一直没有出去玩过真是汗颜。 日本的电车 日本的电车非常准时，我仔细注意过，我只要早上固定在某个时间点从家里出来，一定是在某个时间点到达公司。只有一次电车延迟了半个多小时，原因好像是我坐的这条线正好遇到了人身事故。日本的电车非常安静，日本人在电车上很喜欢看书。电车上明文规定手机保持震动，不要在车上打电话，所以车上非常安静。能听到别人说的悄悄话和翻书的声音。电车上有2个固定的显示屏，一个放广告一个放实时站点信息。不想看广告的话完全不会被打扰，屏幕上会有当天的天气预报。每个电车基本上都设置有3节女性车厢，早晚高峰最好不要坐，不然有可能会被白眼，其实这倒没什么，万一遇到蛮不讲理的女性非要说是痴汉会很伤脑筋。东京早晚高峰电车非常拥挤，这也是为什么男性要尽量避免女性专用车厢。但是平时的话很容易遇到座位，因为有很多日本人都不坐。据说是他们觉得会有比自己更需要座位的人，所以不是特别累就会站着，反正我是奉行有位置不坐是王八的バカ。 日本的电梯文化 我工作的现场有8个电梯，在两边都排着整齐的队伍。有电梯下来依次乘坐，坐不下的会退回来等下一部电梯。站的太满的时候靠近门的那部分人会先出来等别人都出来了再上去，电梯按钮边上的人也会帮忙一直把开的按钮一直按着，不会像国内站在里面想出来只能使劲挤出来。在坐电梯的时候如果门快关了有快速跑过来按开电梯，进来之前会先鞠躬道歉再过来。在按钮边上站着的人会按着开的按钮等所有人都出来了他们再出来，因为我没有这个习惯所以一到目的地楼层我就会先出来，所以心里会有点抱歉。 来日本2个月的感觉 首先从去市役所做住所登录来说，政府人员真的是非常非常有耐心。我听不懂他们说什么的时候，会用非常慢的语速再重复，如果再听不懂会用笔写下来。还是不懂的话我会打电话给日语好的朋友让我朋友帮我说，不管花多长时间他们不会显示出不耐烦。据日本的朋友说，我们作为纳税人养活着他们，他们态度好不是理所当然的么。我觉得非常震惊，但是仔细想过又觉得他说的非常有道理。但是日本非常不方便的是办事情只能工作日，周六周日从来不上班。但是工作现场可以调休这一点也正好弥补了这一点不方便。还有非常不方便的地方就是日本的快递不能邮寄到公司，只能邮到家里。但是提前不能指定时间，他们送到之后。人不在家拿不了时，会给一张不在联络票放在邮箱，拿到不在联络票再指定时间。我觉得这真是一个神奇而又变态的设定。在日本总体来说有着非常好的服务态度，不用担心食品安全问题，每天都能看到蓝天，很多细节感人泪人，也不用在意各种墙，写代码因为网络原因出现各种奇怪而又难解决的问题。但是毕竟这不是自己的家乡，会觉得不适应。也会想家人，想老婆，想孩子，也想我家那只蓝猫。 我接下来的计划 在日本工作生活，时间越长越觉得日语不好是多么的不方便。听着别人说一口流利的日语，真的是不要太羡慕。所以接下来首要的任务就是加油学日语，然后报今年7月份的N2。如果N2能考，12月份接着考N1,万一考不过继续考N2。反正不考到N1不罢休。然后就是好好学学技术，技术是自己的饭碗所以这个当然不能丢。计划做一个独立小游戏上线推广。朋友注册了公司，帮忙做一些公司建设方面的内容。N1到手之后开始把时间转移到学英语和钢琴上，然后考一些日本政府认可的技术证书等等（高级人才签证的准备工作）。我一直觉得人活着，过一天就要有新的收获，所以每一天都在不停的学习。达到一个目标后，继续开始新的目标。比如说初中时各个假期学五笔、学PS、学装系统、电脑维修等等，这些都为我以后的工作生活带来了极大的方便 。有的时候和我朋友讲我的经历，他们总会觉得我的经历充满了传奇，非常的羡慕。但是我想说的是，每个人都是一个精彩的传奇，我被别人羡慕着同样也羡慕着别人。我也有特别多让人烦心的事情，也是一个普通的不能再普通的普通人。 不会日语可以来日本工作吗 完全可以，因为众所周知，日本是一个少子化相当严重的国家，而IT行业缺人尤为严重。只要会一点点技术，基本上都不会找不到工作。不过工资不会太高，一般会在25万左右。但是想在日本长期生活，建议尽最大努力提长自己的日语能力。哪怕来了日语才开始记50音图都没关系，但是一直要快点把日语学好，因为这关系到自己的待遇和生活质量。谁都不想出去了只买自己知道的东西，找不到东西不知道怎么给店员说。有人可能会反驳，很多店都有中国店员，甚至有很多日本人也在在学中文。但是在日本这个国家生活，只想靠中文生活是不是有点说不过去。 到日本工作前所做的努力 首先当然是学习日语了，虽然18年我多花费了一些时间在日语的学习上，但是语言这种东西需要长期的接触和锻炼才能够得到较好的提升，因为一直都没有拿到N2证书。 然后是技术方面，个人对技术方面比较有兴趣，平时也花了不少时间在上面所以还是比较有信心的。所以为了巩固基础考了Oracle的java认证 以上 断断续续天马行空的写了些乱七八糟的东西。想看的朋友将就着看，如果有什么问题想了解我没有提到的欢迎留言，我会适当补充内容。 "],["Fps游戏常用功能","2018年12月12日","/2018/unityfpscommonmethod/","镜头拉远拉近，类似狙的镜头缩放；枪口特效；角色的移动和镜头旋转 镜头拉远拉近 在main camera中添加一个脚本 此脚本的功能是可以在编辑器中自定义缩放等级，不设置的话默认是60,40,20共3个等级。当按下鼠标左键的时候缩放等级+1,到了最大缩放等级回到0 fps角色组成部分 player是个空物体，是放角色模型的容器 player/main camera是player的子物体，我们控制player移动时camera跟着一起移动 player/guns 是枪的容器,放所有的枪 player/guns/HandGun是手枪的容器，里面放手枪的模型，枪口 player/guns/handGun/firePoint/fireEffect 是枪口开火特效，默认隐藏，开火时显示 新建一个脚本 挂在 空物体上,当点击鼠标左键时开火显示特效，使用 方法延迟0.3秒隐藏 角色控制 移动,这个方法因为乘了 ，所以它是在 方法中调用的，h或者v要有其一大于0 旋转视野，这个方法只能在 ，如果要放在 中,x、y要乘于 角色控制器脚本 方法 效果 "],["镜头拉远拉近","2018年12月12日","/2018/unityscenefarandnear/","镜头拉远拉近，类似狙的镜头缩放 在场景中创建一个cube,默认fieldOfView为60 在main camera中添加一个脚本 此脚本的功能是可以在编辑器中自定义缩放等级，不设置的话默认是60,40,20共3个等级。当按下鼠标左键的时候缩放等级+1,到了最大缩放等级回到0 效果如下 "],["unity3d小地图","2018年11月11日","/2018/unity3dminimap/","小地图基本是每个RPG游戏都必备的功能，如果连这个都不会做就太不应该了。 新建一个相机， 设置为正交模式（2d） ,size大概为30左右（视地图而定）,把它放在角色的容器中,让它可以和角色一起移动。Rotation绕x旋转90度，放到天上调整到合适位置和距离 新建一个renderTexture,把它给小地图相机 下载miniMap包 导入，新建材质球。shade设置为custom，第一个指定为renderTexture,第二个指定为mask 新建一个RawImage,把renderTexture和材质球给它 在角色容器中添加一个plane，把miniMap包中的icon给它。然后把layer设置为miniMap层。 把角色模型本体设置为Player层，把主相机的culling mask 取消miniMap,小地图摄像机的culling mask取消player层 完成品如下，如果有外框可以给地图加个外框会漂亮一点 "],["使用UGUI中的层级问题——以背包为例","2018年11月11日","/2018/uguisorting/","UGUI的canvas默认层级是UI，Sorting order 是0，由于unity渲染物体时是从上到下直接渲染的，这就导致了渲染出来的效果和我们预期的不一致，因此必须设置层级，指定渲染的先后顺序（层级低的先渲染）才行。 想要实现的效果是有一个背包，背包里有道具，鼠标移上去之后出现一个框显示物品的详细信息，移开就消失。但是默认UI层级会把挡住 解决方案 在被挡住的UI上添加组件 ,增大它的 ，但是坑爹的是：设置完后，层级的问题解决了，但是UI的所有事件被拦截（包括按钮的点击、UI拖拽等等） 给UI再设置一个组件Graphic RayCaster，完美解决，既可以显示特效，还不会遮挡UI。 至此有个问题，如果界面很多都需要设置上述的canvas，那就需要自己实现一个管理类，给每个ui设置它的order，不过canvas会影响合并批次，所以不能有太多，自己权衡。 给Item上挂一个脚本，实现 和 接口，分别对应设置Active属性 最终效果 "],["使用UGUI制作滚动列表-选服列表","2018年11月11日","/2018/uguiserverlist/","UGUI必将千秋万代，一统江湖！（麻烦给UGUI加一下动画系统，谢谢） 想要实现的效果..ummmm，大概是以下这个样子，这是最终做好的样子，记录一下 假设我现在的目录结构是这样子的，canvas下有一个Bg,bg下有一个RegionFrom用来放服务器列表。 在Region下新建一个Image控件ServerList用来做内容呈现的容器，给它添加 和 ,把 的 的勾去掉。 在ServerList下新建一个空物体Content做来做滑动的区域，这个区域的宽度和ServerList一样大，高度设置大一点,添加上GridLayoutGoup组件自动布局，设置好大小和间距。 在Content下添加服务器项目，项目会被自动布局。运行后即可获得gif效果所示。 "],["docker应用","2018年06月06日","/2018/aboutdockeruse/","docker是一个简化部署的容器,使用docker不仅能够降低性能消耗，而且方便部署工作，在互联网企业中使用十分普遍。 功能 解决了运行环境不一致的问题。 docker隔离了运行环境，对同一台服务器上运行的其他应用不会产生任何影响。 docker可伸缩的部署服务减少了资源的浪费和运维的人工成本。 下载地址 https://www.docker.com/get-docker 网易镜像 https://c.163yun.com/hub#/m/home/ docker安装 center os Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。通过 uname -r 命令查看你当前的内核版本 yum安装docker 运行docker 测试 脚本安装docker 更新系统组件 执行 Docker 安装脚本 启动docker 验证 docker 是否安装成功并在容器中执行一个测试的镜像。 docker镜像加速 鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是网易的镜像地址：http://hub-mirror.c.163.com。新版的 Docker 使用 /etc/docker/daemon.json（Linux） 或者 %programdata%\\docker\\config\\daemon.json（Windows） 来配置 Daemon。 请在该配置文件中加入（没有该文件的话，请先建一个）： mac os 一个命令搞定 镜像加速 鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是网易的镜像地址：http://hub-mirror.c.163.com。 在任务栏点击 Docker for mac 应用图标 -\u0026gt; Preferences\u0026hellip; -\u0026gt; Daemon -\u0026gt; Registry mirrors。在列表中填写加速器地址即可。修改完成之后，点击 Apply \u0026amp; Restart 按钮，Docker 就会重启并应用配置的镜像地址了。 docker常用命令 查看应用容器 启动一个容器 查看应用日志 查看应用程序容器的进程 检查应用程序 停止应用容器 移除应用容器 查看镜像列表 获取一个新镜像 查找镜像 构建镜像 设置镜像tag docker学习资源 http://www.runoob.com/docker/docker-command-manual.html "],["jdk源码系列-Java中ArrayList、LinkedList和Vector的联系与区别","2018年06月06日","/2018/jdksourcecodereadarraylistandlinkedarraylist/","毫无疑问，List是一种非常基础的数据结构，翻译过来就是列表。正如它的名字所示，List表示的是一个有序(插入顺序)的元素序列。在Java的集合框架中，List是作为顶级接口Collection的直接子类接口存在，因此，List分支是集合框架中最简单、最常用的分支。 List概述 List分支作为集合框架中最简单、最常用的分支，其在集合框架中的位置可以直接参看下图： 仔细观察和分析此图，你会发现JDK中对于List接口的实现由三种类型：ArrayList、Vector 和 LinkedList。当我们谈论List的时候，我们可以用它与Set来做比较，集合框架中的Set代表一群无序和唯一的元素集合。 仔细观察上图可知，集合框架中的List接口具有多达三个实现类。由继承机制可知，它们在很多方面都是非常相似的，比如有序、用法等。它们之间最大的区别是它们的内部实现方式和细节，不同的实现方式和细节造就了它们之间巨大的性能差异和用法差异。 ArrayList 是Java语言对于动态数组的一个实现。当不断地添加新的元素到ArrayList集合中时，该集合的底层数组的长度就会动态的增长，以便能容纳新添加的元素。至于ArrayList的底层数组长度的动态增长策略，在不同的JDK实现和版本中是不同的，最常见的策略是新增 %50，具体请参看源码。正因为ArrayList的底层实现是数组，其带来的一个特性是：它的元素可以通过 getter(index) 和 setter(index) 方法直接访问，而且性能特别好。 LinkedList 的底层实现是基于 双向队列(double linked list)。熟悉数据结构的读者应该可以猜到：LinkedList 对于新增和删除元素的操作在性能上远远优于 ArrayList。但是，它的缺点在于：其 getter(index) 方法和 setter(index) 方法的性能很差，时间复杂度是 O(n)。 Vector 与 ArrayList 唯一的区别是：它是同步的(synchronized)，线程安全。 性能对比 对于ArrayList，add/remove的时间复杂度是 O(n)；但在尾部操作是 O(1) 。 对于LinkedList，add/remove的时间复杂度是 O(n)；但在尾部和头部操作的是 O(1) 。 性能测试 为了实际测验三种List的add、get和remove的性能，我们可以使用如下的代码片段： 此处只给出测验ArrayList的add操作的代码，但是测验LinkedList和其他操作的代码是类似，读者可自行修改代码进行测验。测验的结果表明： 在add和remove操作时，LinkedList的性能远优于ArrayList。在get操作时，ArrayList的性能优于LinkedList。经过性能对比和性能的测试，我们可以总结出如何在它们之间做出选择。通常使用ArrayList，但是LinkedList在如下场景时更合适： 随机访问集合元素的次数不是很频繁。 对集合有大量的add/remove操作需求。 总结 对比Vector和ArrayList，如果程序本身就是线程安全的，为了更好的性能，应该选择ArrayList。当添加新的元素到集合时，Vector和ArrayList都需要更多的空间来存储新元素，但是它们的增长策略是不一样的：Vector的增长幅度是 100%；ArrayList的增长幅度是 50%。对于LinkdedList而言，其不仅实现了List接口，还实现了Queue接口，这个Queue接口给LinkdedList带来了更多的访问和操作元素的方法，比如 offer(), peek(), poll() 等。 对于ArrayList而言，如果使用不含参数的构造函数新建一个ArrayList对象，该对象的起始大小是比较小的，只有10。我们都知道对象的动态增长导致的底层数组重写分配和复制是一个非常耗时的操作。所以，对于可以预估ArrayList大小的应用场景，应该指定ArrayList对象的初始大小，从而提供性能。 原文地址 Java中ArrayList、LinkedList和Vector的联系与区别 "],["jdk源码系列-String,StringBuffer,StringBuilder","2018年06月06日","/2018/jdksourcecodereadstringdifferent/","String,StringBuilder以及StringBuffer这三个类之间有什么区别? 这三个类之间的区别主要是在两个方面，即运行速度和线程安全这两方面。 首先说运行速度，或者说是执行速度，在这方面运行速度快慢为：StringBuilder \u0026gt; StringBuffer \u0026gt; String String最慢的原因： String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。以下面一段代码为例： 如果运行这段代码会发现先输出“abc”，然后又输出“abcde”，好像是str这个对象被更改了，其实，这只是一种假象罢了，JVM对于这几行代码是这样处理的，首先创建一个String对象str，并把“abc”赋值给str，然后在第三行中，其实JVM又创建了一个新的对象也名为str，然后再把原来的str的值和“de”加起来再赋值给新的str，而原来的str就会被JVM的垃圾回收机制（GC）给回收掉了，所以，str实际上并没有被更改，也就是前面说的String对象一旦创建之后就不可更改了。所以，Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多。另外，有时候我们会这样对字符串进行赋值 这样输出结果也是“abcde”和“abcde”，但是String的速度却比StringBuilder的反应速度要快很多，这是因为第1行中的操作和 是完全一样的，所以会很快，而如果写成下面这种形式 那么JVM就会像上面说的那样，不断的创建、回收对象来进行这个操作了。速度就会很慢。 再来说线程安全 在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的 如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。 总结一下 String：适用于少量的字符串操作的情况 StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况 StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况 原文地址 Java中的String，StringBuilder，StringBuffer三者的区别 "],["jdk源码系列-创建对象","2018年06月06日","/2018/jdksourcecodereadcreateobject/","到底创建了几个对象？相信大家对这此并不陌生，答案也是众所周知的，2个。接下来我们就从这道题展开，一起回顾一下与创建String对象相关的一些JAVA知识。 我们可以把上面这行代码分成String str、=、\u0026ldquo;abc\u0026quot;和new String()四部分来看待。String str只是定义了一个名为str的String类型的变量，因此它并没有创建对象；=是对变量str进行初始化，将某个对象的引用（或者叫句柄）赋值给它，显然也没有创建对象；现在只剩下new String(\u0026ldquo;abc\u0026rdquo;)了。那么，new String(\u0026ldquo;abc\u0026rdquo;)为什么又能被看成\u0026quot;abc\u0026quot;和new String()呢？我们来看一下被我们调用了的String的构造器： 大家都知道，我们常用的创建一个类的实例（对象）的方法有以下两种： 使用new创建对象。 调用Class类的newInstance方法，利用反射机制创建对象。 我们正是使用new调用了String类的上面那个构造器方法创建了一个对象，并将它的引用赋值给了str变量。同时我们注意到，被调用的构造器方法接受的参数也是一个String对象，这个对象正是\u0026quot;abc\u0026rdquo;。由此我们又要引入另外一种创建String对象的方式的讨论——引号内包含文本。这种方式是String特有的，并且它与new的方式存在很大区别 毫无疑问，这行代码创建了一个String对象。 那这里呢？答案还是一个。 再看看这里呢？答案仍是一个。有点奇怪吗？说到这里，我们就需要引入对字符串池相关知识的回顾了。 在JAVA虚拟机（JVM）中存在着一个字符串池，其中保存着很多String对象，并且可以被共享使用，因此它提高了效率。由于String类是final的，它的值一经创建就不可改变，因此我们不用担心String对象共享而带来程序的混乱。字符串池由String类维护，我们可以调用intern()方法来访问字符串池。我们再回头看看String a=\u0026ldquo;abc\u0026rdquo;;，这行代码被执行的时候，JAVA虚拟机首先在字符串池中查找是否已经存在了值为\u0026quot;abc\u0026quot;的这么一个对象，它的判断依据是String类equals(Object obj)方法的返回值。如果有，则不再创建新的对象，直接返回已存在对象的引用；如果没有，则先创建这个对象，然后把它加入到字符串池中，再将它的引用返回。因此，我们不难理解前面三个例子中头两个例子为什么是这个答案了。 对于第三个例子： String a=\u0026ldquo;ab\u0026rdquo;+\u0026ldquo;cd\u0026rdquo;; 由于常量的值在编译的时候就被确定了。在这里，\u0026ldquo;ab\u0026quot;和\u0026quot;cd\u0026quot;都是常量，因此变量a的值在编译时就可以确定。 这行代码编译后的效果等同于： String a=\u0026ldquo;abcd\u0026rdquo;; 因此这里只创建了一个对象\u0026quot;abcd\u0026rdquo;，并且它被保存在字符串池里了。现在问题又来了，是不是所有经过“+”连接后得到的字符串都会被添加到字符串池中呢？我们都知道“==” 可以用来比较两个变量，它有以下两种情况： 如果比较的是两个基本类型（char，byte，short，int，long，float，double，boolean），则是判断它们的值是否相等。 如果表较的是两个对象变量，则是判断它们的引用是否指向同一个对象。 下面我们就用“==”来做几个测试。为了便于说明，我们把指向字符串池中已经存在的对象也视为该对象被加入了字符串池： 运行结果如下： String a = \u0026ldquo;ab\u0026rdquo;; String b = \u0026ldquo;cd\u0026rdquo;; \u0026ldquo;ab\u0026rdquo;+\u0026ldquo;cd\u0026rdquo; 创建的对象 \u0026ldquo;加入了\u0026rdquo; 字符串池中 a +\u0026ldquo;cd\u0026rdquo; 创建的对象 \u0026ldquo;没加入\u0026rdquo; 字符串池中 \u0026ldquo;ab\u0026rdquo;+ b 创建的对象 \u0026ldquo;没加入\u0026rdquo; 字符串池中 a + b 创建的对象 \u0026ldquo;没加入\u0026rdquo; 字符串池中 从上面的结果中我们不难看出，只有使用引号包含文本的方式创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中。对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中，对此我们不再赘述 但是有一种情况需要引起我们的注意。请看下面的代码： 这段代码的运行结果如下： s等于t，它们是同一个对象 这又是为什么呢？原因是这样的，对于常量来讲，它的值是固定的，因此在编译期就能被确定了，而变量的值只有到运行时才能被确定，因为这个变量可以被不同的方法调用，从而可能引起值的改变。在上面的例子中，A和B都是常量，值是固定的，因此s的值也是固定的，它在类被编译时就已经确定了。也就是说： 等同于 我对上面的例子稍加改变看看会出现什么情况： 它的运行结果是这样： s不等于t，它们不是同一个对象 只是做了一点改动，结果就和刚刚的例子恰好相反。我们再来分析一下。A和B虽然被定义为常量（只能被赋值一次），但是它们都没有马上被赋值。在运算出s的值之前，他们何时被赋值，以及被赋予什么样的值，都是个变数。因此A和B在被赋值之前，性质类似于一个变量。那么s就不能在编译期被确定，而只能在运行时被创建了。由于字符串池中对象的共享能够带来效率的提高，因此我们提倡大家用引号包含文本的方式来创建String对象，实际上这也是我们在编程中常采用的。 接下来我们再来看看intern()方法，它的定义如下： 这是一个本地方法。在调用这个方法时，JAVA虚拟机首先检查字符串池中是否已经存在与该对象值相等对象存在，如果有则返回字符串池中对象的引用；如果没有，则先在字符串池中创建一个相同值的String对象，然后再将它的引用返回。 我们来看这段代码： 运行结果： b没被加入字符串池中，新建了对象。如果String类的intern()方法在没有找到相同值的对象时，是把当前对象加入字符串池中，然后返回它的引用的话，那么b和a指向的就是同一个对象；否则b指向的对象就是JAVA虚拟机在字符串池中新建的，只是它的值与a相同罢了。上面这段代码的运行结果恰恰印证了这一点。最后我们再来说说String对象在JAVA虚拟机（JVM）中的存储，以及字符串池与堆（heap）和栈（stack）的关系。我们首先回顾一下堆和栈的区别： • 栈（stack）：主要保存基本类型（或者叫内置类型）（char、byte、short、int、long、float、double、boolean）和对象的引用，数据可以共享，速度仅次于寄存器（register），快于堆。 • 堆（heap）：用于存储对象。 我们查看String类的源码就会发现，它有一个value属性，保存着String对象的值，类型是char[]，这也正说明了字符串就是字符的序列。当执行String a=\u0026ldquo;abc\u0026rdquo;;时，JAVA虚拟机会在栈中创建三个char型的值\u0026rsquo;a\u0026rsquo;、\u0026lsquo;b\u0026rsquo;和\u0026rsquo;c\u0026rsquo;，然后在堆中创建一个String对象，它的值（value）是刚才在栈中创建的三个char型值组成的数组{\u0026lsquo;a\u0026rsquo;,\u0026lsquo;b\u0026rsquo;,\u0026lsquo;c\u0026rsquo;}，最后这个新创建的String对象会被添加到字符串池中。如果我们接着执行String b=new String(\u0026ldquo;abc\u0026rdquo;);代码，由于\u0026quot;abc\u0026quot;已经被创建并保存于字符串池中，因此JAVA虚拟机只会在堆中新创建一个String对象，但是它的值（value）是共享前一行代码执行时在栈中创建的三个char型值值\u0026rsquo;a\u0026rsquo;、\u0026lsquo;b\u0026rsquo;和\u0026rsquo;c\u0026rsquo;。说到这里，我们对于篇首提出的String str=new String(\u0026ldquo;abc\u0026rdquo;)为什么是创建了两个对象这个问题就已经相当明了了 注 转载自 臧圩人 http://zangweiren.javaeye.com "],["jdk源码系列-类的初始化顺序","2018年06月06日","/2018/jdksourcecodereadclassinitorder/","大家在去参加面试的时候，经常会遇到这样的考题：给你两个类的代码，它们之间是继承的关系，每个类里只有构造器方法和一些变量，构造器里可能还有一段代码对变量值进行了某种运算，另外还有一些将变量值输出到控制台的代码，然后让我们判断输出的结果。这实际上是在考查我们对于继承情况下类的初始化顺序的了解 我们大家都知道，对于静态变量、静态初始化块、变量、初始化块、构造器，它们的初始化顺序依次是（静态变量、静态初始化块）\u0026gt;（变量、初始化块）\u0026gt;构造器。我们也可以通过下面的测试代码来验证这一点： 运行以上代码，我们会得到如下的输出结果： 静态变量 静态初始化块 变量 初始化块 构造器 这与上文中说的完全符合。那么对于继承情况下又会怎样呢？我们仍然以一段测试代码来获取最终结果: 运行一下上面的代码，结果马上呈现在我们的眼前： 父类\u0026ndash;静态变量 父类\u0026ndash;静态初始化块 子类\u0026ndash;静态变量 子类\u0026ndash;静态初始化块 父类\u0026ndash;变量 父类\u0026ndash;初始化块 父类\u0026ndash;构造器 子类\u0026ndash;变量 子类\u0026ndash;初始化块 子类\u0026ndash;构造器 现在，结果已经不言自明了。大家可能会注意到一点，那就是，并不是父类完全初始化完毕后才进行子类的初始化，实际上子类的静态变量和静态初始化块的初始化是在父类的变量、初始化块和构造器初始化之前就完成了。 那么对于静态变量和静态初始化块之间、变量和初始化块之间的先后顺序又是怎样呢？是否静态变量总是先于静态初始化块，变量总是先于初始化块就被初始化了呢？实际上这取决于它们在类中出现的先后顺序。我们以静态变量和静态初始化块为例来进行说明。 同样，我们还是写一个类来进行测试： 运行上面的代码，会得到如下的结果： Test\u0026ndash;A 静态初始化块 Test\u0026ndash;B 大家可以随意改变变量a、变量b以及静态初始化块的前后位置，就会发现输出结果随着它们在类中出现的前后顺序而改变，这就说明静态变量和静态初始化块是依照他们在类中的定义顺序进行初始化的。同样，变量和初始化块也遵循这个规律。了解了继承情况下类的初始化顺序之后，如何判断最终输出结果就迎刃而解了 注 转载自 臧圩人 http://zangweiren.javaeye.com "],["jdk源码系列-AtomicInteger","2018年06月06日","/2018/jdksourcecodereadatomicinteger/","JDK 里面提供的以 Atomic* 开头的类基本原理都是一致的， 都是借助了底层硬件级别的 Lock 来实现原子操作的。 本文以 AtomicInteger 为例进行讲述， 其他的类似。阅读本文前建议先阅读基础篇：Java内存模型 处理器原子操作： 3种加锁方式 关于 CPU 的锁有如下 3 种： 处理器自动保证基本内存操作的原子性 首先处理器会自动保证基本的内存操作的原子性。 处理器保证从系统内存当中读取或者写入一个字节是原子的， 意思是当一个处理器读取一个字节时， 其他处理器不能访问这个字节的内存地址。 奔腾 6 和最新的处理器能自动保证单处理器对同一个缓存行里进行 16/32/64 位的操作是原子的， 但是复杂的内存操作处理器不能自动保证其原子性， 比如跨总线宽度， 跨多个缓存行， 跨页表的访问。 但是处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。 使用总线锁保证原子性（开销大） 如果多个处理器同时对共享变量进行读改写（i++ 就是经典的读改写操作）操作， 那么共享变量就会被多个处理器同时进行操作， 这样读改写操作就不是原子的， 操作完之后共享变量的值会和期望的不一致， 举个例子：如果 i=1,我们进行两次 i++ 操作，我们期望的结果是 3，但是有可能结果是 2 。如下图 原因是有可能多个处理器同时从各自的缓存中读取变量i， 分别进行加一操作， 然后分别写入系统内存当中。 那么想要保证读改写共享变量的操作是原子的， 就必须保证 CPU1 读改写共享变量的时候，CPU2 不能操作缓存了该共享变量内存地址的缓存。 处理器使用总线锁就是来解决这个问题的。 所谓总线锁就是使用处理器提供的一个 LOCK＃ 信号，当一个处理器在总线上输出此信号时， 其他处理器的请求将被阻塞住, 那么该处理器可以独占使用共享内存。 用缓存锁保证原子性 频繁使用的内存会缓存在处理器的 L1，L2 和 L3 高速缓存里， 那么原子操作就可以直接在处理器内部缓存中进行， 并不需要声明总线锁， 在奔腾 6 和最近的处理器中可以使用“缓存锁定”的方式来实现复杂的原子性。所谓“缓存锁定”就是如果缓存在处理器缓存行中内存区域在 LOCK 操作期间被锁定，当它执行锁操作回写内存时，处理器不在总线上声言 LOCK＃ 信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时会起缓存行无效，在上图中，当 CPU1 修改缓存行中的 i 时使用缓存锁定，那么 CPU2 就不能同时修改缓存了 i 的缓存行， 在 CPU1 更新后， CPU2 去主存拿最新值， 从而保证了数据的一致性。 但是有两种情况下处理器不会使用缓存锁定。第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line），则处理器会调用总线锁定。第二种情况是：有些处理器不支持缓存锁定。对于 Inter486 和奔腾处理器,就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。 以上两个机制我们可以通过 Inter 处理器提供了很多 LOCK 前缀的指令来实现。比如位测试和修改指令BTS，BTR，BTC，交换指令 XADD，CMPXCHG 和其他一些操作数和逻辑指令，比如 ADD（加），OR（或）等，被这些指令操作的内存区域就会加锁，导致其他处理器不能同时访问它。 AtomicInteger 源码如何实现原子性 类声明： 继承了 Number， 这主要是提供方法将数值转化为 byte, double 等方便 Java 开发者使用； 实现了 Serializable， 为了网络传输等的序列化用， 编码时最好手动生成序列化 ID， 让 javac 编译器生成开销大， 而且可能造成意想不到的状况。 变量声明： 原始类型变量声明为 private 的， 这样不会发生外部修改问题（逃逸）， 如果是引用的话， 再把引用用 public 方法暴露出去那么还是会造成逃逸现象， 不过这里是原始类型， 不会出现这种情况； volatile 关键字修饰， 使 value 变量的改变具有可见性， 底层实现是内存栅栏，保证每次取到的是最新值。 get 方法： final 类型方法， 不可继承， 进一步保证线程安全。 自减操作： 可以看到 for 是一个死循环， 是采用忙等（也叫自旋）的方式不断地尝试（乐观锁）－1 操作， 直到成功才退出。 这里的核心是调用了 compareAndSet() 方法， 传入当前值和新值。 利用 JNI 调用底层其他语言实现的方法， 利用操作系统提供的 CAS（只要当前值和原来不一致就重新取值直到成功） 来保证原子性。 CAS 的缺点 基本上 Java 的 concurrent 包都是建立在 CAS 的基础上的， 甚至还包括业界一个很出名的应用于高频交易的框架 Disruptor 也是利用 CAS 来保证原子性。 但是 CAS 还是有它的缺点： ABA问题。因为 CAS 需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。 从Java1.5开始JDK的atomic包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。这个类的compareAndSet 方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。 循环时间长开销大。自旋 CAS 如果长时间不成功，会给 CPU 带来非常大的执行开销。如果JVM能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation：内存顺序冲突一般是由伪/假共享引起，假共享是指多个 CPU 同时修改同一个缓存行的不同部分而引起其中一个CPU的操作无效，当出现这个内存顺序冲突时，CPU必须清空流水线）而引起 CPU 流水线被清空（CPU pipeline flush），从而提高 CPU 的执行效率。 只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。 鸣谢 wenniuwuren "],["jdk源码系列-ConcurrentHashMap","2018年06月06日","/2018/jdksourcecodereadconcurrenthashmap/","ConcurrentHashMap 是将锁的范围细化来实现高效并发的。 基本策略是将数据结构分为一个一个 Segment（每一个都是一个并发可读的 hash table， 即分段锁）作为一个并发单元。 为了减少开销， 除了一处 Segment 是在构造器初始化的， 其他都延迟初始化（详见 ensureSegment）。 并使用 volatile 关键字来保证 Segment 延迟初始化的可见性问题。 HashMap 不是线程安全的， 故多线程情况下会出现 infinit loop。 HashTable 是线程安全的， 但是是用全局锁来保障， 效率很低。 所以 Doug Lea 并发专家研发了高效并发的 ConcurrentHashMap 来应对并发情况下的情景。 阅读本文前最好先看： Java内存模型 和 AtomicInteger 分析 。 术语定义 哈希算法 是一种将任意内容的输入转换成相同长度输出的加密方式，其输出被称为哈希值。 哈希表 根据设定的哈希函数H(key)和处理冲突方法将一组关键字映象到一个有限的地址区间上，并以关键字在地址区间中的象作为记录在表中的存储位置，这种表称为哈希表或散列，所得存储位置称为哈希地址或散列地址。 数据结构 抽象结构图 从上述类图和抽象结构图可以看出 ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。Segment 继承(Generalization)了可重入锁ReentrantLock，HashEntry 用于存储键值对数据。一个 ConcurrentHashMap 里 contains-a (Composition) 一个 Segment []，Segment 的结构和 HashMap 类似，是一种数组和链表结构， 一个 Segment 里 has-a (Aggregation)一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素， 每个 Segment 锁定一个 HashEntry 数组里的元素, 当对 HashEntry 数组的数据进行 put 等修改操作时，必须先获得它对应的 Segment 锁。 源码解析 内部类 Segment 类： Segment 维护着条目列表状态一致性， 所以可以实现无锁读。 在表超出 threshold 进行 resize 的时候， 复制节点， 所以在做 resize 修改操作的时候， 还可以进行读操作（在旧 list 读）。 本类里只有变化操作的方法才需要加锁， 变化的方法利用一系列忙等控制来处理资源争用， 例如 scanAndLock 和 scanAndLockForPut 。 那些遍历去查找节点的 tryLocks() 方法， 主要是用来吸收 cached 不命中(在 hash tables 经常出现)， 这样后续获取锁的遍历操作效率将会有不小提升。 我们可能不是真的需要使用找到的数据， 因为重新获得数据还需要加锁来保证更新操作的一致性， 但他们会更快地进行重定位。 此外， scanAndLockForPut 特地创建新数据用于没有数据被找到的 put 方法。 方法： 插入A， B， C后 Segment 示意图： ConcurrentHashMap的size操作 如果我们要统计整个ConcurrentHashMap里元素的大小，就必须统计所有Segment里元素的大小后求和。Segment里的全局变量count是一个volatile变量，那么在多线程场景下，我们是不是直接把所有Segment的count相加就可以得到整个ConcurrentHashMap大小了呢？不是的，虽然相加时可以获取每个Segment的count的最新值，但是拿到之后可能累加前使用的count发生了变化，那么统计结果就不准了。所以最安全的做法，是在统计size的时候把所有Segment的put，remove和clean方法全部锁住，但是这种做法显然非常低效。 因为在累加count操作过程中，之前累加过的count发生变化的几率非常小，所以ConcurrentHashMap的做法是先尝试2次通过不锁住Segment的方式来统计各个Segment大小，如果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小。 那么ConcurrentHashMap是如何判断在统计的时候容器是否发生了变化呢？使用modCount变量，在put , remove和clean方法里操作元素前都会将变量modCount进行加1，那么在统计size前后比较modCount是否发生变化，从而得知容器的大小是否发生变化。 方法: 在新 table 中重新分类节点。 因为使用了 2 的幂指数扩展方式， bucket/bin 中的数据还是在原位， 即旧数据的索引位置不变或者偏移了 2 的幂指数距离。 可以重用旧节点减少不必要的节点生成。 内部类 ：链表结构 初始化 ConcurrentHashMap: ConcurrentHashMap 结构图 由上面的代码可知segments数组的长度size通过concurrencyLevel计算得出。为了能通过按位与的哈希算法来定位segments数组的索引，必须保证segments数组的长度是2的N次方（power-of-two size），所以必须计算出一个是大于或等于concurrencyLevel的最小的2的N次方值来作为segments数组的长度。假如concurrencyLevel等于14，15或16，ssize都会等于16，即容器里锁的个数也是16。注意concurrencyLevel的最大大小是65535，意味着segments数组的长度最大为65536，对应的二进制是16位。 初始化segmentShift和segmentMask。这两个全局变量在定位segment时的哈希算法里需要使用，sshift等于ssize从1向左移位的次数，在默认情况下concurrencyLevel等于16，1需要向左移位移动4次，所以sshift等于4。segmentShift用于定位参与hash运算的位数，segmentShift等于32减sshift，所以等于28，这里之所以用32是因为ConcurrentHashMap里的hash()方法输出的最大数是32位的，后面的测试中我们可以看到这点。segmentMask是哈希运算的掩码，等于ssize减1，即15，掩码的二进制各个位的值都是1。因为ssize的最大长度是65536，所以segmentShift最大值是16，segmentMask最大值是65535，对应的二进制是16位，每个位都是1。 变量cap就是segment里HashEntry数组的长度，它等于initialCapacity除以ssize的倍数c，如果c大于1，就会取大于等于c的2的N次方值，所以cap不是1，就是2的N次方。segment的容量threshold＝(int)cap*loadFactor，默认情况下initialCapacity等于16，load factor等于0.75，通过运算cap等于1，threshold等于零。 在jdk1.8中主要做了2方面的改进 数据结构 1.8中放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现，结构如下： 只有在执行第一次put方法时才会调用initTable()初始化Node数组，实现如下： put实现 当执行put方法插入数据时，根据key的hash值，在Node数组中找到相应的位置，实现如下： 1、如果相应位置的Node还未初始化，则通过CAS插入相应的数据； 2、如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点； 3、如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点； 4、如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值； 5、如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount； size实现 1.8中使用一个volatile类型的变量baseCount记录元素的个数，当插入新数据或则删除数据时，会通过addCount()方法更新baseCount，实现如下： 1、初始化时counterCells为空，在并发量很高时，如果存在两个线程同时执行CAS修改baseCount值，则失败的线程会继续执行方法体中的逻辑，使用CounterCell记录元素个数的变化； 2、如果CounterCell数组counterCells为空，调用fullAddCount()方法进行初始化，并插入对应的记录数，通过CAS设置cellsBusy字段，只有设置成功的线程才能初始化CounterCell数组，实现如下： 3、如果通过CAS设置cellsBusy字段失败的话，则继续尝试通过CAS修改baseCount字段，如果修改baseCount字段成功的话，就退出循环，否则继续循环插入CounterCell对象； 所以在1.8中的size实现比1.7简单多，因为元素个数保存baseCount中，部分元素的变化个数保存在CounterCell数组中，实现如下： 通过累加baseCount和CounterCell数组中的数量，即可得到元素的总个数； 鸣谢 wenniuwuren "],["jdk源码系列-Integer","2018年06月06日","/2018/jdksourcecodereadinteger/","对于 Integer 这个 Java 程序员几乎天天使用的类,使用上却可以看出普通程序员和优秀程序员区别。 深入代码 在创建数字 1 的对象时， 大多数人会使用 new Integer(1)， 而使用 Integer.valueOf(1) 可以使用系统缓存，既减少可能的内存占用，也省去了频繁创建对象的开销。 系统默认只缓存 -128～127 之间的整数。下面我们看一下 Integer.valueOf(int) 方法的代码： 注意到核心 ， 观察 类的源码实现： 为 －128 ～ 127 数值提供自动装箱的缓存服务。 static 静态代码块可知缓存的初始化是在第一次使用的时候。 通过 VM 参数-XX:AutoBoxCacheMax= 可以配置缓存的最大值。 在 VM 初始化期间， 缓存最大值 high， 可能被保存在 sun.misc.VM class 的私有系统属性里。 总结 除非是 JDK 1.5 以前的环境， 如果系统不需要新对象， 则推荐使用 Long， Integer， Short， Character， Byte 的 valueOf() 方法提升性能。 鸣谢 wenniuwuren "],["jdk源码系列-ThreadLocal","2018年06月06日","/2018/jdksourcecodereadthreadlocal/","这个类提供本地线程变量。不同于一般的变量，这些变量在他们各自的线程里通过 get、set 访问一个它自己的变量，这是一个独立初始化的变量副本。在一个类中，ThreadLocal 实例一般是 private static 的，期望和一个线程关联状态（如 userId，transactionId 等）。简单地说，就是此类提供了线程的本地变量，线程修改本地变量不互相影响。 举个例子，下面的类给每个线程生成一个唯一的标识。一个线程 id 在第一次调用 ThreadId.get() 被赋值，并且在后续的调用上保持不变。 只要线程还存活并且 ThreadLocal 实例可访问，那么每个线程持有一个确定的引用指向本地的变量副本，当线程消失，它的本地变量副本将会被GC（除非还被其他对象引用）。 使用案例 源码分析 ThreadLocal 的数据结构：实线表示强引用，虚线表示弱引用 每个 Thread 维护一个ThreadLocalMap 映射 table，映射 table 的 key 是 ThreadLocal 实例，value 就是线程存独立的变量副本的地方。 为什么这么设计，而不是由 ThreadLocal 来维护一个以 Thread 为 key 的映射呢？原因如下： 减小 Entry 数组大小：ThreadLocal 数量多，还是 Thread 的数量多，显而易见，使用 ThreadLocal 来当 key 可以减少 Entry 数量 减小内存占用：当 Thread 消亡，对 Thread 实例不在引用，则 GC 后就会清除相关数据 先看字段含义 主要方法： 核心方法 get() 相关内容： 其中的 getMap(Thread t)： Thread 类中的代码：这里可以看到是 Thread 持有 ThreadLocal.ThreadLocalMap 引用 其中的 map.getEntry(this)： 核心方法 set() 相关内容： 鸣谢 wenniuwuren "],["jdk源码系列-内存模型","2018年06月06日","/2018/jdksourcecodereadmemoryactor/","为了让程序员忽略掉各种硬件和操作系统的内存访问差异， 也既无需关心不同架构上内存模型的差异， Java 在代码和硬件内存模型间又提供了一个 Java 内存模型。 并发模型的分类 在并发编程中，需要处理两个关键问题：线程之间如何通信（线程之间以何种机制来交换信息， 有两种方式：共享内存和消息传递）及线程之间如何同步。 在共享内存的并发模型里（如 Java），线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态（主存）来隐式（对程序员透明）进行通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。 同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。 虽然 Java 是共享内存并发模型， 对程序员透明， 但是不理解 Java 内存模型， 就会对内存可见性， 有序性等问题出现时找不到解决方法。 Java 虚拟机运行时数据区 虚拟机栈描述的是 Java 执行的内存模型： 每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、 操作数栈、 动态链接、 方法出口等信息。 Java 内存模型的主要目标是定义程序中各个变量的访问规则， 既在虚拟机中对变量的读写操作， 监视器的加锁和释放操作， 以及线程的启动和合并操作。 原子性、 可见性和有序性 Java 内存模型是围绕着在并发过程中如何处理原子性、 可见性和有序性来建立的。 原子性： 操作不可再分。 如在 Java 代码中使用 synchronized 和 ReentrantLock 来保障。 可见性： A 线程操作， 对 B 线程可见， 既 A 变量赋值 1， B 线程能看见变量已经变为 1。 synchronized 、final、 volatile 和 ReentrantLock 都能提供。 有序性： 在本线程内观察， 所有操作都是有序的（线程内表现为串行语义）； 如果在另一个线程中观察另一个线程， 所有操作都是无序的（指令重排序与工作内存与主内存同步延迟）。synchronized 、 volatile 和 ReentrantLock 都能提供有序性保证。 从上述可以得出 synchronized 和 ReentrantLock 是万能的， 但是效率却有巨大的差别， ReentrantLock 会比 synchronized 好很多， ConcurrentHashMap 的源码实现中就利用了 ReentrantLock 分段锁来提升并发安全和效率。 Happens-Before 规则 要保证 A 线程看到 B线程的操作结果（无论 A 和 B 是否在同一线程中执行）， 那么 A 和 B 之间必须满足 Happens-Before 关系。 Happens-Before 规则如下： 序次序规则（Program Order Rule）：程序中 操作 A 在操作 B 之前， 那么在线程中 A 操作将在 B 操作之前进行。 管程锁定规则（Monitor Lock Rule）：一个 unlock 操作 happen—before 后面（时间上的先后顺序，下同）对同一个锁的 lock 操作。 volatile 变量规则：对一个 volatile 变量的写操作 happen—before 后面对该变量的读操作。 线程启动规则：Thread 对象的 start() 方法 happen—before 此线程的每一个动作。 线程终止规则：线程的所有操作都 happen—before 对此线程的终止检测，可以通过 Thread.join() 方法结束、Thread.isAlive() 的返回值等手段检测到线程已经终止执行。 线程中断规则：对线程 interrupt() 方法的调用 happen—before 发生于被中断线程的代码检测到中断时事件的发生。 终结器规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）happen—before 它的 finalize() 方法的开始。 传递性：如果操作A happen—before 操作 B，操作 B happen—before 操作 C，那么可以得出 A happen—before 操作 C。 如果两个操作间缺乏 Happens-Before 关系， 那么 JVM 可以对它们进行任意排序。 鸣谢 wenniuwuren Java内存溢出(OOM)异常完全指南 "],["jdk源码系列-深入了解IO的工作机制","2018年06月06日","/2018/jdksourcecodereadio/","I/O 问题是任何编程语言都无法回避的问题，可以说 I/O 问题是整个人机交互的核心问题，因为 I/O 是机器获取和交换信息的主要渠道。在当今这个数据大爆炸时代，I/O 问题尤其突出，很容易成为一个性能瓶颈。正因如此，所以 Java 在 I/O 上也一直在做持续的优化，如从 1.4 开始引入了 NIO，提升了 I/O 的性能。 Java 的 I/O 类库的基本架构 Java 的 I/O 操作类在包 java.io 下，大概有将近 80 个类，但是这些类大概可以分成四组，分别是： 基于字节操作的 I/O 接口：InputStream 和 OutputStream 基于字符操作的 I/O 接口：Writer 和 Reader 基于磁盘操作的 I/O 接口：File 基于网络操作的 I/O 接口：Socket 前两组主要是根据传输数据的数据格式，后两组主要是根据传输数据的方式，虽然 Socket 类并不在 java.io 包下，但是我仍然把它们划分在一起，因为我个人认为 I/O 的核心问题要么是数据格式影响 I/O 操作，要么是传输方式影响 I/O 操作，也就是将什么样的数据写到什么地方的问题，I/O 只是人与机器或者机器与机器交互的手段，除了在它们能够完成这个交互功能外，我们关注的就是如何提高它的运行效率了，而数据格式和传输方式是影响效率最关键的因素了。我们后面的分析也是基于这两个因素来展开的。 基于字节的 I/O 操作接口 基于字节的 I/O 操作接口输入和输出分别是：InputStream 和 OutputStream，InputStream 输入流的类继承层次如下图所示： 输入流根据数据类型和操作方式又被划分成若干个子类，每个子类分别处理不同操作类型，OutputStream 输出流的类层次结构也是类似，如下图所示： 这里就不详细解释每个子类如何使用了，如果不清楚的话可以参考一下 JDK 的 API 说明文档，这里只想说明两点，一个是操作数据的方式是可以组合使用的，如这样组合使用 还有一点是流最终写到什么地方必须要指定，要么是写到磁盘要么是写到网络中，其实从上面的类图中我们发现，写网络实际上也是写文件，只不过写网络还有一步需要处理就是底层操作系统再将数据传送到其它地方而不是本地磁盘。关于网络 I/O 和磁盘 I/O 我们将在后面详细介绍。 基于字符的 I/O 操作接口 不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符，所以 I/O 操作的都是字节而不是字符，但是为啥有操作字符的 I/O 接口呢？这是因为我们的程序中通常操作的数据都是以字符形式，为了操作方便当然要提供一个直接写字符的 I/O 接口，如此而已。我们知道字符到字节必须要经过编码转换，而这个编码又非常耗时，而且还会经常出现乱码问题，所以 I/O 的编码问题经常是让人头疼的问题。关于 I/O 编码问题请参考另一篇文章 《深入分析Java中的中文编码问题》 。 下图是写字符的 I/O 操作接口涉及到的类，Writer 类提供了一个抽象方法 write(char cbuf[], int off, int len) 由子类去实现。 读字符的操作接口也有类似的类结构，如下图所示： 读字符的操作接口中也是 int read(char cbuf[], int off, int len)，返回读到的 n 个字节数，不管是 Writer 还是 Reader 类它们都只定义了读取或写入的数据字符的方式，也就是怎么写或读，但是并没有规定数据要写到哪去，写到哪去就是我们后面要讨论的基于磁盘和网络的工作机制。 字节与字符的转化接口 另外数据持久化或网络传输都是以字节进行的，所以必须要有字符到字节或字节到字符的转化。字符到字节需要转化，其中读的转化过程如下图所示： InputStreamReader 类是字节到字符的转化桥梁，InputStream 到 Reader 的过程要指定编码字符集，否则将采用操作系统默认字符集，很可能会出现乱码问题。StreamDecoder 正是完成字节到字符的解码的实现类。也就是当你用如下方式读取一个文件时： 读取文件 FileReader 类就是按照上面的工作方式读取文件的，FileReader 是继承了 InputStreamReader 类，实际上是读取文件流，然后通过 StreamDecoder 解码成 char，只不过这里的解码字符集是默认字符集。 写入也是类似的过程如下图所示： 通过 OutputStreamWriter 类完成，字符到字节的编码过程，由 StreamEncoder 完成编码过程。 磁盘 I/O 工作机制 前面介绍了基本的 Java I/O 的操作接口，这些接口主要定义了如何操作数据，以及介绍了操作两种数据结构：字节和字符的方式。还有一个关键问题就是数据写到何处，其中一个主要方式就是将数据持久化到物理磁盘，下面将介绍如何将数据持久化到物理磁盘的过程。 我们知道数据在磁盘的唯一最小描述就是文件，也就是说上层应用程序只能通过文件来操作磁盘上的数据，文件也是操作系统和磁盘驱动器交互的一个最小单元。值得注意的是 Java 中通常的 File 并不代表一个真实存在的文件对象，当你通过指定一个路径描述符时，它就会返回一个代表这个路径相关联的一个虚拟对象，这个可能是一个真实存在的文件或者是一个包含多个文件的目录。为何要这样设计？因为大部分情况下，我们并不关心这个文件是否真的存在，而是关心这个文件到底如何操作。例如我们手机里通常存了几百个朋友的电话号码，但是我们通常关心的是我有没有这个朋友的电话号码，或者这个电话号码是什么，但是这个电话号码到底能不能打通，我们并不是时时刻刻都去检查，而只有在真正要给他打电话时才会看这个电话能不能用。也就是使用这个电话记录要比打这个电话的次数多很多。 何时真正会要检查一个文件存不存？就是在真正要读取这个文件时，例如 FileInputStream 类都是操作一个文件的接口，注意到在创建一个 FileInputStream 对象时，会创建一个 FileDescriptor 对象，其实这个对象就是真正代表一个存在的文件对象的描述，当我们在操作一个文件对象时可以通过 getFD() 方法获取真正操作的与底层操作系统关联的文件描述。例如可以调用 FileDescriptor.sync() 方法将操作系统缓存中的数据强制刷新到物理磁盘中。 下面以清单 1 的程序为例，介绍下如何从磁盘读取一段文本字符。如下图所示： 当传入一个文件路径，将会根据这个路径创建一个 File 对象来标识这个文件，然后将会根据这个 File 对象创建真正读取文件的操作对象，这时将会真正创建一个关联真实存在的磁盘文件的文件描述符 FileDescriptor，通过这个对象可以直接控制这个磁盘文件。由于我们需要读取的是字符格式，所以需要 StreamDecoder 类将 byte 解码为 char 格式，至于如何从磁盘驱动器上读取一段数据，由操作系统帮我们完成。至于操作系统是如何将数据持久化到磁盘以及如何建立数据结构需要根据当前操作系统使用何种文件系统来回答，至于文件系统的相关细节可以参考另外的文章。 Java Socket 的工作机制 Socket 这个概念没有对应到一个具体的实体，它是描述计算机之间完成相互通信一种抽象功能。打个比方，可以把 Socket 比作为两个城市之间的交通工具，有了它，就可以在城市之间来回穿梭了。交通工具有多种，每种交通工具也有相应的交通规则。Socket 也一样，也有多种。大部分情况下我们使用的都是基于 TCP/IP 的流套接字，它是一种稳定的通信协议。 下图是典型的基于 Socket 的通信的场景： 主机 A 的应用程序要能和主机 B 的应用程序通信，必须通过 Socket 建立连接，而建立 Socket 连接必须需要底层 TCP/IP 协议来建立 TCP 连接。建立 TCP 连接需要底层 IP 协议来寻址网络中的主机。我们知道网络层使用的 IP 协议可以帮助我们根据 IP 地址来找到目标主机，但是一台主机上可能运行着多个应用程序，如何才能与指定的应用程序通信就要通过 TCP 或 UPD 的地址也就是端口号来指定。这样就可以通过一个 Socket 实例唯一代表一个主机上的一个应用程序的通信链路了。 建立通信链路 当客户端要与服务端通信，客户端首先要创建一个 Socket 实例，操作系统将为这个 Socket 实例分配一个没有被使用的本地端口号，并创建一个包含本地和远程地址和端口号的套接字数据结构，这个数据结构将一直保存在系统中直到这个连接关闭。在创建 Socket 实例的构造函数正确返回之前，将要进行 TCP 的三次握手协议，TCP 握手协议完成后，Socket 实例对象将创建完成，否则将抛出 IOException 错误。 与之对应的服务端将创建一个 ServerSocket 实例，ServerSocket 创建比较简单只要指定的端口号没有被占用，一般实例创建都会成功，同时操作系统也会为 ServerSocket 实例创建一个底层数据结构，这个数据结构中包含指定监听的端口号和包含监听地址的通配符，通常情况下都是“*”即监听所有地址。之后当调用 accept() 方法时，将进入阻塞状态，等待客户端的请求。当一个新的请求到来时，将为这个连接创建一个新的套接字数据结构，该套接字数据的信息包含的地址和端口信息正是请求源地址和端口。这个新创建的数据结构将会关联到 ServerSocket 实例的一个未完成的连接数据结构列表中，注意这时服务端与之对应的 Socket 实例并没有完成创建，而要等到与客户端的三次握手完成后，这个服务端的 Socket 实例才会返回，并将这个 Socket 实例对应的数据结构从未完成列表中移到已完成列表中。所以 ServerSocket 所关联的列表中每个数据结构，都代表与一个客户端的建立的 TCP 连接。 数据传输 传输数据是我们建立连接的主要目的，如何通过 Socket 传输数据，下面将详细介绍。 当连接已经建立成功，服务端和客户端都会拥有一个 Socket 实例，每个 Socket 实例都有一个 InputStream 和 OutputStream，正是通过这两个对象来交换数据。同时我们也知道网络 I/O 都是以字节流传输的。当 Socket 对象创建时，操作系统将会为 InputStream 和 OutputStream 分别分配一定大小的缓冲区，数据的写入和读取都是通过这个缓存区完成的。写入端将数据写到 OutputStream 对应的 SendQ 队列中，当队列填满时，数据将被发送到另一端 InputStream 的 RecvQ 队列中，如果这时 RecvQ 已经满了，那么 OutputStream 的 write 方法将会阻塞直到 RecvQ 队列有足够的空间容纳 SendQ 发送的数据。值得特别注意的是，这个缓存区的大小以及写入端的速度和读取端的速度非常影响这个连接的数据传输效率，由于可能会发生阻塞，所以网络 I/O 与磁盘 I/O 在数据的写入和读取还要有一个协调的过程，如果两边同时传送数据时可能会产生死锁，在后面 NIO 部分将介绍避免这种情况。 NIO 的工作方式 BIO 带来的挑战 BIO 即阻塞 I/O，不管是磁盘 I/O 还是网络 I/O，数据在写入 OutputStream 或者从 InputStream 读取时都有可能会阻塞。一旦有线程阻塞将会失去 CPU 的使用权，这在当前的大规模访问量和有性能要求情况下是不能接受的。虽然当前的网络 I/O 有一些解决办法，如一个客户端一个处理线程，出现阻塞时只是一个线程阻塞而不会影响其它线程工作，还有为了减少系统线程的开销，采用线程池的办法来减少线程创建和回收的成本，但是有一些使用场景仍然是无法解决的。如当前一些需要大量 HTTP 长连接的情况，像淘宝现在使用的 Web 旺旺项目，服务端需要同时保持几百万的 HTTP 连接，但是并不是每时每刻这些连接都在传输数据，这种情况下不可能同时创建这么多线程来保持连接。即使线程的数量不是问题，仍然有一些问题还是无法避免的。如这种情况，我们想给某些客户端更高的服务优先级，很难通过设计线程的优先级来完成，另外一种情况是，我们需要让每个客户端的请求在服务端可能需要访问一些竞争资源，由于这些客户端是在不同线程中，因此需要同步，而往往要实现这些同步操作要远远比用单线程复杂很多。以上这些情况都说明，我们需要另外一种新的 I/O 操作方式。 NIO 的工作机制 我们先看一下 NIO 涉及到的关联类图，如下： 上图中有两个关键类：Channel 和 Selector，它们是 NIO 中两个核心概念。我们还用前面的城市交通工具来继续比喻 NIO 的工作方式，这里的 Channel 要比 Socket 更加具体，它可以比作为某种具体的交通工具，如汽车或是高铁等，而 Selector 可以比作为一个车站的车辆运行调度系统，它将负责监控每辆车的当前运行状态：是已经出战还是在路上等等，也就是它可以轮询每个 Channel 的状态。这里还有一个 Buffer 类，它也比 Stream 更加具体化，我们可以将它比作为车上的座位，Channel 是汽车的话就是汽车上的座位，高铁上就是高铁上的座位，它始终是一个具体的概念，与 Stream 不同。Stream 只能代表是一个座位，至于是什么座位由你自己去想象，也就是你在去上车之前并不知道，这个车上是否还有没有座位了，也不知道上的是什么车，因为你并不能选择，这些信息都已经被封装在了运输工具（Socket）里面了，对你是透明的。NIO 引入了 Channel、Buffer 和 Selector 就是想把这些信息具体化，让程序员有机会控制它们，如：当我们调用 write() 往 SendQ 写数据时，当一次写的数据超过 SendQ 长度是需要按照 SendQ 的长度进行分割，这个过程中需要有将用户空间数据和内核地址空间进行切换，而这个切换不是你可以控制的。而在 Buffer 中我们可以控制 Buffer 的 capacity，并且是否扩容以及如何扩容都可以控制。 理解了这些概念后我们看一下，实际上它们是如何工作的，下面是典型的一段 NIO 代码： NIO 工作代码示例 调用 Selector 的静态工厂创建一个选择器，创建一个服务端的 Channel 绑定到一个 Socket 对象，并把这个通信信道注册到选择器上，把这个通信信道设置为非阻塞模式。然后就可以调用 Selector 的 selectedKeys 方法来检查已经注册在这个选择器上的所有通信信道是否有需要的事件发生，如果有某个事件发生时，将会返回所有的 SelectionKey，通过这个对象 Channel 方法就可以取得这个通信信道对象从而可以读取通信的数据，而这里读取的数据是 Buffer，这个 Buffer 是我们可以控制的缓冲器。 在上面的这段程序中，是将 Server 端的监听连接请求的事件和处理请求的事件放在一个线程中，但是在实际应用中，我们通常会把它们放在两个线程中，一个线程专门负责监听客户端的连接请求，而且是阻塞方式执行的；另外一个线程专门来处理请求，这个专门处理请求的线程才会真正采用 NIO 的方式，像 Web 服务器 Tomcat 和 Jetty 都是这个处理方式，关于 Tomcat 和 Jetty 的 NIO 处理方式可以参考文章《 Jetty 的工作原理和与 Tomcat 的比较》。 下图是描述了基于 NIO 工作方式的 Socket 请求的处理过程： 上图中的 Selector 可以同时监听一组通信信道（Channel）上的 I/O 状态，前提是这个 Selector 要已经注册到这些通信信道中。选择器 Selector 可以调用 select() 方法检查已经注册的通信信道上的是否有 I/O 已经准备好，如果没有至少一个信道 I/O 状态有变化，那么 select 方法会阻塞等待或在超时时间后会返回 0。上图中如果有多个信道有数据，那么将会将这些数据分配到对应的数据 Buffer 中。所以关键的地方是有一个线程来处理所有连接的数据交互，每个连接的数据交互都不是阻塞方式，所以可以同时处理大量的连接请求。 Buffer 的工作方式 上面介绍了 Selector 将检测到有通信信道 I/O 有数据传输时，通过 select() 取得 SocketChannel，将数据读取或写入 Buffer 缓冲区。下面讨论一下 Buffer 如何接受和写出数据？ Buffer 可以简单的理解为一组基本数据类型的元素列表，它通过几个变量来保存这个数据的当前位置状态，也就是有四个索引。如下表所示： Buffer 中的参数项 在实际操作数据时它们有如下关系图： 我们通过 ByteBuffer.allocate(11) 方法创建一个 11 个 byte 的数组缓冲区，初始状态如上图所示，position 的位置为 0，capacity 和 limit 默认都是数组长度。当我们写入 5 个字节时位置变化如下图所示： 这时我们需要将缓冲区的 5 个字节数据写入 Channel 通信信道，所以我们需要调用 byteBuffer.flip() 方法，数组的状态又发生如下变化： 这时底层操作系统就可以从缓冲区中正确读取这 5 个字节数据发送出去了。在下一次写数据之前我们在调一下 clear() 方法。缓冲区的索引状态又回到初始位置。 这里还要说明一下 mark，当我们调用 mark() 时，它将记录当前 position 的前一个位置，当我们调用 reset 时，position 将恢复 mark 记录下来的值。 还有一点需要说明，通过 Channel 获取的 I/O 数据首先要经过操作系统的 Socket 缓冲区再将数据复制到 Buffer 中，这个的操作系统缓冲区就是底层的 TCP 协议关联的 RecvQ 或者 SendQ 队列，从操作系统缓冲区到用户缓冲区复制数据比较耗性能，Buffer 提供了另外一种直接操作操作系统缓冲区的的方式即 ByteBuffer.allocateDirector(size)，这个方法返回的 byteBuffer 就是与底层存储空间关联的缓冲区，它的操作方式与 linux2.4 内核的 sendfile 操作方式类似。 I/O 调优 下面就磁盘 I/O 和网络 I/O 的一些常用的优化技巧进行总结如下： 磁盘 I/O 优化 性能检测 我们的应用程序通常都需要访问磁盘读取数据，而磁盘 I/O 通常都很耗时，我们要判断 I/O 是否是一个瓶颈，我们有一些参数指标可以参考： 如我们可以压力测试应用程序看系统的 I/O wait 指标是否正常，例如测试机器有 4 个 CPU，那么理想的 I/O wait 参数不应该超过 25%，如果超过 25% 的话，I/O 很可能成为应用程序的性能瓶颈。Linux 操作系统下可以通过 iostat 命令查看。 通常我们在判断 I/O 性能时还会看另外一个参数就是 IOPS，我们应用程序需要最低的 IOPS 是多少，而我们的磁盘的 IOPS 能不能达到我们的要求。每个磁盘的 IOPS 通常是在一个范围内，这和存储在磁盘的数据块的大小和访问方式也有关。但是主要是由磁盘的转速决定的，磁盘的转速越高磁盘的 IOPS 也越高。 现在为了提高磁盘 I/O 的性能，通常采用一种叫 RAID 的技术，就是将不同的磁盘组合起来来提高 I/O 性能，目前有多种 RAID 技术，每种 RAID 技术对 I/O 性能提升会有不同，可以用一个 RAID 因子来代表，磁盘的读写吞吐量可以通过 iostat 命令来获取，于是我们可以计算出一个理论的 IOPS 值，计算公式如下所以： ( 磁盘数 * 每块磁盘的 IOPS)/( 磁盘读的吞吐量 +RAID 因子 * 磁盘写的吞吐量 )=IOPS RAID 策略 网络 I/O 优化 网络 I/O 优化通常有一些基本处理原则： 一个是减少网络交互的次数：要减少网络交互的次数通常我们在需要网络交互的两端会设置缓存，比如 Oracle 的 JDBC 驱动程序，就提供了对查询的 SQL 结果的缓存，在客户端和数据库端都有，可以有效的减少对数据库的访问。关于 Oracle JDBC 的内存管理可以参考《 Oracle JDBC 内存管理》。除了设置缓存还有一个办法是，合并访问请求：如在查询数据库时，我们要查 10 个 id，我可以每次查一个 id，也可以一次查 10 个 id。再比如在访问一个页面时通过会有多个 js 或 css 的文件，我们可以将多个 js 文件合并在一个 HTTP 链接中，每个文件用逗号隔开，然后发送到后端 Web 服务器根据这个 URL 链接，再拆分出各个文件，然后打包再一并发回给前端浏览器。这些都是常用的减少网络 I/O 的办法。 减少网络传输数据量的大小：减少网络数据量的办法通常是将数据压缩后再传输，如 HTTP 请求中，通常 Web 服务器将请求的 Web 页面 gzip 压缩后在传输给浏览器。还有就是通过设计简单的协议，尽量通过读取协议头来获取有用的价值信息。比如在代理程序设计时，有 4 层代理和 7 层代理都是来尽量避免要读取整个通信数据来取得需要的信息。 尽量减少编码：通常在网络 I/O 中数据传输都是以字节形式的，也就是通常要序列化。但是我们发送要传输的数据都是字符形式的，从字符到字节必须编码。但是这个编码过程是比较耗时的，所以在要经过网络 I/O 传输时，尽量直接以字节形式发送。也就是尽量提前将字符转化为字节，或者减少字符到字节的转化过程。 根据应用场景设计合适的交互方式：所谓的交互场景主要包括同步与异步阻塞与非阻塞方式，下面将详细介绍。 同步与异步 所谓同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。要么成功都成功，失败都失败，两个任务的状态可以保持一致。而异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。我们可以用打电话和发短信来很好的比喻同步与异步操作。 在设计到 IO 处理时通常都会遇到一个是同步还是异步的处理方式的选择问题。因为同步与异步的 I/O 处理方式对调用者的影响很大，在数据库产品中都会遇到这个问题。因为 I/O 操作通常是一个非常耗时的操作，在一个任务序列中 I/O 通常都是性能瓶颈。但是同步与异步的处理方式对程序的可靠性影响非常大，同步能够保证程序的可靠性，而异步可以提升程序的性能，必须在可靠性和性能之间做个平衡，没有完美的解决办法。 阻塞与非阻塞 阻塞与非阻塞主要是从 CPU 的消耗上来说的，阻塞就是 CPU 停下来等待一个慢的操作完成 CPU 才接着完成其它的事。非阻塞就是在这个慢的操作在执行时 CPU 去干其它别的事，等这个慢的操作完成时，CPU 再接着完成后续的操作。虽然表面上看非阻塞的方式可以明显的提高 CPU 的利用率，但是也带了另外一种后果就是系统的线程切换增加。增加的 CPU 使用时间能不能补偿系统的切换成本需要好好评估。 两种的方式的组合 组合的方式可以由四种，分别是：同步阻塞、同步非阻塞、异步阻塞、异步非阻塞，这四种方式都对 I/O 性能有影响。下面给出分析，并有一些常用的设计用例参考。 四种组合方式 虽然异步和非阻塞能够提升 I/O 的性能，但是也会带来一些额外的性能成本，例如会增加线程数量从而增加 CPU 的消耗，同时也会导致程序设计的复杂度上升。如果设计的不合理的话反而会导致性能下降。在实际设计时要根据应用场景综合评估一下。 下面举一些异步和阻塞的操作实例： 在 Cassandra 中要查询数据通常会往多个数据节点发送查询命令，但是要检查每个节点返回数据的完整性，所以需要一个异步查询同步结果的应用场景，部分代码如下： 异步查询同步结果 总结 本文阐述的内容较多，从 Java 基本 I/O 类库结构开始说起，主要介绍了磁盘 I/O 和网络 I/O 的基本工作方式，最后介绍了关于 I/O 调优的一些方法。 "],["jdk源码系列-线程池","2018年06月06日","/2018/jdksourcecodereadthreadpool/","Executors 是 Executor、ExecutorService、ThreadFactory、Callable 类的工厂和工具方法。 创建一个固定大小的线程池 通过重用共享无界队列里的线程来减少线程创建的开销。当所有的线程都在执行任务，新增的任务将会在队列中等待，直到一个线程空闲。由于在执行前失败导致的线程中断，如果需要继续执行接下去的任务，新的线程会取代它执行。线程池中的线程会一直存在，除非明确地 shutdown 掉。 返回的是 ThreadPoolExecutor 类的对象，这个构造方法使用传入的参数和默认的线程工厂与拒绝执行的处理。 corePoolSize：线程池中的线程数量，除非设置了 allowCoreThreadTimeOut， 否则就算线程空闲还是在保存在线程池中 maximumPoolSize：线程池中允许存放最大的线程数量 keepAliveTime：当线程数大于 corePoolSize，如果 keepAliveTime 内空闲的线程未执行，线程将被终结 unit：keepAliveTime 的时间单位 workQueue：保存 execute() 提交的任务 可以看到固定大小线程池，corePoolSize 和 maximumPoolSize 传入的参数是一样的 创建一个单个线程的线程池 任务会被保证顺序执行，因为只有一个工作线程。不像 newFixedThreadPool(1)，这个不保证任务顺序执行。corePoolSize 和 maximumPoolSize 都是 1。 创建一个可按需自动扩容的线程池,但是会优先重用线程池中空闲可用的线程 这个类型的线程池将会大大提升执行许多短暂的异步任务的程序。如果线程池中线程都在使用，又有新任务到来，则新增一个线程到线程池。如果线程 60 秒内空闲，则将被终止移除线程池。corePoolSize 为 0，可知一旦线程 60s 空闲就会被移出线程池 创建一个在一定延迟时间后调度命令的线程池，或者周期性执行的线程池。 创建完线程池，然后就该执行任务了 看下内部类 DelegatedExecutorService 里的 execute 方法：可以看到任务执行策略（单线程串行、多线程并行）和任务的具体执行分离，是一个典型的命令模式。 创建线程池的时候，已经实例化了 ThreadPoolExecutor，所以上面 execute() 方法实际是调用 ThreadPoolExecutor 的 execute：给定的任务可能在未来的某个时刻执行。可能是新建一个线程执行，也可能是线程中原有的线程执行。如果任务不能执行，可能是这个 executor 已经被 shutdown 了，也可能是到达了线程池的执行阈值，任务被拒绝执行处理器处理中。 看到这，其实发现线程池的核心实现就是在 ThreadPoolExecutor 里面，所以先介绍下 ThreadPoolExecutor 类的作用： 上图可以看出 ThreadPoolExecutor 类的层次结构中的位置，是对抽象方法和接口的完整实现，即核心代码在这个类里。 一个 ExecutorService 执行每个任务可能用到线程池中的一个或多个线程，线程池由 Executors 工厂创建。 线程池解决了两个不同的问题： 执行大量异步的任务时，线程池减少线程的创建来减少开销，提升性能 提供了对资源的管理，包括当执行一系列任务时，线程的消耗。每个 ThreadPoolExecutor 也存储有些基本数据，诸如完成的任务数量 想要在更广阔的背景下使用的话，这个类提供了许多可调整的参数和扩展的 hook。不管怎么样，还是推荐使用 Executors 来创建线程池比较方便。 这个主要的线程池控制状态 ctl，使用 AtomicInteger 存储两个概念上的字段 workerCount(线程池有效的线程数) 和 runState(线程池是 running、shuting down 等等状态) 上述 execute() 方法有三个处理步骤： 如果正在 running 的线程 (即 worker 线程) 小于 corePoolSize ( workerCountOf(c) \u0026lt; corePoolSize )，尝试创建一个新线程并把传入的 command(任务) 作为它的第一个任务。调用 addWorker(command, true) 自动检查 runState 和 workCount，以便在不能增加线程的时候返回 false。添加成功直接 return，不能添加就要看下面的步骤 如果被成功放进队列（if (isRunning(c) \u0026amp;\u0026amp; workQueue.offer(command)) workQueue 是一个任务排队的阻塞队列），然后还需要二次检查线程池是否 shut down（上次检查后到这次检查前死亡）。所以我们重新检查状态，如果线程池停止的话，回滚进队操作，或者如果没有工作的线程开启一个新线程（addWorker(null, false);） 如果不能让任务进入阻塞队列，然后尝试新增一个线程。如果新增线程失败，可能是线程池 shut down 或者线程池饱和（达到 maxPoolSize），所以接下来抛弃这个任务。 任务（Task）被包装在一个叫做 Worker 的内部类，Worker 继承 AQS 来实现任务增加/删除的同步控制，使用 HashSet 来保存 Worker 线程。如果 worker 线程大于 corePoolSize，则不创建 worker 线程，而是放入一个 BlockingQueue 排队。如果有界队列的 BlockingQueue 满了，则尝试增加线程到线程池，但是线程总数要小于 maxPollSize。 addWorker() 方法：检查线程池当前状态和线程数量的边界条件看是否可以增加 worker 线程。如果可以，工作线程计数响应调整，并且，如果可能的话，新的 worker 线程被创建，启动，跑它的第一个 task。如果线程池 stop 或者要被 shut down，此方法返回 false。如果线程工厂（thread factory）创建线程失败，此方法也会返回 false。如果线程创建失败，不管是 thread factory 返回 null，或者 exception（通常是 OOM），都会被回滚。 参数 firstTask： 新线程应该运行的第一个任务。如果 worker 线程小于 corePoolSize，worker 和初始化的第一次任务一起创建绕过排队这一过程，或者队列已满。初始化空闲线程通常是通过 prestartCoreThread 或者替换已经死亡的 worker 线程。 core：如果 true，则使用 corePoolSize 作为边界，否则使用 maximumPoolSize 作为边界。（这里使用 Boolean 而不是传入实际值，是因为传入值可能会在传入过程被改变，在方法中直接读取值更精确）。 鸣谢 wenniuwuren "],["jdk源码系列-Object","2018年06月06日","/2018/jdksourcecodereadobject/","Object类是类层次结构的根，是每一个类的父类。所有的对象（包括数组）都是实现了object类的方法。 Object结构 这里有7个native方法： registerNatives() getClass() hashCode() clone() notify() notifyAll() wait(long) 什么是native方法？简单的说，native表示该方法的实现java本身并没有完成，而是有c/c++来完成，放在.dll动态库文件中。这里我们不关注本地方法的具体，我们可以看看其注释和声明，知道这些方法是干什么的。 1） 该方法源码中并没有任何注释说明，而且在静态块中调用了方法。首先明确在类初始化的时候，这个方法被调用执行了。 至于该方法的做用，请看native方法的c代码实现：这里是相关的C代码（来自OpenJDK6）： 详细的说：通常情况下，为了使JVM发现您的本机功能，他们被一定的方式命名。例如，对于java.lang.Object.registerNatives，对应的C函数命名为Java_java_lang_Object_registerNatives。通过使用registerNatives（或者更确切地说，JNI函数RegisterNatives），您可以命名任何你想要你的C函数。(来自：https://www.linuxidc.com/Linux/2015-06/118676.htm ) 简单的说：就是对几个本地方法进行注册(也就是初始化java方法映射到C的方法)。 细心的读者可能发现这里为什么没有getClass()方法的注册？因为它不需要被注册，它有一个Java_java_lang_Object_getClass的“标准”名称。 （2）getClass() 返回Object的运行时class对象，返回的对象是被静态同步方法锁定的对象（这意味着，该类的所有对象中，同时只有一个对象可以获得锁）。而且实际上返回的class对象是多态的，可以是调用者的子类（注释中Number的例子解释了这一内容）。 （3）hashCode() hashCode()也是一个native方法，该方法返回调用对象的hash码。hashCode必须满足以下协议： 在一个Java应用中，对同一个对象多次调用hashCode()方法，必须返回相同的值。在对象被修改时，不提供equals方法的比较信息。（我的理解：不可以将hashCode值作为equals方法相等的充要条件，同一对象hashCode值肯定相等，不同对象hashCode值不一定不相等） 如果两个对象通过equals方法相等，那么两个对象的hashCode返回值必须要相等。 如果两个对象通过equals方法不相等，两个对象的hashCode返回值不一定不相等。但是程序员应该知道，不相等的对象若返回不想等的hash值，有助于提高hash表的性能。 （4）equals(Object obj) 判断两个对象是不是相等。该方法遵循如下性质： 自反性：对于任意非空引用x，则x.equals(x)返回true。 对称性：对于任意非空引用x、y，若x.equals(y)返回true，则y.equals(x)返回true。 传递性：对于任意非空引用x、y、z，若x.equals(y)返回true且y.equals(z)返回true，则x.equals(z)返回true。 对于任何非空引用值x和y，多次调用x.equals（y）始终返回true或者始终返回false，没有提供任何信息进行相等比较的对象被修改。 对于任意非空引用x，则x.equals(null)返回false。 重写equals方法必须重写hashCode方法来保证对任意两个对象equals返回值true时，他们的hashCode返回值必须相等。 请注意源码中的实现是“==”号，必要时请重写该方法！ （5）clone() 创建和返回一个对象的复制。注意以下几点： x.clone() != x 是true 一个对象可以被克隆的前提是该对象代表的类实现了Cloneable接口，否者会抛出一个CloneNotSupportedException异常。 调用clone方法时，分配的内存和源对象（即调用clone方法的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域， 填充完成之后，clone方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部。 克隆是浅复制。（详情：http://www.importnew.com/22035.html ） （6）toString() 返回一个表示该对象的字符串，默认实现是：类名@Integer.toHexString(hashCode()) 建议子类重写该方法。 （6）notify()、notifyAll()、wait()、wait(long)、wait(long,int) 这几个方法是多线程编程里面常用的方法，这里不多解释。 （7）finalize() 这是一个被垃圾收集器调用的方法，当一个对象没有被其他引用指向时，垃圾回收器会清理该对象，在回收该对象之前会调用finalize方法。子类一般会重写该方法做一些系统资源清理工作。一个对象只会被调用一次finalize方法。如果finalize方法抛出异常，这个对象的终结将会停止。 鸣谢 wenniuwuren "],["jdk源码系列-NIO","2018年05月05日","/2018/jdksourcecodereadnio/","Java NIO和IO之间第一个区别是， IO是面向流的， NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节， 直至读取所有字节， 它们没有被缓存在任何地方。 JavaNIO的缓冲导向方法略有不同。 数据读取到一个它稍后处理的缓冲区， 需要时可在缓冲区中前后移动。 还需要检查是否该缓冲区中包含所有您需要处理的数据。 而且， 需确保当更多的数据读入缓冲区时， 不要覆盖缓冲区里尚未处理的数据。 另外， Java IO的各种流是阻塞的， 而Java NIO是非阻塞的。 IO是当一个线程调用read() 或write()时， 该线程被阻塞， 直到有一些数据被读取， 或数据完全写入。 该线程在此期间不能再干任何事情了。 而Java NIO的非阻塞模式， 使一个线程从某通道发送请求读取数据， 但是它仅能得到目前可用的数据， 如果目前没有数据可用时， 就什么都不会获取。 而不是保持线程阻塞， 所以直至数据变的可以读取之前， 该线程可以继续做其他的事情。 非阻塞写也是如此。 一个线程请求写入一些数据到某通道， 但不需要等待它完全写入， 这个线程同时可以去做别的事情。 而且， Java IO: 一个典型的IO服务器设计- 一个连接通过一个线程处理， 而NIO可让您只使用一个单线程管理多个通道（ 网络连接或文件） ， 但付出的代价是解析数据可能会比从一个阻塞流中读取数据更复杂。 java NIO主要组成部分 Channels Buffers Selectors 虽然Java NIO 中除此之外还有很多类和组件， 但在我看来， Channel， Buffer 和 Selector 构成了核心的API。 其它组件， 如Pipe和FileLock， 只不过是与三个核心组件共同使用的工具类。 Java NIO的通道类似流， 但又有些不同： 既可以从通道中读取数据， 又可以写数据到通道。 但流的读写通常是单向的。 通道可以异步地读写。 通道中的数据总是要先读到一个Buffer， 或者总是要从一个Buffer中写入。 Channel 和 Buffer 基本上， 所有的 IO 在NIO 中都从一个Channel 开始。 Channel 有点象流。 数据可以从Channel读到Buffer中， 也可以从Buffer 写到Channel中。 Channel和Buffer有好几种类型。 下面是JAVA NIO中的一些主要Channel的实现： FileChannel,从文件中读写数据。 DatagramChannel，能通过UDP读写网络中的数据 SocketChannel,能通过TCP读写网络中的数据 ServerSocketChannel,以监听新进来的TCP连接， 像Web服务器那样。 对每一个新进来的连接都会创建一个SocketChannel。 正如你所看到的， 这些通道涵盖了UDP 和 TCP 网络IO， 以及文件IO。 基本的Channel示例 注意 buf.flip() 的调用， 首先读取数据到Buffer， 然后反转Buffer,接着再从Buffer中读取数据。 Java NIO中的Buffer用于和NIO通道进行交互。 如你所知， 数据是从通道读入缓冲区， 从缓冲区写入到通道中的。缓冲区本质上是一块可以写入数据， 然后可以从中读取数据的内存。 这块内存被包装成NIOBuffer对象， 并提供了一组方法， 用来方便的访问该块内存。以下是Java NIO里关键的Buffer实现： ByteBuffer CharBuffer DoubleBuffer FloatBuffer IntBuffer LongBuffer ShortBuffer 这些Buffer覆盖了你能通过IO发送的基本数据类型： byte, short, int, long, float, double 和char。Java NIO 还有个 MappedByteBuffer， 用于表示内存映射文件。 当向buffer写入数据时， buffer会记录下写了多少数据。 一旦要读取数据， 需要通过flip()方法将Buffer从写模式切换到读模式。 在读模式下， 可以读取之前写入到buffer的所有数据。一旦读完了所有的数据， 就需要清空缓冲区， 让它可以再次被写入。 有两种方式能清空缓冲区： 调用clear()或compact()方法。 clear()方法会清空整个缓冲区。 compact()方法只会清除已经读过的数据。 任何未读的数据都被移到缓冲区的起始处， 新写入的数据将放到缓冲区未读数据的后面。 Buffer的capacity,position和limit position 当你写数据到Buffer中时， position表示当前的位置。 初始的position值为0.当一个byte、 long等数据写到Buffer后， position会向前移动到下一个可插入数据的Buffer单元。 position最大可为capacity – 1.当读取数据时， 也是从某个特定位置读。 当将Buffer从写模式切换到读模式， position会被重置为0. 当从Buffer的position处读取数据时， position向前移动到下一个可读的位置。 limit 在写模式下， Buffer的limit表示你最多能往Buffer里写多少数据。 写模式下， limit等于Buffer的capacity。当切换Buffer到读模式时， limit表示你最多能读到多少数据。 因此， 当切换Buffer到读模式时， limit会被设置成写模式下的position值。 换句话说， 你能读到之前写入的所有数据（ limit被设置成已写数据的数量， 这个值在写模式下就是position） 向Buffer中写数据 写数据到Buffer有两种方式： 从Channel写到Buffer。 通过Buffer的put()方法写到Buffer里。 从Buffer中读取数据 从Buffer中读取数据有两种方式： 从Buffer读取数据到Channel。 使用get()方法从Buffer中读取数据。 Selector Selector（ 选择器） 是Java NIO中能够检测一到多个NIO通道， 并能够知晓通道是否为诸如读写事件做好准备的组件。 这样， 一个单独的线程可以管理多个channel， 从而管理多个网络连接。Selector允许单线程处理多个 Channel。 如果你的应用打开了多个连接（ 通道） ， 但每个连接的流量都很低， 使用Selector就会很方便。 例如， 在一个聊天服务器中 为什么使用Selector? 仅用单个线程来处理多个Channels的好处是， 只需要更少的线程来处理通道。 事实上， 可以只用一个线程处理所有的通道。 对于操作系统来说， 线程之间上下文切换的开销很大， 而且每个线程都要占用系统的一些资源（ 如内存） 。 因此， 使用的线程越少越好。 Selector的创建 通过调用Selector.open()方法创建一个Selector， 如下： 要使用Selector， 得向Selector注册Channel， 然后调用它的select()方法。 这个方法会一直阻塞到某个注册的通道有事件就绪。 一旦这个方法返回， 线程就可以处理这些事件， 事件的例子有如新连接进来， 数据接收等。与Selector一起使用时， Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用， 因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。 注意register()方法的第二个参数。 这是一个“interest集合”， 意思是在通过Selector监听Channel时对什么事件感兴趣。 可以监听四种不同类型的事件 SelectionKey.OP_CONNECT SelectionKey.OP_ACCEPT SelectionKey.OP_READ SelectionKey.OP_WRITE 如果你对不止一种事件感兴趣， 那么可以用“位或”操作符将常量连接起来， 如下: Scatter/Gather Java NIO开始支持scatter/gather， scatter/gather可以从Channel中读入和读取数据。分散（ scatter） 从Channel中读取是指在读操作时将读取的数据写入多个buffer中。 因此，Channel将从Channel中读取的数据“分散（ scatter） ”到多个Buffer中。聚集（ gather） 写入Channel是指在写操作时将多个buffer的数据写入同一个Channel， 因此，Channel 将多个Buffer中的数据“聚集（ gather） ”后发送到Channel。scatter / gather经常用于需要将传输的数据分开处理的场合， 例如传输一个由消息头和消息体组成的消息， 你可能会将消息体和消息头分散到不同的buffer中， 这样你可以方便的处理消息头和消息体 Scattering Reads Scattering Reads是指数据从一个channel读取到多个buffer中。 read()方法按照buffer在数组中的顺序将从channel中读取的数据写入到buffer， 当一个buffer被写满后， channel紧接着向另一个buffer中写。Scattering Reads在移动下一个buffer前， 必须填满当前的buffer， 这也意味着它不适用于动态消息(译者注： 消息大小不固定)。 换句话说， 如果存在消息头和消息体， 消息头必须完成填充（ 例如 128byte） ， Scattering Reads才能正常工作 Gathering Writes Gathering Writes是指数据从多个buffer写入到同一个channel。 buffers数组是write()方法的入参， write()方法会按照buffer在数组中的顺序， 将数据写入到channel， 注意只有position和limit之间的数据才会被写入。 因此， 如果一个buffer的容量为128byte， 但是仅仅包含58byte的数据,那么这58byte的数据将被写入到channel中。 因此 Scattering Reads相反， Gathering Writes能较好的处理动态消息。 "],["jdk源码系列-throwable和Exception的区别","2018年05月05日","/2018/throwableandexception/","在写代码的时候Exception随手就来，但是提到Throwable总觉得又熟悉又陌生。 先上图为敬 从上图可以看出,throwable是Exception的父类，它包含了系统级的Error和程序级的Exception,所以接触的少倒也不足为奇。 什么是异常 异常的英文单词是exception，字面翻译就是“意外、例外”的意思，也就是非正常情况。事实上，异常本质上是程序上的错误，包括程序逻辑错误和系统错误。比如使用空的引用、数组下标越界、内存溢出错误等，这些都是意外的情况，背离我们程序本身的意图。错误在我们编写程序的过程中会经常发生，包括编译期间和运行期间的错误，在编译期间出现的错误有编译器帮助我们一起修正，然而运行期间的错误便不是编译器力所能及了，并且运行期间的错误往往是难以预料的。假若程序在运行期间出现了错误，如果置之不理，程序便会终止或直接导致系统崩溃，显然这不是我们希望看到的结果。因此，如何对运行期间出现的错误进行处理和补救呢？Java提供了异常机制来进行处理，通过异常机制来处理程序运行期间出现的错误。通过异常机制，我们可以更好地提升程序的健壮性。 什么是错误 是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。 区别 注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。通常，Java的异常(包括Exception和Error)分为可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）。 可查异常（编译器要求必须处置的异常）：正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。 除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。 应该catch什么 其实只要是Throwable和其子类都是可以throw和catch的，那么如果在需要统一处理异常的地方，我们应该catch (Throwable th) 还是 catch (Exception)呢？ 这两种处理的区别在于，catch throwable会把Error和其他继承Throwable的类捕捉到。而catch Exception只会捕捉Exception极其子类，捕捉的范围更小。先不考虑有其他的类继承了Throwable的情况下，第一种catch相当于比第二种catch多捕捉了把Error和其子类。 那么究竟Error是否需要捕捉呢？JDK中Error类的的注释（如下）里提到过，Error是一种严重的问题，应用程序不应该捕捉它。 Error可以catch吗？ 可以catch了后做些其他处理吗？ Error是可以catch的，而且也可以向常规Exception一样被处理，而且就算不捕捉的话也只是导致当前线程挂掉，其他线程还是可以正常运行，如果有需要的话捕捉Error之后也可以做些其他处理。但是Error是一种系统内部的错误，这种错误不像Exception一样是可能是程序和业务上的错误是可以恢复的。 "],["jdk源码系列-顺序索引","2018年05月05日","/2018/jdksourcecoderead/","很多java开发的小伙伴都会阅读jdk源码，然而确不知道应该从哪读起。以下为通常所需阅读的源码范围。 标题为包名，后面序号为优先级1-4，优先级递减 1、java.lang java.util java.util.concurrent java.util.concurrent.atomic java.lang.reflect java.lang.annotation java.util.concurrent.locks java.nio java.sql java.net 阅读笔记简版 1、Object 2、String 3、AbstractStringBuilder 4、StringBuffer 5、StringBuilder 继承AbstractStringBuilder 6、ArrayList 7、LinkedList 8、HashMap 9、Hashtable 10、HashSet 11、LinkedHashMap继承HashMap 12、LinkedHashSet 13、AbstractMap 14、ConcurrentHashMap 15、TreeMap 16、TreeSet 来源 https://blog.csdn.net/qq_21033663/article/details/79571506 "],["我的书架","2018年04月04日","/2018/mybooksheet/","在如今数据爆炸的年代，如果在大量数据中找到自己需要的那部分东西至关重关。在我关注的领域中，常伴我的那些经典之作奉给各位。 鸟哥的Linux私房菜—基础学习篇 个人评价：这本书对于学习Linux基础知识非常有帮助，既可以当成教科书也可以当成工具，很多服务是运行在linux这类操作系统之中的，学习一些linux知识是很有必要的。比如vim，makefile, 常用的linux命令，脚本编写等等知识点。虽然次数的名字不是像类似“深入浅出****”，“深入理解*****”等那么高大上一些，但是如果要掌握一些linux知识，此书评价可看此大任。当然此书还有另一本，是服务架设篇，如果对此有兴趣的朋友可以买来看看。书中基本没有错别字，笔误等小错误，可见其背后的团队之认真。 评分：5分（满分5分，这个给5分不是说此书已经登峰造极，而是觉得以目前关于此类的书籍，已经是上品了） 提示：此书篇幅较大（可以和《Think in Java》的篇幅相比），内容较多，看个一两遍基本也记不住多少，还是要勤加练习，更多的可以当工具书来查阅。 Effective Java 个人评价：了解过Java的人应该或多或少的听过此书吧，堪称经典。书中主要罗列了一些知识点，然后对于这些知识点单独进行详述。内容颇有深度，建议有基础的人看。 题外话：很多人认为《Think in Java》是经典之作，当然博主也写不出《Think in Java》这类巨作，但是博主本人并不推荐《Think in Java》这本书，应该他的定位很尴尬（博主看过第三版和 第四版），就拿第四版来说，对于初学者看起来应该是很吃力的，尤其是书中的案例特别长，而且是用外国人的思维去举例的，初学者看起来比较扯淡。那对于实力者而言，这本书的意义就是帮你复习复习，却很难有知识点去惊艳到你。再者就是这本书也不是当工具书，书中例子很多，但是对于单个的知识点未尽其细。所以博主的观点是这本书适合闲来看看，不喜请轻喷。。。 评分：5分。 提示：无。 Java并发编程实战 个人评价：国外人写的书，这是翻译版，原书《Java Concurrency In Practice》,堪称并发中的经典书籍。翻译的也很好，书本内容偏理论，基本知识点都能够概括。当然这本书还是需要有一点的并发基础的人适合看的，零基础的看起来会有点吃力。此书可以看好多遍，每看一遍都会有新的认识。 评分：5分。 提示：无。 Java多线程编程核心技术 个人评价：此书是国人写的，适合零基础的人学习，里面每一个知识点都会有案例介绍。如果你有那么点基础，此书就不用看了，纯粹是浪费时间浪费钱。其实会点并发的一天就可以看完此书了。既然是多线程核心技术，连ThreadPoolExecutor都没有涉及。书中基本是关于Thread和Runnable翻来覆去的用法。 评分：2分。 提示：不建议看，实在闲得慌或者基本零基础可以看看。 Java并发编程的艺术 个人评价：此书是阿里人也的书，一共有三个作者，第一作者是方腾飞，也是并发编程网的创始人，如果在网上搜索并发编程的相关知识，或多或少的会链接到他的网站上去。此书开篇就很有深度，比如偏向锁、自旋锁、轻量级锁等。前面6章都很不错，理解的非常深入，很底层，后面开始有点撑版面的，尤其是Atomic这一章出现了严重的错误，有点凤头鸡尾的感觉。但是总体上来看还是很不错的，非常推荐买来看看。 评分：4分 提示：强烈推荐，只不过尾部几章写的太草率，扣点分 深入理解Java虚拟机 个人评价：此书也甚为经典，博主看了不下5遍。此书的作者是国内的，在市场上面滥竽充数横行的今天，算得上是上上品。书中对JVM进行了详细深刻的说明，是学习JVM原理必备书籍。必须强烈推荐。 评分：5分 提示：无 大型网站技术架构核心原理与案例分析 个人评价：如果要学习分布式，这本书基本把分布式的知识讲了个边（概论），书本篇幅不大，但是内容特别精炼，比如网站架构演变，高可用，高性能，伸缩性等等。此书的作者和下面所要陈述的两本书的作者也都是阿里系的。个人觉得学习分布式或者说大型网站架构可以先看看这本书来个全局统筹，然后再看《大型分布式网站架构设计与实践》，最后又实践经验了再看《大型网站系统与Java中间件实践》。 评分：5分 提示：强烈推荐。 大型分布式网站架构设计与实践 个人评价：刚刚那本书是关于大型分布式网站架构的一个概论，而这本就根据作者的经历，在实际中需要用到的一些知识对这个主题进行了一番探讨，偏应用，书中罗列了很多技术，也进行了案例探讨，内容不深。此书值得看一看。 评分：4分 提示：最好实际操作一下，加深印象。 大型网站系统与Java中间件实践 个人评价：这本书比上面两本要深一点，主要是关于一些中间件的设计。这里的并不是简单的教你怎么使用一些中间件，而是根据实际问题来演变怎么设计一个合适的中间件，适合有一定相关工作经验的人翻阅。可以买来看看，写的很不错 评分：4.5分 提示：最好有相关工作或学习经验。 netty实战 个人评价：在游戏行业中，如果用java做服务端。无非只有netty,mina,grizzly3个框架可以选择。而netty是使用最广泛的一个,netty实战对于netty框架进行了全面的剖析。 评分：4.8分 提示：需要有多线程并发基础。 Head First 设计模式 简介：《Head First设计模式》(中文版)共有14章，每章都介绍了几个设计模式，完整地涵盖了四人组版本全部23个设计模式。前言先介绍这本书的用法；第1章到第11章陆续介绍的设计模式为Strategy、Observer、Decorator、Abstract Factory、Factory Method、Singleton，Command、Adapter、Facade、TemplateMethod、Iterator、Composite、State、Proxy。最后三章比较特别。第12章介绍如何将两个以上的设计模式结合起来成为新的设计模式(例如著名的MVC模式)，作者称其为复合设计模式(这是作者自创的名称，并非四人组的标准名词)，第13章介绍如何进一步学习设计模式，如何发觉新的设计模式等主题，至于第14章则很快地浏览尚未介绍的设计模式，包括Bridge、Builder、Chain of Responsibility、Flyweight、Interpreter、Mediator、Memento、Prototype，Visitor。第1章还介绍了四个○○基本概念(抽象、封装、继承、多态)，而第1章到第9章也陆续介绍了九个○○原则(Principle)。千万不要轻视这些○○原则，因为每个设计模式背后都包含了几个○○原则的概念。很多时候，在设计时有两难的情况，这时候我们必须回归到○○原则，以方便判断取舍。可以这么说：○○原则是我们的目标，而设计模式是我们的做法。 评分：4.5分 提示：设计模式基础 重构：改善既有代码的设计 简介：《重构:改善既有代码的设计》(中文版)解释重构的原理（principles）和最佳实践方式（best practices），并指出何时何地你应该开始挖掘你的代码以求改善。《重构:改善既有代码的设计》(中文版)的核心是一份完整的重构名录（catalog of refactoring），其中每一项都介绍一种经过实证的代码变换手法（code transformation）的动机和技术。某些项目如Extract Method和Move Field看起来可能很浅显，但不要掉以轻心，因为理解这类技术正是有条不紊地进行重构的关键。点击进入该书更多详细信息。 评分：4.6分 提示：java架构 "],["项目上线之后遇到的坑","2018年03月03日","/2018/onlineprojectken/","现在真正理解了能力越强，责任越来。这是我在作为一个普通程序时从未体会到的感受。当线上出现bug需要紧急处理的时候，真的生无可恋 。 压测时数据库文件庞大无比，仔细分析binlog和玩家数据结构找到原因改造。 竞技场战斗结束没有结算面板，导致大量参与活动者无法退出副本。 每日充值奖励策划配置id变动导致充值奖励领取异常，写修复脚本紧急处理。 因sql文件名字对应不上，运维未执行sql文件导致所有排行榜数据为空。 http切换https(ws切换到wss)时域名解析对不上导致服务器无法连通 自动开服工具开服时间修改不完整导致开服活动未开 运营设置时间错误导致自动开服工具开服出现断服,新服30,39己成老服 热更脚本问题导致全平台黑屏10分钟 其他bug待发现(感觉需要请高僧给服务器开个光) "],["主程职责总结和反思","2018年03月03日","/2018/mainprojectjobs/","有生之年作为主程做的第一款游戏终于正式上线了(之前有2款作为普通程序的己上线的游戏),虽然现在依然保持着一周加班6天的状态。但是欣慰的是上线数据表现还不错，值得期待。做主程时间也有半年多了，从最初的手忙脚乱，诚惶诚恐到现在能够较好的应对，其中心酸历程只有经历过才能体会到。即使如此还是有很多做的不够的地方值得反思，要提升自己的综合素质。 在网络上搜集了各种资料和自己的经验（大部分内容摘自网络,主要也是为了提醒自己），总结如下： 服务端主程主要负责游戏开发中服务端的各项工作 包含但不限于：解决团队中别人解决不了的问题，制作提升工作效率的工具； 服务端技术人员管理 向上有汇报，向下能统筹 尽可能的快速实现策划的需求，提供解决方案 达到一个里程碑后能反馈，遇到难点短时间无法攻克，及时沟通，并说说自己能做到的程度，帮助策划思考替换方案； 改需求无法避免。（网上产品经理（策划）是被各种程序员黑，现实中调侃调侃可以，别过了，人家也是没办法。） 会反思，策划的功能对吗?为何有会这么设计？配表方便吗？ 手下心中的好大哥，人品过关，技术过关。 保持对新技术的好奇心，多关注业内比较新的解决方案。因为一旦做新项目，技术选型就是你的本职工作，而且影响整个项目周期，换句话说到底未来需要踩多少坑，由你决定。所以你要有一套经过实践证明行之有效的学习方法论 对于一个刚刚晋升的同学来说，管理这一块是最棘手的，对于我来说也是这个阶段。这块其实也比较通用，不限于技术管理领域，但是管理这东西不能靠书本，在实践中总结，才是深刻的。你是主程了，那就意味这有一堆人会看着你做事。你怎么做事将间接的影响组员的做事态度。所以一个词——以身作则。别以为主程了就可以有些特权，可以迟到，可以工作时间扯淡，始终牢记：能力越大，责任越大。之所以把这条列在这里，我觉得管理包括自我管理和团队管理,而且前者是后者的基础；以前吧，你只要把自己的事情做好就算完成本职工作了，超出边界的工作，你做了那是加分，你的主程看到了或许还能表扬你，你不做也没关系。而现在你的事情就是整个游戏的服务端（甚至整个技术），任何报错，组员解决不了的诡异的bug，那都是你要解决的事情。 你的工作会被各种打断，来自各位组员，主策，主美，项目经理。所以整片的工作时间几乎只在这些人都回家了，你留下来加班才能获得。 可能你还有一件事情，就是给每个组员打绩效，项目经理说，SABCD各占一定比例，所以给你出个难题，你想想你怎么解决：这个月是项目上线前夕,大家表现得都很拼，都很优秀，你怎么打绩效。 你的内心要足够强大，因为会有人质疑你的决策。 你的沟通表达能力需要提升一个档次，因为你要给各个层次的人解释同一个问题; 你会有许多跨部门的沟通； 你的组织能力要跟上节奏，定期组织这帮程序单身男“腐败”,严谨点叫团建。还要开技术分享会议。 你要保持谦虚，明白个人能力再强，都不可能解决所有事情，你需要咨询你的组员。再优秀的人都有他的短板，你要做就是把一群互补的人凑在一起，各自发挥优势。 你要给组员尽可能清晰地提供上升阶梯。多年以后，当他成为主程了，你可以骄傲地对他说 我曾经推动过你的进步。 你最好能充分了解你的组员,分配任务要有明确的范围，不能存在模糊地带，要能给与一定的帮助。 你的组员能力不均匀，做事情不要一刀切，换句话说管理要分层, 不同层关注点不同 你是Leader，不是Boss。在雇佣关系中，好人谈钱，坏人谈理想。所以多为组员谋取福利吧。 你其实也是个打工的对项目经理负责，所以要有汇报 谁都不希望加班，但问题总得解决，更要命的是你还不知道怎么解决。咱们程序和美术不一样，美术基本上是工作量的事情，程序会有bug，deadline就在那里，问题还没解决怎么办？ 一． 以德服人而不以技术高管制别人。 主程序一般技术水平高，在管理下面的程序的时候，多以自己的水平高而获得大家的认可，但是技术水平高和项目管理水平高不是同一个概念。一个技术水平高的主程序不一定能管好人，能带好人。如果以技术水平高自居，对下面的人肆意对待，他无法赢得项目成员的拥戴，无法获得大家的认可。程序员不是实现产品功能的工具，他是具备思考感情的人。在我所遇到的主程序中，有的很好，技术水平高，做事分明，不以水平高自居，而以自己的人格魅力赢得大家的尊重；有的则难言其好，技术水平高，但做事有针对性，常以水平高自居，对不服从的人进行压制。不同的风格，会产生不同的结果。我在此想说的是，一个人的技术是不可能永远保持先进性，而一个人的品德则可以永恒的。工作除了满足生活的需要之外，它带给人的还有快乐。一个优秀的主程序，应该公平、公正的对待每一个人，以德服人。让每个跟从的人体验到你不仅仅是技术水平高，人格更高。 二． 自由、共享、开放而不是限制、保守、自封。 主程序在项目中，对核心技术常常保留，隐藏，不公开，以防别人了解，学习，泄露，进而走进一个限制、保守、自封的怪圈。其实技术保留是没有错的，但是在这个自由、共享、开放的世界中，有时候是行不通的。因为中国的程序员有多少原创的技术呢？多是在互联网上，查查资料，共享下别人的经验，然后加以改造，修改，实现功能。每个人都应该很清楚，我们查询的资料是哪里来的呢？是那些有志于自由 ，共享，开放的有识之士发布的，我们从别人哪里学习，而我们为什么不把我们的经验心得也以自由，共享，开放的心态与天下的程序员共享呢？限制、保守、自封不利于技术的进步，不利于人才的成长。如果为限制、保守、自封找个理由，那就是为自己保留饭碗，惧怕被竞争。 三． 优秀的代码不一定创造优秀的产品，它只是更好的为产品服务； 优秀的产品并不一定建立在优秀的代码上，而是建立在市场和用户基础上。一个优秀的主程序，除了做好本身的编程，架构，设计工作外，更多的精力应放在如何设计优秀的产品而不是如何编写优秀的代码，产品是和市场赛跑，产品是和时间赛跑。抓住市场的先机，快速的创造出合格的产品比把心思放在如何写出优秀的代码价值大的多。衡量一个产品的成功，不是靠评价代码的优劣，而是靠是否赢得市场，是否赢得用户的欢迎。主程序常犯的一个错误是这行代码应该这样写，哪行代码应该那样写，完成的功能在不断的修改，修改。时间就这样消磨掉，推出产品上市的日期就被无限制的拖延下去。从而失去了市场的先机，走向失败。所以在我看来，一个优秀的主程序应该能够控制好时间，对市场的嗅觉要灵敏，对用户的把握要准确，只有这样才能保证产品能够在预期内推向市场，赢得成功。 四． 善于接纳意见，切忌专断 主程序有个很大的毛病就是专断，总是相信自己是对的，别人的意见不愿听从。先前曾经和一个主程序做事，他工作大概7年了，经验也很丰富，技术水平也很高。但是他做事的风格让人很难接受，在项目中要求别人必须绝对的服从，不容许有意见。即使项目组成员提出了合理的意见，也只是点头但不当回事。妄自尊大，孤傲自负的主程序，对项目是百害而无一利的。主程序要懂得尊重别人。只有互相尊重才有利于合作的愉快，项目顺利的完成。经验对于每一个来说，都可以随着工作阅历的增长而增长；技术水平也可以随着工作阅历的增长而提高。但是人格魅力，品德修养却非一朝一夕炼成的。懂得如何做人比什么都重要。具有人格魅力的主程序总是得到大家的赞赏。 五． 合理安排任务，不搞个人主义 在项目中，有的和主程序关系不错，主程序在安排任务时就把重要的模块分配给他，让其他人打酱油。这种做法不值得提倡和发扬。公平合理的安排任务，不搞个人主义，这也是对主程序的一个基本要求。从客观的说，项目中人人平等，每个人都应该得到应用的锻炼机会。在不影响项目进度的情况下，我们应该如何合理的安排任务呢？我们应该积极的和策划沟通，对每一个功能点，每一个细节进行衡量，判断所需要的时间，然后分配给项目组的成员。但是有的主程序的做法是自己先列出一个宏观计划，对某某A说，这个月你搞定这个；对某某B说，这个月你搞定那个。这种没有对每一个功能点进行细化的做法的结果就是，项目进度无限制性的延期。经验教训表明：宏观计划和微观计划二者是合而为一的，缺一不可的。 有些人，工作了很多年了，但差不多每年换一次工作，因为很多游戏研发周期只有1年多，结束就走人。然后最后手里会积累大量的代码资源，这些资源有可能是别人的，也肯定有自己的一部分，但是这个时候如果没有融汇贯通，那么这些东西都不是自己的，他手里的资源也就像一个人家里买了很多书但是从来不看一样，暴殄天物，可是一般情况一个人也看不了这么多的东西，最简单的道理就是msdn了，这就有了第一点的要求，能够进行大量的信息索引。就是说一个主程必须要有足够多的见识，同时必须要能够快速针对当前项目碰到的问题定位，并且在自己的知识库里找出来。当然我们不可能储存足够的信息在以后的工作中来用。但是必须要有快速上手一个新的项目的能力，如果项目中有大量的超出自己知识范围的东西存在，那么我的建议是放弃在这个项目中间做主程，因为无法准确评估项目需要开发的时间，无法把握功能难点。 "],["fastjson的key为非字符串的处理","2018年01月01日","/2018/fastjson/","fastjson己然成为最为流行的Json处理框架,今天在处理json的时候发现默认以long型为key时解析会失败,网上搜索无果但最终还是发现了解决方法 fastJson的toJSONString toJSONString有多个重载,默认一个参数的是没有做特殊处理的,也就是说如果key中存在非字符串会解析失败. 处理办法 SerializerFeature这个枚举类有很多选项,从中我们可以找到把非字符串转成字符串的操作. 感悟 总感觉自己能力不足看不懂框架的源码所以不去看,这样技术进步会很慢.遇到问题可以debug跟进源码看一看是什么原因.对解决问题帮助很大. "],["2017年终总结(作为主程的这一年)","2017年12月12日","/2017/summary/","最近忙的真的有点晕头转向的,觉得自己的脑袋不够用了。 今年正月初七上班,初五从家出发。赶上项目上线，从初七开始到现在为止一直没有休息过，晚上回家11到到凌晨2点不等。如果你在杭州，一定会对3.5号晚上的狂风印象深刻，我差点都回不了家。 当时的情况是这样的。。 好在回家比较晚，到家凌晨2点半，回家的时候风己经停了。 好好梳理下最近做的事情（因为明年3.11号要回家结婚被强行催着做）。 游戏系统功能修改 SDK接入（贪玩，上士，9377） 待上线版本性能优化（数据库数据拆分，日志） 充值系统重构 代码优化和BUG修复 装备极品属性系统开发 后台API接口开发（充值，封号，禁言，白名单） 过包服务器的搭建 不知道有没有人体会过，手的速度跟不上思考的速度，敲到最后手腕疼的像搬了很多重物一样。由于睡眠时间不足，整天都是迷糊的状态，再加上公司搬迁，在上班的时候又加喷了油漆，真的感觉整个人都不好了。上班的时候人人都戴着口罩，但是油漆味会完全穿透口罩进入呼吸系统。后来有不少小伙伴买了防毒面具，这也是个神奇的经历了。见下图： 值得高兴了的，千呼万唤始出来，我们的项目终于上线了。因为《蓝月争霸H5》这个项目是我从立项到上线全程作为一个主程的角色参与的，我敢没说有人比我对服务端的代码更熟悉了。所以也有一种特殊的感情在里面，就像养了几十年的女儿终于要出嫁了，也会激动的老泪纵横。也可能是因为这是自己第一个倾注的大量心血的项目，所以会多愁善感一些。真心希望项目能够蒸蒸上，获得该有的回报。项目地址： 安卓下载链接：https://download.tanwan.com/h5lyzbxy/h5lyzbxy_155723.apk IOS链接：https://itunes.apple.com/cn/app/id1296175622?mt=8 web端： http://h5.tanwan.com/game/?id=490 这是一款传奇题材的egret + java 开发养成类挂机游戏,算是弱交互的rpg游戏，有传奇情怀的玩家可以玩一下(比较烧钱)。 从前年开始断断续续开始学日语，从一开始的单纯喜欢日漫到后来去日本旅游后喜欢日本的文化，喜欢这个国度。因为工作占了整个生活的绝大部分时间，导致学日语的时间很少，连续考了2次N2都没过，开始有点沮丧了，但是我绝对不会放弃的。几十年来坚持下来的两个兴趣：编程和语言(日语/英语)，我会一如既往的坚持着，N2,N1，流畅自如。已经3月了，我准备继续报6月份的考试，给自己一点动力。活到考，学到老。让我秉承着这一信念一直下去吧。工作上来说，时光荏苒，一晃已经工作了3年了。从最初的小菜鸟到现在能够独立带项目，把自己的经验和心得教给自己的组员，而且大部分组员学历都比我要高，更加促使着我不断学习。在项目开发期间不断的有猎头和阿里/蚂蚁等公司看到我的github之后联系我问考不考虑换工作，我都以项目太忙为由回掉了。不过有次阿里的技术找了我几次也比较好奇阿里需要什么样的人就同意了下电面。本来因为一点准备都没有，而且自己能力上的不足被狠狠虐了一把（问的都是一些实现原理，jvm优化,mysql性能调优相关的连环炮就不展开说了，有兴趣可以加我详聊）。感觉自己现在的能力勉强能达到阿里P6的标准？我自己也不知道，我只知道自己需要学的东西还很多。而且随着工作时间的增加，这种感觉越明显。2008年暑假买了C语言的书来看，看的一知半解。大学期间自学java,写了无数遍的hello world 不知道到底能做什么。15年毕业之后正式入行，夜夜在慕课网/极客学院/传智播客等自学网站长期霸榜，仿佛回到了高三那一年充实无比。也庆幸自己不算懒惰，使得不算聪明的我在互联网行业站稳脚步。每当有同事知道我是文科出身，半路出家都一脸惊讶。我觉得没什么了不起的，因为我不想像我同学一样没有一技之长只能去当客服。我向往远方，去了解未知的事物;梦想着环游世界，走遍每一个角落。希望自己有生之年能够财务自由，是为了兴趣而活，而不是仅仅为了生存。 2015年大部分时间在看java web,沉迷于框架不能自拔。学习spring,mybatis,spring boot ,hibernate等各种框架的使用，从来没想过实现原理。2016年迷上所见即所得的前端，在空闲时间研究html,css,scss,less,gulp,webpack,angular等前端技术，发现前端并没有想像中简单，现在的前端已经不是以前那样照着psd写写静态就可以了，浏览器适配，首屏加载，代码混淆，编译等新名词不断出现，感觉像发现了一个新的世界。2017年公司新项目立项，我有幸担任主程一职，开始了解游戏的整体框架和底层依赖jar包源码。2017年我对java的使用理解更加的深入，开始有意无意的去了解更底层的一些东西。开始研究 设计模式，代码重构，代码整洁之道，netty实战等相关的知识。能够用一些简单的设计模式思想去解决问题，养成了代码优化重构的习惯。能够快速定位问题并解决问题，对业务需求得心应手。我想这就是能力的快速提高吧，感谢我的领导对我的信息和栽培，让我有机会接触到这些东西。2018年，我想我会回归到java的jdk上来，去看一看优秀的jdk源码。自己去实现一个迭代器，或者自己实现在一个hashmap之类的东西，不能只知其然而不知其所以然。最后我希望2018我的个人能力能够进上一层楼，在杭州安个家。 "],["StackOverFlow提问的艺术","2017年11月11日","/2017/howtoaskquestiononstackoverflow/","stackOverFlow现在不仅是一个社区，更是一个程序员的聚集地，就像古代高手云集的江湖。合理的使用它不仅能够方便自己，更能够帮助别人。我最喜欢的两个网站:github 和stackOverFlow 提问相关 可以问什么样的主题 大家都知道 Stack Overflow是编程类的问答社区， 但还真有人把它当成通用的问答社区了， 问些完全无关的问题。 其实， Stack Overflow 是有一系列兄弟网站的（目前已经有100+)， 统称 Stack Exchange， 涵盖很多主题， 比如数学、物理、化学等科学类， 服务器管理、Latex、数据库等计算机类， 中文、俄文、日文等语言类， 详细的列表看这里， 不要让好问题问错地方哦。 允许的主题包括： 具体的编程问题、软件算法相关、通常只有程序员用的软件工具相关等。 有些主题是比较容易弄错的， 比如一般的电脑操作问题， 应该去Super User(热门的 Linux/Unix, 和Ubuntu还有独立的站点）， 专业的服务器问题， 应该去Server Fault。这些都不属于编程类的问题， 尽管不少程序员的日常工作也有涉及（想一想“怎么修电脑？”属于编程问题么）。 再举个例子， 同样是编辑器， Vim/Emacs/Atom相关的问题是可以的，因为基本只有程序员会用这些工具， 而 Word/记事本相关的一般就不可以。 什么样的问题应该避免问 编程相关还不够， Stack Overflow 要求问题必须是 「practical, answerable questions based on actual problems that you face」。 这是什么意思呢？ 首先， 开放式的问题是不允许的，比如“你为什么喜欢PHP?”， 隔壁Quora会是更合适的对象。 其次， 问题应该不需要很长的篇幅来回答， 如果一个问题期待的回答足够写一本书， 那很可能会被关闭的。 各种寻求资源的问题应该避免，如 “要完成某某工作， 有什么Python的库可以用”， 或者“学习C++应该选择哪本书？”等， 因为答案会主观， 也容易吸引广告。 最后， 问题不要基于凭空的假设，要基于实际的难题。 需要注意的是，你很可能见过一些违反上面规定的问题还在，而且浏览量很大， 尤其是一些寻求资源的问题， 和非编程相关的计算机问题等。 这是什么原因呢？ 原来，早期的Stack Overflow的规则还比较松，也没有Super User之类的站点。 这些问题往往是08/09年问的，大多数现在已经被关闭了。 上面的规则如果遵守， 你的问题应该问对地方了。 下面继续说说内容上具体需要注意的。 直入主题 Stack Overflow不是论坛， 它的目标是希望成为编程类问答的一个超级数据库， 所以每个问题都不止是为了帮助提问者本人， 更重要的是希望将来能够帮助到每一个遇到同样问题的人。 所以， 和问题无关的内容都被认为是一种噪音， 包括： 打招呼（比如 Hi, Hello， Good afternoon， Dear Coders等)， 表示感谢（比如 Thanks, Any help would be appreciated等)， 没必要的背景（比如 I’m a newbie in C#等)， 你的签名 等。 可能有人会不理解为什么这样规定， 尤其是不要表示感谢这点。 Stack Overflow社区的理由是， 对愿意阅读并尝试解答你问题的人来说， 最好的表达感谢的方式是upvote有帮助的回答， 以及选择其中一个作为答案。 每一句和问题无关的内容都增加了额外的阅读时间， 而一个问题可能会被大量的人阅读。 更多的相关讨论可以参见这里和这里。 同样道理， 当有人回答你的问题之后， 也不要去添加无用的评论， 比如单纯的表达感谢的话， “+1”， 或者闲聊等。 评论的唯一用处是用来澄清疑问。 英语 作为一个英语社区， 不论提问、回答还是在评论中和别人互动， 都是要用英语的。 除非英语水平真的很糟糕， 语法其实并不是最需要担心的，因为并不需要做到完美。Stack Overflow是允许自由的编辑其他人的问题/回答的（编辑者如果rep不到2K，需要经过评审才会生效）。 有很多人会热情的对问题进行编辑的， 包括修复可能的语法错误。 我想说的一点是， 要尽可能的保证单词拼写是正确的。 即使对英语不够好的人来说， 这也只需要多花一点时间检查就可以做到， 但它代表着对阅读你问题的人的尊重。 甚至很多英语母语的人在拼写上也不注意， 会把I’m 写成im, 把 want to写成 wanna之类的非正式英语， 这些都会降低问题被回答的概率。 内容 在发问题之前， 问自己几个问题： 你做过足够的研究么？ 有的人连入门指南都没读上10分钟就去提问， 问的问题能有多少价值呢？ 你尝试过搜索么？ 至少要试过Google和站内搜索， 很可能相同的问题已经有答案了 你试过debug么？ 把你的想法或调试过程写在问题里，否则很可能会看到几条评论“Have you tried anything?”或“We don’t do your homework”之后问题就被downvote得惨不忍睹了。 因为大多数人是拒绝回答没有努力尝试的提问者的。 标签： 一个问题可以加1~5个标签， 大多数问题是和某种具体的编程语言相关的， 这个语言的标签通常是必须的， 否则相关语言的关注者们很可能根本见不到问题。 起一个好标题 一般来说， 标题应该尽量用简介的语言描述具体的问题。 比如 C# number confusion就是个反例， 如果改成 Why does using float instead of int give me different results when all of my inputs are integers? 就要具体多了。 提供代码 对于编程类问题，的确有问题不需要代码也能表达清楚的， 但大多数问题都需要代码才能清晰的表达。“我声明了一个变量， 调用了几个函数， 然后它的值就变了， 为什么呢？” 这样的问题， 鬼才知道答案。 提供代码要注意： 不要贴截图， 难道你要回答者去照着截图敲键盘复现你的问题？ 也不要只贴站外的链接， 如果站外链接能够提供一些额外的方便功能， 也要在贴代码的基础上附上该链接。 对于提供什么样的代码， Stack Overflow给出了一个可参考的标准： MCVE， 即Minimal, Complete, and Verifiable example Minimal: 最小的， 也就是尽可能的去掉和问题无关的部分。 如果你贴了一个几百行的代码， 很少有人愿意花时间去仔细看。 构造最小化例子的过程本身也是debug的过程。 Complete: 完整的， 一个简单的判断是：别人看到问题， 可以通过复制你提供的代码复现出问题吗？ Verifiable: 可验证， 描述问题尽可能具体， “the code doesn’t work”这样的描述就很不好。 如果编译不过， 要加上编译错误信息； 如果运行报错， 也同样要加上具体的错误信息； 如果结果和你的预期不一致， 要说清楚你的预期结果是什么， 为什么会这样想。 格式 Stack Overflow的编辑器是Markdown格式的， 如果你还不熟悉， 建议去学一下， 因为Markdown真的是一个只要10分钟就可以学会的语言。 大多数的格式问题都是出在贴代码的地方， 如果你发现你的代码是普通文本， 而没有语法高亮等功能， 那你很可能是格式搞错了。 最方便的方法就是选择所有代码， 然后按键盘Ctrl + K 即可。 交流 有可能你的问题几分钟内就会有人回答， 也有可能有人对问题有疑问， 在评论中要求你解释。 可以评论@他们解释， 如果问题确实不够清晰， 编辑你的问题吧。 最后， 如果你自己发现了解答方法， 而还没人给出， 那就自己回答自己的问题吧。 自问自答是被鼓励的行为。 结语 看完上面我的唠叨， 是不是也感觉到Stack Overflow对新手的不友好了呢？ 但这是保持高质量内容的代价之一， 必须有一定的机制让低质量的问题不会泛滥， 才会有更多的人愿意花时间回答好的问题。 希望大家都能得到自己问题的答案， 有机会再讲讲如何回答问题。 提问前的自问 提问之前你做过研究吗？ \u0026lt;注1\u0026gt; 你是否说明了自己试过哪些方法解决问题？ 你说明你使用的编程语言/平台了吗， 包括版本号？ 如果你的问题包含代码， 你是否已经改写成最小且完整的程序？\u0026lt;注2\u0026gt; 如果你的问题包含代码， 你是否检查过代码格式？\u0026lt;注3\u0026gt; 如果你的代码不能编译， 问题中是否包含了编译错误信息？ 如果你的问题不包含代码， 你确认不需要吗？ 如果你的程序抛出了异常， 问题中是否包含异常信息和堆栈回溯(stack trace)？ 如果你的程序的输出结果和预期不同， 你是否说明了你的预期结果是什么， 你为什么这么想， 以及程序的实际结果？ 如果你的问题和本地化有关（语言，时区等）， 问题中是否包含了相关的信息？ 你是否检查过问题的格式是否正确？ 你是否检查过拼写和语法？\u0026lt;注4\u0026gt; 你是否认真读过自己的问题， 确认问题对一个不了解问题背景的人也能明白? 如果以上任何一个问题的答案是否定的话， 很可能你提问前需要再修改一下问题。 我知道这听上去像是不少工作， 但它能帮助你尽快的得到答案。别忘了你是在请求他人用自己的善心帮助你， 你有义务让他们的工作尽可能的简单。 注1： 如果你从“这怎么不工作了”到“应该去问个问题”只花了不到10分钟， 那很可能你的研究还不够。 注2： 理想情况下， 你的代码应该可以让回答者复制， 粘贴到编辑器， 编译， 运行， 然后就能看到问题输出。 命令行程序适用于这样的标准（除非你的问题和用户界面有关， 最好用命令行程序）。 去掉任何和问题无关的代码， 但保证可以复现问题。 注3： 代码最好不需要水平滚动， 这可能需要你从IDE复制代码之后做些额外的处理。 为了那些愿意帮助你的人花点时间把问题表达清楚吧。 注4： 我明白很多Stack Overflow用户母语不是英语， 我们并不要求完美， 只是希望你做过努力。如果你清楚自己英语不好， 找一个同事/朋友帮你改改吧。k 答题相关 想法的萌芽 如果非要总结下我多年来是如何使用Stack Overflow的话，我的答案就是：打开网页，搜索问题，查看Stack Overflow的搜索结果，参考答案，最后再关掉网页。 我的生活已经离不开Stack Overflow了。但我从来没有对那些有用的回答做出过反馈，更别提自己提问题和回答问题了。 不过我最终还是意识到，Stack Overflow的成功正是建立在其众多用户的慷慨解答上。我从这个网站上收获了很多，却从未做出回报，因为没有任何人、任何规则的约束。每个问题、每个答案或者每个有帮助的评论的出现只是因为某人慷慨的写了出来。诚然，Stack Overflow也有一套激励机制去帮助它的发展，且用户获得徽章和威望的多少也是个未知数，且通常由其他用户决定。例如，如果你提了一个问题或者回答了一个问题，没有人有义务去赞同或者反对你。 多年来，我一直受益于它，但未对它尽过绵薄之力。我在网站上找到过一打有帮助的答案，但我甚至不曾为它们点个赞。 是时候回报Stack Overflow了！ 目标 某天我在浏览徽章列表时发现，可以通过连续30天访问网站而获得一枚银色勋章。于是我决定将这个作为我的目标，通过30天不间断地浏览网站并且达到1000威望值。但我将只回答问题而不提问。 完成情况 正如下表所示，我只能算是勉强完成目标。 尽管我发现在访问量达到200的时候就会有100点威望值的福利作为回报，但是我也依然有一整个星期都颗粒无收的瓶颈期。理解并回答问题无疑是一个缓慢并需要一定方法的过程，要想达到我的目标，至少需要每天30点左右的威望值进账才可以。 ##经验之谈 Stack Overflow看起来就像一个纯粹的问答网站，但在我花了30天沉浸在回答问题的过程中后，发现了网站本身以及它所形成的社区的一些微妙的特点。以下是我所学到的一些： “摘樱桃” 没过多久我就发现了网站上用户提问的速度之快。而我每天要做的只是：每小时花上几分钟刷新下问题页面，随机淘汰几个简单、不圆满的答案而已。除此之外，网站上的一些友好（有时并不十分友好）的竞争状况也显而易见。 我从择优的过程中学到了很多。 首先，确保你理解了问题。读完整个问题并且明确提问者想要的答案。如果你没有理解的话那么在评论中礼貌的问清楚。阅读标签也同样重要。不止一次我错误的回答了一个问题只因我自己假定了提问者所用的环境，显然这种情况可以通过阅读标签避免。 其次，不要为了快点回答问题而牺牲了答案的质量。错别字和语法错误不会对任何人有帮助，并且这些都可以通过放慢回答速度以及在提交答案前检查一遍来避免。换一种方式来说：拥有良好的书写格式和完整的答案更容易得赞，而残缺的答案自然不会。不要只为了回答问题而写一个快速但不完整的答案，然后不得不忙着补充忘记的点。我见过太多这样的答案，这样做也只会招来其他用户甚至包括操作员要求更多的解释。这种行为明显不利于用户提问和回答的发展。 最后，如果你正在撰写一个答案，一定要看一下已经存在的答案。如果你的答案和别人的几乎一样，那么你只需为别人的答案点个赞。如果他们的答案中缺了某些方面，那么你只需要在该答案的评论中去补充一下就可以了。 求助吸血鬼 Stack Overflow上有一群被称为”求助吸血鬼”的人。这些用户以“从不放过任何机会获得别人的帮助 “而闻名。这种现象一直存在，可我一直不知道他们甚至有个专属用词，直到某天有个用户斥责一位问题提问者为“求助吸血鬼”我才知道。 我就曾经为几个看起来像“求助吸血鬼”的用户回答过问题，接着就一发不可收拾了。他们通常采纳了我的答案接着在再答案下留言问一些新的毫无关系的新问题。 我的处理方式就是（建议其它用户在遇到这种情况时也这样）：写一个评论告诉用户他的所作所为是不对的以及应该怎么做。当时我就建议他去Google一下这个新问题，如果找不到想要的答案再来Stack Overflow上问一个新的问题，而不是在一个用户的答案下不停的问一些毫无关联的问题。 上面给出的Meta Stack Exchange链接上提供了很多在遇到这种求助吸血鬼时的有用回应。我还想说的一点就是，当普遍认可的答案却得到质疑时，首先应该做的是在该问题下做出评论，解释提问者可以自己修正这个问题。给用户一个改正自己错误的机会。这样的话，用户可能更能从这个网站上学到新的东西，你甚至还能为网站审核者节省时间！ 卖弄狼人 卖弄狼人，我专门为与“求助吸血鬼”所造的名词。对于求助吸血鬼们来说，这些原本可能善意的用户简直就是恶魔的化身。 当我发现求助吸血鬼的现象越来越严重的时候，有些用户采用粗暴且无用的方法制止他们。卖弄狼人们通常这样说：“这明显是一个家庭作业水平的问题”，“你难道都不试着Google一下么”，“不要问重复的问题！”。当我完成我的30天目标时，比起求助吸血鬼，我更烦这些卖弄狼人。 我想对这些人说：请回答的更具建设性和有用一点。为提问者提供更常规的答案。我的这些建议对提问者也同样适用！如果你遇到一个卖弄狼人只需要忽视他们就行，树立一个好榜样，不要在评论里面针锋相对！ 关于反对票 在这30天里，我一直尽我最大的努力为提问者做出一个好的、详细的答案。但是有时候会出现这样的现象：某个我的被采纳了的答案竟然没有一个人赞同，反而都是反对。 这些否定深深得伤害了我。那些不赞同我的答案的用户都没有解释原因，甚至在我追问后也没有给出回答。我的答案被接受了，显然对于提问者来说这是一个好答案，但是我至今不懂为什么有那些反对票，甚至让我丢了两点威望值。 Stack Overflow上并没有强制要求你在反对某个答案的时候解释原因，这样郁闷很久后，我觉得网站应该这样有这样的机制。在一个反对票下做出解释是体现网站人性化的一面。 如何人性的在反对票下留言呢？我想了两种方法： 如果有人已经在反对票中的评论解释了为什么投反对票，那么你只需要赞同一下这个评论就能引起回答者的注意了。 如果没有人解释你投反对票的原因，那么就在评论中写出问题或者答案需要改进的地方。 声明： 我只是个萌萌的搬运工，待我也在stackOverFlow上修行完成之后再来谈自己的经验。 相关文章 玩转 Stack Overflow 之提问篇 泡在 Stack Overflow 答题的 30 天 国内为什么没有好的 Stack Overflow 的模仿者？ Stack Overflow 2016最新架构探秘 CODE Keyboard：Stack OverFlow 联合创始人亲手操刀的极客机械键盘 为什么离不开 StackOverFlow？ 提问的智慧 "],["java的oracle考试认证(OCJP)之路","2017年11月11日","/2017/oraclejavasesliver/","最近几天准备了一下java的oracle认证考试(OCJP),在网上查找资料奈何国内基本没太多有用的信息,还是费了一番功夫. 为什么我要参加这个考试 有朋友建议我考一下这个证书,所以我花了些时间上网查了相关的资料.虽然国内的网上一大堆评论都是没什么用,含金量不高之类之类的.但是它毕竟是oracle的官方认证,我的动机大致如下: 我本来就是半路出家,再静下心来过一遍java基础没什么不好,在这过程中我又巩固了不少知识. 虽然国情如此,但是有出国意愿的话这个证书还是很有必要的. 什么是 OCJP OCJP(Oracle Certified Java Programmer)是Oracle认证的Java程序员的简称，即Sun被Oracle收购之前的SCJP，是Java语言的拥有厂商对全球的Java开发人员进行的 技术水平认证。该认证在国际上获得了IT 公司的普遍认可， 是目前国际上最热门的IT认证之一。 考试内容 青铜级考java基本语法 白银级考java基础api 黄金级考java高级api 推荐 《thinking in java》,很好的一本书. 我的网盘上存的有 pdf版本: http://online.xiaomo.info 该考哪个科目 oracle认证的科目繁多,让人看花了眼而且没有说明,这让很多想考scjp的朋友急坏了头,下面是我整理的科目 说明:ocjp考试认证分为3个等级:青铜白银和黄金(听起来像是lol),只有黄金有前提条件(必须先拿到白银) 建议:因为题目比较基础,建议直接报白银,如今java9都出了,就不要再考6或7了,不然还得再考一次升上来 结论:报1Z0-808(全英文题目),我报的是1Z0-808-JPN(全日语),题目内容都是一样的 可点击此链接查看具体规则(抱歉没找到中文版): http://www.oracle.com/jp/education/certification/jse8-2489021-ja.html 考试费用 以上所有的报名费用都是158美元,大概在1077rmb.但是报名缴费只支持master card,jcb或者visa卡,我请日本的朋友刷jcb代付的. 淘宝上代付1150-1200之间 报名地址 注册一个 person vue 账号,然后根据步骤走就可以了. 遇到问题可以看这个 OCJP考试VUE约考流程 ,oracle认证全球有很多地方可以考试,比如说我在杭州来说,最近的离我只有3公里. 考试流程 报名之后按照指定时间提前15分钟到达考点,需要携带身份证和一张辅助证件(驾驶证,信用卡,市民卡等都可以) 验证身份证件和拍照认证 填写一个声明,关于不能作弊,不违反规则之类的东西 把身上所有的东西掏出来放到柜子里锁起来,考试时只能带柜子上的钥匙 小姐姐会给一个手写板,一支笔和纸巾进入房间答题(没人监考,但有监控,不要作弊). 上机考完1Z0-808所有题目(77题),共150分钟答题时间(可提前交卷) 交卷时前台小姐姐那里会同步打印一张回执单,告知你30分钟之内oracle会发邮件通知考试结果 考试结果 收到的邮件内容: 登录之后查看到的考试结果: 通过考试之后会得到一个徽章和电子证书 证书 徽章验证地址 : Oracle Certified Java Programmer, Silver SE 8 (Oracle Certified Associate, Java SE 8 Programmer) - JPN 补充:2017-12-27 时隔一个月左右,我再次报了OCJP的 1z0-809-jpn科目.这个科目对java8的很多新特性都考察到了,个人觉得还是挺有难度的. 大致说明 价格和808一样 地点和上次一次 题目内容为85题,答对65%及格,也就是最少要答对56道题. 考试结果 当然是考过了,O(∩_∩)O哈哈哈~.不然就浪费了1000多的报名费 证书: 徽章验证地址: Oracle Certified Java Programmer, Gold SE 8 (Oracle Certified Professional, Java SE 8 Programmer) - JPN cclaim "],["安装黑苹果的历程","2017年11月11日","/2017/blackapplesystem/","最近新买了一台主机，折腾着准备装win+mac双系统，记录一下以备后续需要。 准备工作 MSDN上的win10原版镜像 带有winPE的装机U盘(大白菜，老毛桃都可以) transMac mac镜像 确认自己的电脑是否支持UEFI模式 转换分区格式 因为准备装10.13.1原版镜像，所以需要GRID(GPT)分区，查看步骤：我的电脑-设备管理器-磁盘工具-选择硬盘0或者磁盘1（这里不要选择分区）-右击属性-找到（卷）我们就可以看磁盘分区形式：GUID 分区表（GPT） 如果不是GRID，那么就插上U盘进入winPE，用DG分区 1、我们选择我们的系统磁盘。然后右键里面有一个转GPT格式后保存 2、选择C盘，右键然后选择“调整分区大小”，拆分一个300M左右的分区 3、新建分区，选择EFI类型，大小为300M 4、 保存重启 制作Mac镜像 插入U盘（插到USB2.0接口），在U盘选项上右键点击你的U盘。选择Format Disk for mac将U盘格式化。 右键选择你的U盘。选择Restor with disk image. 选择下好的dmg镜像。 安装镜像 选择从UEFI的u盘启动，然后苹果读条之后选择 安装系统。 选择磁盘工具，格掉要装位置的磁盘。（扩展日志格式） 选择安装mac到磁盘。 按照流程安装，整个过程需要重启3次。 安装驱动 驱动太难装\u0026hellip;\u0026hellip;\u0026hellip;.. 参考教程 macOS High Sierra 10.13.x 最新黑苹果原版安装教程 "],["日本游记","2017年10月10日","/2017/japantravel/","日本游记，记录为期9天的日本之旅。第一次出国，便是自由行。有人说是艺高人胆大，我倒觉得是难得自由。下次出去玩，我还是会选择自由行。所有照片放在空间相册日本之旅 行程前的准备 护照(200RMB一本) 一般来说是在户籍所在地办理，用时1周左右，可以自取和邮寄。 签证(旅行社代办300RMB) 自己办需要的材料比较多，觉得麻烦可以直接找代办，就是价格稍贵。 住处(airbnb,booking) airbnb是民宿，booking是酒店，如果是一行人的话住民宿会比较划算。 JR PASS(1600RMB) 可以乘坐日本所有的JR,如果行程规划只是在一个城市就没有必要买，因为我们要去富士山和大阪所以买了会省不少钱。 机票 买的春秋航空的廉价机票，往返2800/人。如果是平日只需要一半左右，国庆期间出游的人太太太多，所以溢价不少。 电话卡(WIFI) 直接买了1张可以使用一周的达摩卡（建议1人一张），不买4g卡可以去机场租wifi。 google地图 人肉翻墙终于可以看看墙外的世界了,让google地图指引你前进的方向吧。 日元 怎么说呢，日本习惯用卡和现金，所以备点零钱去了刷银联也可以。但是钱嘛多带点毕竟有安全感（日本的治安不用担心钱的安全问题） 一个18到24寸之间的密码箱 去的时候尽量留空，因为回来的时候根本不够装啊。 行程 9.27 杭州-上海-东京 中午从杭州出发，5点前到达上海浦东机场办值机登机，7点左右出发。 晚上11点左右到达东京羽田机场，然后万能的淘宝接机送我们到住处——浅草，因为日本是右舵靠左行，开着100多的速度一路上看着感觉好惊险刺激，总觉得要撞上了，不过我的担心是多余的。到达浅草大概夜里12点左右，并且在下雨，装上达摩卡打开google地图。为了找住的地方绕了有半个小时才找到位置，心情不是很美丽，不过到了住的地方老婆还是很开心，暖心的微笑。 9.28 浅草-浅草寺-上野-银座 睡到自然醒，然后去浅草寺逛了好几个小时,在路上偶遇现场的幽默剧表演，老婆看的入迷拉都拉不走。不得不说在东京的外国人真的超多，中国的，韩国的，美国的，印度的，非洲的各种都能遇到，走着走着遇到一个韩国人搭讪让我帮忙。他们应该是家庭出游，一家人说了一大通听不懂的话然后站在一起让我拍照。到中午了，在日本吃的第一顿饭真是一言难尽。点了一份荞麦面，腥味重的可怕结果一点都没吃，后来去超市买了一大包零食。 有家店门口有个大青蛙，还挺萌的 浅草寺，就在我们住的地方旁边，还是挺热闹的，还遇到了一家子韩国人让我帮忙拍合照。 浅草的纪念品，然而我都没买 在东京见到了久违的黄包车，还存在这个东西有点让我惊讶 下午坐车去上野换JR PASS,决定换到从9.29-10.5号期间的票。 上野JR站，我们的JP PASS票就是在这里兑换的 之后坐车去银座逛商店，不得不说银座的建筑真的超级漂亮，地上找不到垃圾也找不到垃圾桶。银座应该算是有钱人的天堂吧,各种东西超级贵，逛了一下午没找到一件能下手的东西，穷人真的是很难过的说。 银座繁华的商场 偶然遇到一辆日产的火红跑车，亮瞎了我的眼 sony大楼里的高科技，投影出来一个可点击的android的操作系统桌面，可以把任何地方当桌面用。 银座大黑屋，听说还挺出名的 因为中午的阴影，晚上吃饭在麦当劳解决的。不用怀疑，麦当劳和肯德基在全世界都是一个味道。晚上我们比较早就回住处了，不过同行的小伙子去了居酒屋去玩到半夜1点多才回。 一个麦当劳套餐 看板上的广告都有这么萌的妹子，忍不住拍了一张 9.29 浅草-富士山 到日本玩不到富士山难免是一场遗憾,所以决定今天去富士山去玩。查了路线大概有150公里，需要3个多小时才能到。再加上出发的时间比较晚，到达富士山的时候己经下午了，因此没有爬山。只是在富士山下玩顺便吃了顿饭便开始返回。 9.30 浅草-秋叶原 今天在日本名古屋工作的朋友知道我们在东京便一起出发找我们一起玩，我们约定在秋叶原汇合，同行的另一个小伙伴要去买小学生书包我们便分头行头了。 秋叶原的入口，进一步便是宅男天堂 JR秋叶原站，旁边也有地铁站 来到了传说中的宅男天堂，不过里面真的有好多化妆品啊，结果大部分时间都是陪妹子逛各种化妆品和药妆店。当然也去看了手办，本来打算帮同事带高达，不过找了很久都没有找到想要的那一款。 巴比娃娃 动物王国 扭蛋机，比我在杭州国际动漫节玩的扭蛋机要便宜，这边的商店到处都有扭蛋机。 在秋叶原体验街机的父子 你的名字相关的名信片，不知道去哪买邮票就没买 ps4版的初音，买不起 同事让我帮忙找高达，都是这种小个子，我想要一个同人的大家伙。 本来以为是个卡哇伊的小女孩，走近才发现是个洋娃娃 洋娃娃正面照，很精致 音乐猫，每只猫捏了都能发出不同的声音。 遇到一个萌出血的双马尾妹子 忍不住又拍了一张 10.1 东京-大阪 今天出发去大阪，坐了2个多小时的JR终于到达大阪，买了一张2500yen的大阪周游券。 一日游的卡 附带了这么大的一本说明 然后下了JR拿出地图寻找住处，然后突然伸出一个头看我们的手机，被吓了一下，结果是个热心的小伙子帮我们指路，语速超快，听的我们一行人n脸懵逼，然后带着我们去地铁站排队叮嘱了一大串才离开。不仅感慨大阪民风淳朴，热情好客，弄的我们都不好意思了。跟着google地图到来住处附近徘徊，遇到一个老太太，带着比较重的关西口音问我们要去哪里，然后她佝偻着身子一直带我们到住的门口，感动的无以言表。由于初到大阪，决定放好行李之后出去熟悉一下路线。正好我们住处的旁边有一条商店街。因为是周末过去的，所有有好多店关都关着的。我们沿着这条街一直走，都没有遇到几个人。不禁在想，如果是在国内一定是人从众众众 吧。 在路上偶遇中年夫妻开的中华料理店，不由自主的便进去了。点了好几个家常菜和老板娘说了一路的日语。结果点完菜她用浓浓的东北口音给她老公说话，真是蜜汁尴尬。 日本的中国饭店还是挺多的 吃完饭去逛大阪的药妆店，不过买的东西并不多。后来非常后悔，因为大阪的东西真的比东京要便宜不少。回去的时候就买了一大吃零食和水果，如果能反悔，当时一定要在大阪把想买的东西都买了，可以省不少钱。 大阪商店街，一共有1-9条街 由于逛的比较晚，准备回去的时候己经快夜间12点了。偶然抬头看着天空，简直把我惊到了，明亮的月亮加上白色的云，我发誓这辈子没看到过这种景色。 如果在这种地方生活，一定会多活很多年的吧。 10.2 大阪一日游 早上一大早起来，很不幸外面下起了雨。不过既然买了卡我们依然按照原计划去大阪城玩。第一站：通天阁，高度500多米,站在塔顶能够看到大阪80%以上的建筑，如果是晚上看的话一定很漂亮。 站在500多米的观景台上看下面的景色，白天一点都没有感觉 对面的塔晚上会很漂亮，白天完全不行 观景台楼下的迷你大阪城，精致到看每个人都栩栩如生（白天）。 观景台楼下的迷你大阪城，精致到看每个人都栩栩如生（夜晚） 也不知道这个铜人叫什么，反正很出名就是了 纪念章，500日元一个，可以刻字 带着这么萌的包出来心里没点数么。 在这里还偶遇猴子表演，确实还挺有意思的。这里有很多土特产，不过让人心动的倒没遇到。在商店逛的时候遇到了假的白色恋人巧克力，名字叫《面白い恋人》真正的是叫《白い恋人》，小伙伴们要注意分辨。如果要带白色恋人巧克力去机场免税店吧，别的地方都是假的。 第二站准备去大 天王寺动物园 ，结果去了被告知今天休息（详情看大阪周一休园 ),整个人瞬间就不好了。 很可惜天王寺动物园周一休园，只能在门外拍张照表示来过 然后去下一个游玩点 坐轮渡,全体披着雨衣坐观光船还是很壮观的。最前面有个导游顶着雨铿锵有力的解说着各个景点，不得不佩服日本人对工作的敬业态度。 第三站去了天保山坐世界上最大的摩天轮，为了排队透明舱多等了半个多小时，坐上去的时候并没有特别刺激的感觉，当升到顶的时候看风景是很漂亮的，如果想刺激去大阪影视城坐过山车挺好的。 来到了世界上最大的天保山摩天轮，还下着小雨 在摩天轮上看到外面的玻璃都是水 从透明仓底部拍的比较清楚 晚上的摩天轮果然最漂亮 第四站坐游轮看了个各个码头的集装箱和两岸的风景，还可以把天保山摩天轮做背景拍照。 这个大妈指着让我去坐圣玛利亚帆船 在船上看摩天轮依然这么大 江对面的工厂 帆船走远了，摩天轮越来越小 大概有这么大 对面的码头很热闹，很多集装箱。想到了docker\u0026hellip;，程序员的思想跳跃就是大 最后一站去空中展望台依旧不营业，真是罪过，错过这么多景点。由于一直下雨身上也淋了雨我们就准备回去休息了，不过老婆看起来玩的还挺开心的,在回去的路上也拍了几张。 在大阪的街上闲逛 开这么萌的车出来会被打的 10.3 大阪-奈良公园 同行的小伙伴觉得奈良太远便去了大阪影视城玩，我和老婆便坐JR去了奈良。 这个是小鹿的人偶店 奈良的人真的很少，我们下车之后一度认为走错了位置。 这个其实是一个古代名人的后院 一路问奈良公园的入口在哪，被问的人都一脸懵逼的看着我，说这边一大片都是奈良公园，然后走着走着看到一个门收费200日元我们便进去了，进去才发现是一个古代名人的后院所以我们准备直接出来，那个收费叫知道我们走错地方还准备退我钱我谢绝了。后来走了很久看到一个地图才恍然大悟，奈良是免费的没有设立入口,从哪都可以进。 在去公园的路上遇到了一个湖 在公园见到了传说中的小鹿，喂它吃东西还会点头表示感谢。遇到这么萌的小鹿真是太高兴了。 一只鹿 在公园门口穿和服的女人 中午饭了就在景区吃饭随意找了一家荞麦面馆。按照中国的习惯我己经做好了被宰的准备，但是很意外的价格很亲民，吃饭的时候我们迎面看到了一座特别漂亮的山然后忍不住问店员能不能爬。然后热心的老婆婆拿了一张地图过来一边讲一边画路线，标记上哪一段路程大概花费多少分钟，简直无法表达感激之情。 对面的房子是春日大社，久仰大名 吃完饭按照老婆婆的线路图往前走，看到了传说中的春日大社和美术馆，因为被山上的景色吸引我们便没有多做停留直接往山那边的方向走。 从这条路可以上山 爬山前管理员细心的告诉我们要准备点吃的和喝的，用蹩脚的英语说 no drink,not shop。听了好几遍才反应过来她说的什么意思，有时候不同的语言表达真是太有意思了。爬山的过程的辛苦的，但是爬到一半的时候回头看山下的景色，看起来真是太惊艳了。 下过雨的松树看起来很绿 在半山腰感觉己经挺高了 在山上的各个地方都能看见小鹿，悠闲的吃着草，想起了小时候在山上放牛的日子。 在山上感觉整个人都是轻松的，不用考虑工作，不用考虑生活，这一刻静静的享受这美景。 在半山腰看大阪城 顺着这么路可以继续爬山 半山腰的检票口，遇到两个美国人 在山顶看大阪城 有个大概70岁左右的老爷爷坐在山顶的长凳上休息，真佩服他们的体力 老婆在山顶上高兴的撒欢子跑 在山顶上睡觉的老外，他老婆抱着孩子跑的我都看不到了 下山的路 再看一眼风景 长的奇怪的树 下山了 遇到很多来若草山玩的小学生，一个个的都好萌 从奈良回来己经8点多了，由于第二天准备回东京所以趁晚上再出去转转买个PS4玩玩。到电器街的时候大概9点多了，发现各个商场都在准备收拾关门了感觉很遗憾。老婆一直说再找找，我们就一直逛终于遇到了一个卖电子设备的店没关门。大阪和东京的商店的区别是东京大部分店都有中国店员，但是大阪基本上都没有。但是我们在这个店里遇到了一个说中文特别标准的日本女孩，瞬间觉得她很厉害。因为她说的很标准我把她当成中国人了就语速较快的和她讲中文，但是发现她有点发愣我才反应过来她不是中国人。就这样我们中文+日语沟通着，最后成功的买回了一台价值3万多日元的PS4。 10.4 大阪-东京 今天睡到自然醒然后起床收拾东西准备回东京，直接去机场然后到机场免税店逛。到了机场问了工作人员得知飞机起飞前3个小时才能进，我们只能把行李暂寄在机场去银座和秋叶原逛街。 在秋叶原狠心买了一块2万日元的太阳能机械表和6000日元的香水(送给老妈)，老婆买了一套雪肌精和一堆化妆品。把剩下的钱全部花光了，这算是最后的狂欢吧。 在机场免税店发现可以刷支付宝，于是买了几盒白色恋人巧克力，抹茶饼干和一条sevenStar的香烟，支付宝自动换算成人民币扣款还减了20块钱，很好很强大给个好评。 10.5 东京-上海-杭州 0点左右我们开始办检票登机，发现飞机上基本上都是中国人连空姐都是中国人，有种己经回国了的错觉。我困的不行上飞机就想睡觉，老婆兴奋的像个孩子一样说外面的风景好漂亮，拉着我和她一起看风景，她成功的赶跑了我的瞌睡一起看着飞机转弯、加速、起飞、爬升，一直到半夜2点多才睡着。 由于时差原因到上海的时候才半夜3点左右，下了飞机去转盘取行李。真是一脸懵逼，上面一件行李都没有。站着像望夫石一样等了近半个小时行李才一件一件的出来。但是在日本的时候刚下飞机所有的行李都全部放出来了,真的无力吐槽中国的办事效率。 拿到行李的时候己经快4点了，我们叫了个接机的司机直接送我们去上海虹桥火车站坐火车回杭州，再次感受到了天朝的威力,早上6点钟人多的都挤不动，一上车马上就有一群人冲进去抢座位，根本不管什么先下后上，才回来我还真不适应，等我反应过来的时候我己经被挤出来了。 再次回来这个熟悉而又无奈的地方，为期9天的行程结束了。 对日本初印象 公共场合都非常安静 不管是在飞机上，地铁上还是JR上都比较安静，可能是因为有不少人在睡觉的原因吧。印象比较深刻的是有个小孩哭了,他妈妈告诉她不要哭了不然会吵到别人，然后小孩子就停止哭泣了，真是羞愧难当。 日本一年四季都喝冰水，所以如果你点餐时如果未做要求都会上冰水。 有不解的看知乎吧 日本人为什么喜欢喝冰水？ ,主要是我在亲爱的祖国喝冷水会拉肚子。 日本坐手扶梯都是自觉靠右站，左侧留给赶时间的人通过。 这似乎己经成了一种骨子里的习惯，如果所有人都站成一排自己站旁边，也会觉得脸红的吧。 日本坐电梯位于电梯按钮位置的人会最后出来 因为选择站在这里就有一个职责,要让所有人安全的进出，所以会一直按着开门的按钮等所有人离开再出来，如果外面有人准备进来但是因为有事没进来一定会鞠躬道歉。 日本所有商场基本上都是8点关门，秋叶原则是10点。 不管多么繁华的地方，到了8点以后基本上都看不到有在营业的商场了。我好奇问了一下，说是因为老板付不起加班费(正常工资的2倍到3倍)，所以到点基本上都下班了。 日本没有假货，但是也有坑 在日本最放心的就是没有假货，但是我还是差点被坑了。原因是那个白色恋人巧克力(白い恋人)，我在大阪的商店看到了有趣的恋人(面白い恋人),当时差点认错。我查了一下这个产品己经被起诉了，但是不知道为什么还一直在卖。侵权事件请看 日本名点“白色恋人”诉“有趣恋人”侵犯商标权 日本所有的商品价格标签都会有两个价格:含税价和不含税价，真正的明码标价，童叟无欺。 国内都是稀里糊涂，或许是因为税太高了，不敢标出来。我买个15万的车增值税出了2万多，购置税出了1万多，真是呵呵了。 日本的铁路和地铁一样方便 日本铁路叫JR,每个站点外面都有自动售票机（当然也有人工窗口），随买随走不用记名。 日本的红绿灯在变绿后会发出声音，提示行人可以通过了 并且颜色看着很不习惯，绿灯并不是绿色的，而是有点蓝色的感觉。在日本并不是100%没有人闯红灯，在小道上没车的时候偶尔也会看到红灯时有人通过，但不会出现中国式过马路。 日本能用支付宝的地方并不多,刷银联卡会更划算(打9.5折) 听国内吹嘘的多么牛逼，支付宝己打开全球市场。虽然能用是事实，但是支持的店铺很少，机场免税店可以用、银座部分商场可以用，别的地方看到的很少，多数情况是付现金或刷卡。 所有的服务台(不管是柜台还是收银台)都会有一个小盘子 付钱也好找零也好抑或是小票，都会放在小盘子里自取。可能因为日本用硬币情况下太多，放个盘确实会方便很多。 在日本问路要谨慎 在日本旅游期间我问路次数 算是比较多的，问到后面我都不好意思开口了。如果你在路上遇到一个人想问路说一句”あの、すみません(对不起，打扰一下)”、对方一定会停下脚步答到\u0026quot;はい、なんでしょうが(好的，请问有什么事？)\u0026quot;,然后芭啦芭啦给你讲怎么走。如果讲完还是没听懂，对方便会说 \u0026ldquo;ご案内します(请让我给你带路吧)\u0026quot;,然后跟着走就好了。到了之后他/她还会给你鞠躬道谢，这是我最接受不了的。本来麻烦了别人还要还要道谢，这让我很愧疚。总计问路多少次没统计，但是印象深刻的有一个老大爷，带着我走了5分钟左右一直把我带到地铁口，还准备带我下去买票。还好我说了接下来我自己去就好了，他才离开。第二个是中年大叔(或许不是本地人)，我问了他也不知道然后看我手机开着地图然后就带我绕了一圈还是没找到结果把我带到警察局了，让我问警察。(笑哭) 第3个是一个30多岁的阿姨，在地铁站给我讲了很久差点错过电车，在最后一秒跳上车，然后我忍不住深深的鞠了一躬表示道谢和歉意。第4个是一个年轻小伙子，是我们刚从东京到大阪下车在地铁里面徘徊，他上来问我们要去哪。我们把住宿地址给他看了之后便芭啦芭啦语速超快的讲了至少有3分钟，然后我们基本上都没听懂真是迷之尴尬，然后他就直接带着我们去坐车。才开始着实吓了我一跳。最后一个是在大阪天王寺公园我遇到一个阿姨问她这附近地铁在哪，才开始她讲日语发现我们听不大懂开始用蹩脚的英语和我们沟通，我们任性的用着半吊子日语回复，真是神奇的体验。 日本的水果和零食特别贵 以前听说日本的旅客来中国旅 游看到我们拿着勺子挖西瓜吃简直不敢相信。我现在是信了，他们苹果是按个卖的，大概4-5rmb一个。零食也很贵，随便一包都至少得10+rmb。我在想，日本人不吃零食和水果么。我怀疑我老婆在日本呆久了真能吃零食吃到我怀疑人生。 日本的交通很贵 一站最低10块钱。我猜想是日本的地铁网太密集了，导致于很多在跑的地铁很大一部分人都坐不满，为了避免亏损太多，定价也很高。听说可以用西瓜卡刷地铁，不知道会不会便宜一点。 日本地铁大部分时间都有位置 我很奇怪明明有很多座位，但是很多人就是愿意站着，而且有部分人还是50岁以上的中老年人。反正我看到有座位一定会去坐的，出去玩每天都3万步，简直累趴了。 日本有站着吃面的面馆 才开始我很好奇站着怎么吃，发现那位穿西装的大叔吃的那么自然。我知道盯着人看不礼貌，所以扫了一眼没看一直看。 进屋要脱鞋 不脱鞋会让人很困扰，我们去和服店看衣服时遇到一个中国女孩直接穿鞋进去了。然后马上被屋主带出来了，然后立刻去拿抹布去擦，让人很难为情。门口都会备拖鞋 不打听别人的家事，更不要说隐私。 在一起工作十几年，不知道对方有几个兄弟姐妹。福原爱在接受日本媒体的采访时说，中国记者什么都问，问得直想哭。 日本的自动贩卖机多到不敢让人相信 不管在多偏的乡下，只要有人住的地方都有自动贩卖机，这点真心太方便了。 日本的垃圾桶很少 出去玩做好把垃圾背回家的准备。要么走很远都遇不到垃圾桶，要么一遇到就是一大排（分很多种类）。我们居住的生活垃圾最后都留给房东自己处理了，因为对我们来说相当棘手啊。 日本的出租车门是自动的 虽然出国之前我们也知道，但是多年养成的习惯还是会随手去关门，然后被司机礼貌的提醒这个门是自动的，感觉超尴尬的。 日本的地铁进口和出口是通用的 如果你正在出去，另一面会显示一个红色的叉提醒别人这个门暂时不能用，反之亦然。 日本是一个高度自助的国度 好像日本是一个不担心路人不给钱，破坏自助设备的国家，到处都是自动贩卖机。其实，不仅仅是卖饮料，日本的超市，医院，加油站等等都实现了自助付款，不懂日文的话会有些很不方便。我去入住了东京和大阪的民宿全程都没有见到房东，但是走的时候我们会去房间好好整理一下，还获得了房东的夸奖。还有去商场买衣服的时候旁边有很多台机器，把衣服放进去会显示价格，然后投币就可以把衣服拿走了，当然袋子就在机器边上，就是这么自助，超级不适应的说。下面的是airbnb的房东的评价： 开销 机票 2800/人 接机 400/次 JR PASS 1600/张 交通约 50/天/人 大阪周游券 300/人 住宿 350/天/人 吃饭 50/顿/人 购物 约10000rmb左右 两个人合计2.5万RMB左右。 购物清单 注意：发票会订在护照上要保存好，过海关时可能会检查。免税(8%)化妆品过海关前不要开封，不然要交税。 PS4、游戏碟、手表、雪肌精、Beauteye、玫瑰滴眼液、FX银瓶滴眼液、龙角散、白色恋人、七星香烟、香水、zippo打火机、太田胃药、大正制药口腔溃疡贴、小儿退烧贴、大麦若叶、巧克力零食、坚果、小红丸、MINON、化妆水、EVE止疼药、儿童沐浴液、伊藤园绿茶、Ipsa粘土面膜酵素X酵母 值得买但没买的东西(网上搜集) 护肤品： SK2神仙水 Albion奥尔滨健康水 Albion渗透乳 Mandom曼丹眼唇卸妆油 Kose高丝卸妆油 Rosette硫磺祛痘膏 Rosette海泥洗面奶 Smile suisai酵素洁面粉 Skinlife泡沫洗面奶 Shiseido资生堂洗颜专科 Albion奥尔滨健康皂 IPSA化妆棉 Unicharm1/2省水化妆棉 化妆品： Impress granmula 端正环采顶级粉霜 CPB肌肤之钥高光 CPB肌肤之钥遮瑕棒 Kate眉粉 Kate眼影 Kissme睫毛膏 Kissme眼线笔 Canmake棉花糖粉饼 DHC唇膏 Shiseido资生堂药用唇膏 Anessa安耐晒金瓶 Anessa安耐晒银瓶 ALLIE防晒 Narisup娜丽丝防晒喷雾 Deonatulle止汗石 Shiseido资生堂131粉刷 Shiseido资生堂119粉扑 Shiseido资生堂睫毛夹 Shiseido资生堂眉刀 日用品： Lycee乐敦小红花滴眼液 狮王滴眼液 Kissyou负离子牙刷 Smile cosmetique美白牙膏 狮王美白牙膏 Ora2美白牙膏 花王泡沫染发剂 Hair Recipe银杏果蜂蜜洗发水 reveur无硅洗发水 资生堂Fino发膜 树之惠足贴 花王蒸汽眼罩 bold洗衣液 Lenor Eau deLuxe衣物柔顺剂 汉方天然果蔬清洁贝壳杀菌粉 陶瓷刀 匠牌指甲刀 小学生书包 药品： Crystal硅素水 药王酵素100 新谷夜酵素 DHC维生素 小林制药Breath care口气清新薄荷丸 小林制药液体创可贴 AG鼻塞喷雾剂 狮王祛痘膏 白兔祛痘膏 浅田饴 大正制药感冒颗粒 食品： Royce生巧克力 Royce巧克力饼干 Tokyo Banana东京香蕉蛋糕 Potato Farm薯条三兄弟 Kracie玫瑰香体糖 Uha葡萄味觉糖 Calbee麦片 电器： Tescom负离子胶原蛋白吹风机 Panasonic松下卷发棒 Panasonic松下造型吹风机 Panasonic蒸脸器 象印保温杯 膳魔师保温杯 象印焖烧杯 虎牌焖烧杯 剃须刀 索尼电子产品 参考攻略 日本购物攻略——去日本值得购买的80件产品 2016日本购物攻略，去日本旅行千万别买这些东西 切记 去日本必买的东西top10 懒人夫妻由东到西的日本15日自由行详细流水账攻略 篇一：第一日 抵达东京，逛银座及东京塔 懒人夫妻由东到西的日本15日自由行详细流水账攻略 篇二：第二日 筑地，皇居，秋叶原和台场 懒人夫妻由东到西的日本15日自由行详细流水账攻略 篇三：第三日 上野动物园，浅草寺，天空树 懒人夫妻由东到西的日本15日自由行详细流水账攻略 篇四：第四日 江之岛，镰仓 懒人夫妻由东到西的日本15日自由行详细流水账攻略 篇五：第五日 去往富士河口湖 懒人夫妻由东到西的日本15日自由行详细流水账攻略 篇六：第六日 去往京都 懒人夫妻由东到西的日本15日自由行详细流水账攻略 篇七：第七日 八坂神社，二年坂，三年坂，清水寺 懒人夫妻由东到西的日本15日自由行详细流水账攻略 篇八：第八日 仙洞御所，伏见稻荷大社 懒人夫妻由东到西的日本15日自由行详细流水账攻略 篇九：第九日 奈良行，春日大社，东大寺 懒人夫妻由东到西的日本15日自由行详细流水账攻略 篇十：第十日 二条城，东西本愿寺 懒人夫妻由东到西的日本15日自由行详细流水账攻略 篇十一：第十一日 金阁寺，岚山景区 懒人夫妻由东到西的日本15日自由行详细流水账攻略 篇十二：第十二日 去往大阪，海游馆，天保山摩天轮 懒人夫妻由东到西的日本15日自由行详细流水账攻略 篇十三：第十三日 大阪环球影城 懒人夫妻由东到西的日本15日自由行详细流水账攻略 篇十四：第十四日 大阪城 道顿堀 懒人夫妻由东到西的日本15日自由行详细流水账攻略 篇十五：最后一日：梅田蓝天大厦 返回厦门以及算总账 "],["游戏服务器的常用架构","2017年09月09日","/2017/gameservertype/","游戏服务器，是一个会长期运行程序，并且它还要服务于多个不定时，不定点的网络请求。所以这类服务的特点是要特别关注稳定性和性能。这类程序如果需要多个协作来提高承载能力，则还要关注部署和扩容的便利性；同时，还需要考虑如何实现某种程度容灾需求。由于多进程协同工作，也带来了开发的复杂度，这也是需要关注的问题。 游戏服务器架构要素 对于游戏服务端架构，最重要的三个部分就是，如何使用CPU、内存、网卡的设计： 内存架构：主要决定服务器如何使用内存，以最大化利用服务器端内存来提高承载量，降低服务延迟。 逻辑架构：设计如何使用进程、线程、协程这些对于CPU调度的方案。选择同步、异步等不同的编程模型，以提高服务器的稳定性和承载量。可以分区分服，也可以采用世界服的方式，将相同功能模块划分到不同的服务器来处理。 通信模式：决定使用何种方式通讯。基于游戏类型不同采用不同的通信模式，比如http,tcp,udp等。 游戏类型 卡牌跑酷等休闲游戏弱交互游戏 分区分服RPG游戏（RPG页游） 分服模型是游戏服务器中最典型，也是历久最悠久的模型。在早期服务器的承载量达到上限的时候，游戏开发者就通过架设更多的服务器来解决。这样提供了很多个游戏的“平行世界”，让游戏中的人人之间的比较，产生了更多的空间。其特征是游戏服务器是一个个单独的世界。每个服务器的帐号是独立的，每台服务器用户的状态都是不一样的，一个服就是一个世界，大家各不牵扯。 后来游戏玩家呼吁要跨服打架，于是就出现了跨服战，再加上随着游戏的运行，单个服务器的游戏活跃玩家越来越少，所以后期就有了服务器的合并以及迁移，慢慢的以服务器的开放、合并形成了一套成熟的运营手段。目前多数游戏还采用分服的结构来架设服务器，多数页游还是采用这种模式。 数据共享游戏服务器 网关部分分离成单端的gate服务器，DB部分分离为DB服务器，把网络功能单独提取出来，让用户统一去连接一个网关服务器，再有网关服务器转发数据到后端游戏服务器。而游戏服务器之间数据交换也统一连接到网管进行交换。所有有DB交互的，都连接到DB服务器来代理处理。 场景服务器：它负责完成主要的游戏逻辑，这些逻辑包括：角色在游戏场景中的进入与退出、角色的行走与跑动、角色战斗（包括打怪）、任务的认领等。场景服务器设计的好坏是整个游戏世界服务器性能差异的主要体现，它的设计难度不仅仅在于通信模型方面，更主要的是整个服务器的体系架构和同步机制的设计。 非场景服务器：它主要负责完成与游戏场景不相关的游戏逻辑，这些逻辑不依靠游戏的地图系统也能正常进行，比如公会聊天或世界聊天，之所以把它从场景服务器中独立出来，是为了节省场景服务器的CPU和带宽资源，让场景服务器能够尽可能快地处理那些对游戏流畅性影响较大的游戏逻辑。 网关服务器: 在类型一种的架构中，玩家在多个地图跳转或者场景切换的时候采用跳转的模式，以此进行跳转不同的服务器。还有一种方式是把这些服务器的节点都通过网关服务器管理，玩家和网关服务器交互，每个场景或者服务器切换的时候，也有网关服务器统一来交换数据，如此玩家操作会比较流畅。 房间游戏 房间类玩法和MMORPG有很大的不同，在于其在线广播单元的不确定性和广播数量很小。而且需要匹配一台房间服务器让少数人进入一个服务器。 这一类游戏最重要的是其“游戏大厅”的承载量，每个“游戏房间”受逻辑所限，需要维持和广播的玩家数据是有限的，但是“游戏大厅”需要维持相当高的在线用户数，所以一般来说，这种游戏还是需要做“分服”的。典型的游戏就是《英雄联盟》这一类游戏了。而“游戏大厅”里面最有挑战性的任务，就是“自动匹配”玩家进入一个“游戏房间”，这需要对所有在线玩家做搜索和过滤。 玩家先登录“大厅服务器”，然后选择组队游戏的功能，服务器会通知参与的所有游戏客户端，新开一条连接到房间服务器上，这样所有参与的用户就能在房间服务器里进行游戏交互了。 "],["lombok常用注解整理","2017年09月09日","/2017/javalombok/","2017-09-11-lombok常用注解整理 简介 lombok 提供了简单的注解的形式来帮助我们简化消除一些必须有但显得很臃肿的 java 代码。 lombok插件 安装 使用 lombok 是需要安装插件的，如果不安装，IDE 则无法解析 lombok 注解。 idea eclipse/myeclipse 将 lombok.jar 复制到 myeclipse.ini / eclipse.ini 所在的文件夹目录下 打开 eclipse.ini / myeclipse.ini，在最后面插入以下两行并保存： -Xbootclasspath/a:lombok.jar -javaagent:lombok.jar 3.重启 eclipse / myeclipse 常用注解 @Data 注解在类上；提供类所有属性的 getting 和 setting 方法，此外还提供了equals、canEqual、hashCode、toString 方法 @Setter ：注解在属性上；为属性提供 setting 方法 @Setter ：注解在属性上；为属性提供 getting 方法 @Log4j ：注解在类上；为类提供一个 属性名为log 的 log4j 日志对象 @NoArgsConstructor ：注解在类上；为类提供一个无参的构造方法 @AllArgsConstructor ：注解在类上；为类提供一个全参的构造方法 @Cleanup : 可以关闭流 @Builder ： 被注解的类加个构造者模式 @Synchronized ： 加个同步锁 @SneakyThrows : 等同于try/catch 捕获异常 @NonNull : 如果给参数加个这个注解 参数为null会抛出空指针异常 @Value : 注解和@Data类似，区别在于它会把所有成员变量默认定义为private final修饰，并且不会生成set方法。 参考文档 官方文档： https://projectlombok.org/features/all lombok注解介绍 http://blog.csdn.net/sunsfan/article/details/53542374 Lombok介绍及使用方法 http://www.cnblogs.com/holten/p/5729226.html "],["swift项目初探","2017年04月04日","/2017/swiftprojectbuild/","截至到上一篇博客到现在为止差不多有一个月了,时光飞逝,从来没有觉得时间过的如此之快。在这一个月中其实发生了很多事:学完了日语中级上册,记了整整一本笔记;装上了黑苹果,因此也有机会接触到IOS相关的内容,所以大致过了一遍swift3的语法;养了一只小仓鼠,生活变的有趣许多;整理了一下github,切换了主邮箱。其他来说,生活依旧在继续，折腾一直未停止,为了生活,为了编程.我一直在努力,也从未放弃。记一篇swift入门的博客以作慰藉。 前言 因为本人是在学习swift中,所以这篇文章更多的成份算是自己的笔记,只是将自己的经历分享出来。请大牛们勿喷,小白们别当权威。如果有错误请指出，我一定会虚心改正。最后，与君共勉，早日成为独当一面的人物。 一.基本环境 OS x 10.11.6 Xcode 8.2.1 swift 3.0.2 swift package manager 3.0.2 pod 1.2.1 carthage 0.20.1 因为xcode是严格和os x版本对照的,所以我的10.11.6黑苹果就止步于8.2.1版本的xcode,因此swift3.1也玩不了,表示很心痛. 二 swift能做些什么 IOS手机APP开发(据说也能开发android应用,期待大一统) Mac电脑应用,同样的软件,在mac上看着就是高雅,这不得不说是apple的功劳 watchOS和TvOS,暂时没接触到 服务端开发,也就是说可以开发网站或者其他各种东西,对应框架有Perfect，Vapor，Kitura 和 Zewo. 附一篇文章介绍 其他待挖掘,世界各国的计算机科学家们可不是打酱油的. 三. SPM是什么鬼 Swift Package Manager(SPM)是苹果最新的官方工具,可以用来管理 Swift 代码的分配，它为 Swift 编译系统集成了自动进行下载、编译和连接依赖的过程,不过目前还处于早期开发阶段。 支持的平台 ✔ macOS ✔ Linux ✘ iOS ✘ watchOS ✘ tvOS 在此之前我们常用的工具是 和 。 如何下载 下载对应版本 ,然后安装 在终端中执行 验证是否安装成功 怎么使用 首先，使用 创建一个新的目录，用来放置你的包或者应用。 这里我们使用 作为例子： 。 然后，使用 命令进入 目录，运行命令： 。 我们看看 生成的内容： ：包的”配置信息”（manifest）。 使用你创建的目录名作为包名。 目录：按照 SwiftPM 的要求，所有的源代码文件都放到 Sources 目录下。 ：Swift 应用使用 （有且只有一个）作为程序执行的入口。 目录：存放应用的测试用例。 ：一个便捷的 文件，忽略一些本地编译时用到的配置目录和文件，比如: 和 目录（一些你不想加入到 git 库的东西）。 在这个 例子中， 文件内容如下： 运行 会创建可执行文件 ，运行这个文件就会在终端输出 . 如果你想编译一个 Swift 库，只需要删除 文件，然后替换成你的库代码。在没有 的情况下， 会创建一个静态的库。 怎么在xcode中打开 在项目根目录运行 ,会生成 ,此时可以用xcode打开这个项目 我们来看看生成的代码是什么样子的 怎么添加其他依赖 我们以引入Alamofire为例 项目根目录有一个 的文件,打开这个文件,加入Alamofire的地址 .Package(url: \u0026quot;https://github.com/Alamofire/Alamofire.git\u0026quot;, majorVersion: 4) 文件内容如下 然后运行再次在项目根目录运行 就会下载Alamofire的依赖 四. pod又是干咩的 CocoaPods是什么？ 当你开发iOS应用时，会经常使用到很多第三方开源类库，比如JSONKit，AFNetWorking等等。可能某个类库又用到其他类库，所以要使用它，必须得另外下载其他类库，而其他类库又用到其他类库，“子子孙孙无穷尽也”，这也许是比较特殊的情况。总之我的意思就是，手动一个个去下载所需类库十分麻烦。另外一种常见情况是，你项目中用到的类库有更新，你必须得重新下载新版本，重新加入到项目中，十分麻烦。如果能有什么工具能解决这些恼人的问题，那将“善莫大焉”。所以，你需要 CocoaPods。 CocoaPods应该是iOS最常用最有名的类库管理工具了，上述两个烦人的问题，通过cocoaPods，只需要一行命令就可以完全解决，当然前提是你必须正确设置它。重要的是，绝大部分有名的开源类库，都支持CocoaPods。所以，作为iOS程序员的我们，掌握CocoaPods的使用是必不可少的基本技能了。 如何下载和安装CocoaPods？ 在安装CocoaPods之前，首先要在本地安装好Ruby环境。至于如何在Mac中安装好Ruby环境，请google一下，本文不再涉及。 假如你在本地已经安装好Ruby环境，那么下载和安装CocoaPods将十分简单，只需要一行命令。在Terminator（也就是终端）中输入以下命令（注意，本文所有命令都是在终端中输入并运行的。什么，你不知道什么是终端？那请我吃饭，我告诉你）： 如果下载不了可能又是伟大的墙在发挥作用,请自行翻墙或修改国内镜像源. 正常来说,等上十几秒钟，CocoaPods就可以在你本地下载并且安装好了，不再需要其他设置。 好了，安装好CocoPods之后，接下来就是使用它。所幸，使用CocoPods和安装它一样简单，也是通过一两行命令就可以搞定。 我在这里用两种使用场景来具体说明如何使用CocoaPods。 场景1：利用CocoaPods，在项目中导入Alamofire类库 Alamofire类库在GitHub地址是：https://github.com/Alamofire/Alamofire.git 为了确定Alamofire是否支持CocoaPods，可以用CocoaPods的搜索功能验证一下。在终端中输入： 如果能正确返回 相关信息。这说明，Alamofire是支持CocoaPods，所以我们可以利用CocoaPods将Alamofire导入你的项目中。 我们创建一个swift的ios项目,然后在终端中切换到该项目的根目录,运行以下命令: 这个命令会在根目录下生成一个 ,我们在这个文件中添加相应的依赖就可以了. 修改Podfile文件,添加依赖 然后运行 注意提示: 告诉我们要关掉xocode,选择 打开项目,目录结构现在应该是这个样子的. 添加 依赖 =\u0026gt; =\u0026gt; ,将 勾上, 此时,我们就可以使用 来做些有趣的事情了。 关于 Podfile.lock 当你执行pod install之后，除了 Podfile 外，CocoaPods 还会生成一个名为Podfile.lock的文件，Podfile.lock 应该加入到版本控制里面，不应该把这个文件加入到.gitignore中。因为Podfile.lock会锁定当前各依赖库的版本，之后如果多次执行pod install 不会更改版本，要pod update才会改Podfile.lock了。这样多人协作的时候，可以防止第三方库升级时造成大家各自的第三方库版本不一致 场景2：如何正确编译运行一个包含CocoPods类库的项目 你也许曾经遇到过（特别是新手iOS开发者）这种情况，好不容易在GitHub上找到一份代码符合自己想需求，兴冲冲下载下来，一编译，傻眼了，发现有各种各样错误。一看，原来是缺失了各种其他第三方类库。这时候莫慌，你再仔细一看，会发现你下载的代码包含了Podfile。没错，这意味着你可以用CocoaPods很方便下载所需要的类库。 下面，我以代码 UAAppReviewManager 为例来说明如何正确编译运行一个包含CocoPods类库的项目。 UAAppReviewManager是一个能够让你方便地将提醒用户评分的功能加入你的应用中。当你去UAAppReviewManager的GitHub地址下载这份代码之后，打开Example工程（UAAppReviewManagerExample），编译，你会发现Xcode报告一大堆错误，基本都是说你编译的这份代码找不到某某头文件，这就意味着你要成功编译UAAppReviewManager的Example代码，必须先导入一些第三方类库。同时你会发现在UAAppReviewManagerExample文件夹下面有三个跟CocosPods相关的文件（文件夹）：Podfile，Podfile.lock和Pods 这时候，打开终端，进入UAAppReviewManagerExample所在的目录，也就是和Podfile在同一目录下，和场景1一样，输入以下命令（由于已经有Podfile，所以不需要再创建Podfile）： 这时候，再回到 文件夹看一看，会看到多了一个文件 根据终端的信息提示，你以后就需用新产生的 来运行这个 代码了。 打开 ，编译运行，成功 注意，这里有个小问题，如果刚刚你不是输入 ，而是输入 ，会发现类库导入不成功 这里的意思大概是 文件过期，类库有升级，但是 没有更改。 只会按照 的要求来请求类库，如果类库版本号有变化，那么将获取失败。但是 会更新所有的类库，获取最新版本的类库。而且你会发现，如果用了 ，再用 就成功了。 那你也许会问，什么时候用 ，什么时候用 呢，我又不知道类库有没有新版本。好吧，那你每次直接用 算了。或者先用 ，如果不行，再用 。 五. Carthage 说到Carthage,就要先说swift，2014年苹果发布swift初期，用swift编写的第三方库就只能通过拖动源代码到自己的项目中才能被调用， 由于当时只有寥寥无几的开源库，且不能打包，加上swift1.0并不是那么好用，许多人对swift持着观望的态度。随着swift逐步趋于稳定，并且从ios8.0开始支持将自己写的swift打包成framework，越来越多的纯swift编写框架开始出现，就在这时候carthage突然出现在人们的视野中，而且陆陆续续几乎所有的开源框架都开始支持carthage。 安装使用Carthage 如果你不喜欢使用终端，也可以从网站https://github.com/Carthage/Carthage/releases 下载最新版的Carthage.pkg来更新。 当你安装好Carthage后，在终端执行 即可看到当前的carthage版本, 当我写这篇文章的时候，Carthage的版本为0.20.1 。现在，你已经安装好了Carthage，接下来就是在你的项目中使用carthage了： 通过终端进入到项目所在的文件夹 创建一个空的carthage文件 使用xcode打开cartfile文件 添加内容 保存并关闭cart file文件，在终端执行命令 ,carthage会为你下载和编译所需要的第三方库，当命令执行完毕，在你的项目文件夹中会创建一个名为Carthage的文件夹 添加依赖 六. 如何选择 google出来多半都是使用 和 ,所以我们暂时也从这里面二选一吧。前面提到目前 只支持 和 系统,所以开发ios应用的话选用 会好一些,我会花了更多的时间在 上面。但是，我更期待 能够支持 ,让我们拭目以待吧。 七. 使用Alamofire来玩点有趣的吧 未完待续 "],["我的常用软件清单","2017年04月04日","/2017/mysoftware/","折腾了各种系统,因为各种原因影响 。工作的系统安装了黑苹果，从此再也不需要折腾系统了。告别100%硬盘占用，99%内存占用；告别网页qq,网页微信 。 告别游戏，从此一心为技术，哈哈哈哈哈，手动脑残3秒钟。 一. mac下常用软件 1. spectacle 最大化窗口小工具 2. Cinch 功能同上 3. scroll reverse 让鼠标滚动反向(和win同步的习惯) 4. Owly 防止系统休眠,咖啡因功能也是如此 5. hotkeyEVE/cheat sheet 快捷键提示 6. Alferd 搜索神器 https://www.waerfa.com/alfred-workflow 7. mac自带常用应用 numbers,keynote,Pages,mail,itunes,icloud,照片,系统监控 8. iterm2 终端 9. oh-my-zsh 终端增强 10. xcode mac标配编码器 11. 迅雷 下载少不了 12. idea 代码编辑器 13. java 开发java怎么能少了它 14. 微信/QQ 工作联系 15. chrome 通向世界的入口,还附带了一大批好用的插件 16. sourceTree git管理客户端 17. AppCode 写swift的好东西 18. 网易云音乐 听歌必备,忘了杭州地铁1号线吗? 19. virtual box 装个window看看而已 20. kindle 电脑上管理kindle的好工具 21. macDown/typora 写markdown的好东东 22. 百度Hi/阿里旺旺/钉钉/微博maipo 择需而装 联系人偶尔用用 22. dash 看文档简直不要太好 23. bilibili b站的客户端啊,不要么? 24. photoshop 还是要装一个,看着也好啊 25. Yummy Ftp ftp工具,目前我没找到替代者 25. navicat mysql数据库客户端 26. sublime text 打开超级快,就当文本编辑器用用吧 27. onenote 我的笔记都在上面 28. 微信web开发者工具 装个看看,感觉界面布局挺方便,不过我不开发微信程序 29. visual studio 号称全宇宙最好用的编辑器,你不看看么? 30. office全家桶 要和windows做兼容,还是要装它 31. apowersoft mac录屏王 录屏啊,你懂的 32. licecap 无意间发现的一个录gif的好工具 33. 向日葵 /teamviwer 远程助手 34. line 可惜不能用 35. 爱奇艺 看电视啊 36. yotube 看世界 37. the unarchiver 解压工具 38. shadowsocks 去外面的世界 https://go.ishadowx.net/index_cn.html 39. sketch 也有网页版的磨刀,磨刀更好用 40. Istatus Menu 在右上角显示当前网速/CPU/硬盘等系统信息 41. jsonExport 可以根据json生成model的好东西 41. charles 抓包工具 二. win下常用软件 1. IDEA JAVA开发最强IDE,不管什么时候都少不了。 2. xshell+xftp WIN下远程连接linux比较好用的工具,就这东西我可能玩好多年。 3. 作业部落 写博客的时候可以用它实时预览，简洁美观。 4. 微信 越来越多的人从QQ换到微信 5. QQ 因为工作原因需要用QQ交流 6. 网易云音乐 唯一的娱乐 7. OneNote 己经离不开的软件了，记录了很多笔记 8. FoxMail 收发邮件相当方便，多帐号统一管理 9. Navicat Premium中文版 mysql客户端 10. 360安全卫士 主要是清清垃圾，管理一下开机软件 11. Mockplus 以前用axture，现在发现了一个更厉害的东西。 12. photoshop 虽然不是专业的，但是也学过几个月。偶尔会用一下 13. 搜狗五笔 像我一直始终坚持着五笔的人真的不多了。 14. zeal 就是mac上的dash,api快速查询工具 15. LICEcap gifCam 录gif的神器 16. Beyond Compare 4 版本对比工具,IDEA默认的没法对比csv文件 17. 迅雷 下载软件少不了 18. p2p searcher 别在公司用，会被打的！ 19. jd-gui java反编译工具 20. team viewer 当初用qq远程，有了tv，才发现qq远程是多么不实用。。 21. EmEditor 公司项目配置表都是用的csv,这俩货真是绝配。当然还有wps 22. UltraISO 把系统写到U盘的工具，类似的还有老毛桃，大白菜。 23. 12306Bypass 抢火车票必备 24. 360wifi 配个360发射器，20块钱一个。 25. 钉钉 企业管理工具，公司统一使用。 26. 百度网盘 在各大网盘咯屁的大背景下，总感觉百度网盘风雨飘摇，希望它能坚持的久一点，再久一点。 27. ADSafe（净网大师） 有了这款软件，网上各大视频网站0秒广告，直接观看视频无添加任何广告，让你一次看个爽，再也不用看着90S的广告恨的牙痒痒了。 28. 冰点文库下载器 我们在下载百度文库、道客巴巴、豆丁的文档时，经常会遇到这种需要财富值才可以下载的文档，有的甚至还需要收费才可以下载。 给大家安利的这款软件，只要找到百度文库、道客巴巴、豆丁等需要下载的文档地址，放在冰点文库下载器中，就可以直接下载了。 29. 比特数据恢复软件 电脑中存放的一些非常重要的文件丢失，却又没有备份的时候，对我们的工作造成了很大的困扰，如果我们遇见硬盘里的文件丢失怎么办？加下来给大家安利的这款软件将帮助大家找回丢失的重要文件，必须学起来。（1）下载安装“比特数据恢复软件”；（2）运行该软件，可选择“万能恢复”帮助我们找回丢失的文件； 30. pptminimizer 压缩图像和照片，优化PowerPoint，Word，Excel和PDF文件的大小能够高达50-90%，而无需打包压缩。 31. PhotoZoom Pro 支持Mac OS X 10.9 (Mavericks), Windows 10, Photoshop CC； 采用最新S-Spline插值算法放大或缩小图像生成最高品质，降低JPEG低品质失真和噪点； 新增鲜艳度和清晰度微调设置、新增分屏预览：预览不同的调整大小方式； 针对不同类型图像，优化预设值；改进GPU加速以加速图像处理 Raw图像现在支持独立的应用程序（插件已经支持） 32. 开发环境 JDK,MAVEN,git,node等等。用到什么装什么。。 三. 常用的工具网站 1. pdf和word互转 工作中经常需要将PDF转化成WORD，PDF转化成JPG，你还在到处下软件再进行转换吗？ 2. iconfont PPT中好看、简洁的png图标一直是PPT人/设计师的最爱，那么，如何免费去下载海量的png图标呢？ 给大家安利的这款软件就是这样一款可以免费下载png图标的神器，是阿里做的图标库网站，页面干净利落，完全没广告。 3. 图标 免费图标 4. ppt转flash 现在flash越来越没落了，不知道还用不用得上 5. 云端工具 尤其适合mac用户使用 四. linux下的常用软件 1. 通讯工具 electronic-wechat 非官方微信，我也说过了，某腾就是这样。好在有网上的大牛给我们提供了便利。 webQQ 因为工作原因，交流都是qq，只能将就一下。 2017年2月7补充：在和别人交流的时候听说在linux上装个virtual box，然后装个windows系统比较好。于我就愉快的去折腾了。经过昨天下午的折腾，成果如下： 成功的在linux上装上了virtual box虚拟机，然后装个win,镜像去msdn上下载吧。 在虚拟机上装了QQ,微信,chrome,OneNote,xshell,xftp,qq五笔,迅雷 暂时需要的就这么多，以后有需要再直接安装。因为是使用的是windows系统，所以exe文件都可以运行。并且解决了win卡顿的问题。折腾起来真愉快 2. 翻墙 eos自带的vpn,然后去买个账号就行了。由于我用的这个也不是很稳定，所以就不推荐给大家了。 3. 编辑器 vim 首推vim,然后各种配置，打造最强ide emacs 神之编辑器，你值得拥有 idea 悄悄告诉你，不管是神之编辑器，还是编辑器之神，其实我用的是idea。哈哈，不要打我，因为在win下面开始。idea算是有口皆碑最好的ide了，当然我现在也在学习vim。等我学会vim我就加入大vim家庭了。 gedit 这个东西还是好用的，跟win下的notepad++差不多。 sublime text 轻量级编辑器，被称为前端神器，界面漂亮，功能实用，值得推荐。 4. 娱乐 网易云音乐 不愧为有情怀的大厂，各种版本一应俱全。再加上是精品中的精品，自然是首选。 擦，没了。。算了，我是爱编程的小莫，代码就是我的娱乐。 5. 截图软件 shutter 添加安装包软件源 sudo add-apt-repository ppa:shutter/ppa 更新源并安装 shutter sudo apt-get update sudo apt-get install shutter 搜索 shutter 可看到已安装成功 shutter安装成功 设置 Shutter 快捷键 打开系统设置 系统设置 打开 Keyboard 键盘设置 键盘设置 添加成功的状态 添加自定义快捷键命令 单击右侧 Disabled，然后快速按下 Ctrl+Alt+A 如下图 shutter 快捷键设置成功 Ctrl+Alt+A 测试OK。 ps: 里面的快捷键命令用：shutter -s 或者shutter –select 截取当前活动窗口：shutter -a （a表示active） 截取拖拉区域：shutter -s （s是select之意），拖拉出矩形区域后按Enter。 Linux 的世界，无所不能的世界 - hsl。 6. 粘贴工具 cliplt sudo apt-get install cliplt 7. 浏览器 当然我的大chrome啦，有情怀的也可以用firefox咯。 sudo wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb dpkg -i google-chrome-stable_current_amd64.deb 8. ftp工具 sudo apt-get install fileZilla 9. 终端工具guake sudo apt-get install guake 10. 远程协助 team viewer https://www.teamviewer.com/zhCN/download/linux/ sudo dpkg -i install teamviewer_12.0.71510_i386.deb 如果报错的话执行 sudo apt-get install -f 再执行 sudo dpkg -i install teamviewer_12.0.71510_i386.deb 11. 下载工具 uget+aria2 下载及配置 transmission sudo add-apt-repository ppa:transmissionbt/ppa sudo apt-get install transmission "],["关于对象的一些思考","2017年03月03日","/2017/aboutobject/","《thinking jn java》被公认为java界的圣经，没有拜读过《thinking jn java》，谈不上算是合格的java程序员。怀着这份敬畏，我开始了 thinking in java. 对象有自己的特性和行为。 所有的东西都是对象。可将对象想象成一种新型变量；它保存着数据，但可要求它对自身进行操作。理论上讲，可从要解决的问题身上提出所有概念性的组件，然后在程序中将其表达为一个对象。 程序是一大堆对象的组合；通过消息传递，各对象知道自己该做什么。为了向对象发出请求，需向那个对象“发送一个消息”。更具体的讲，可将消息想象为一个调用请求，它调用的是从属于目标对象的一个子例程或函数。 每个对象都有自己的存储宽间，可容纳其他对象。或者说，通过封装现有对象，可制作出新型对象。所以，尽管对象的概念都非常简单，但是在程序中却可达到任意高的复杂程度。 每个对象都有一种类型。根据语法， 每个对象都某个“类“的一个”实例“。其中，\u0026ldquo;类\u0026rdquo;(class)是\u0026quot;类型\u0026quot;（type)的同义词。一个类最重要的特性就是”能将什么消息发给它？“ 同一类所有对象都能接收相同的消息。这实际是别有含义的一种说法。由于类型为Circle的一个对象也属于类型为Shape的一个对象，所以一个圆能完全接收形状消息。这意味着可让程序代码统一指挥形状，令其自动控制所有符合形状描述的对象，其中自然包括圆。这一特性称为对象的可替换性，是OOP最重要的概念之一。 数据存在哪 程序运行时,我们最好对数据保存到什么地方做到心中有数。特别要注意的是内存的分配。有六个地方都可以保存数据: (1) 寄存器。 这是最快的保存区域,因为它位于和其他所有保存方式不同的地方:处理器内部。然而,寄存器的数量十分有限,所以寄存器是根据需要由编译器分配。我们对此没有直接的控制权,也不可能在自己的程序里找到寄存器存在的任何踪迹。 (2) 堆栈。 驻留于常规 RAM(随机访问存储器)区域,但可通过它的“堆栈指针”获得处理的直接支持。堆栈指针若向下移,会创建新的内存;若向上移,则会释放那些内存。这是一种特别快、特别有效的数据保存方式,仅次于寄存器。创建程序时,Java 编译器必须准确地知道堆栈内保存的所有数据的“长度”以及“存在时间”。这是由于它必须生成相应的代码,以便向上和向下移动指针。这一限制无疑影响了程序的灵活性,所以尽管有些 Java 数据要保存在堆栈里——特别是对象句柄,但 Java 对象并不放到其中。 (3) 堆。 一种常规用途的内存池(也在 RAM 区域),其中保存了 Java 对象。和堆栈不同,“内存堆”或“堆”(Heap)最吸引人的地方在于编译器不必知道要从堆里分配多少存储空间,也不必知道存储的数据要在堆里停留多长的时间。因此,用堆保存数据时会得到更大的灵活性。要求创建一个对象时,只需用 new 命令编制相关的代码即可。执行这些代码时,会在堆里自动进行数据的保存。当然,为达到这种灵活性,必然会付出一定的代价:在堆里分配存储空间时会花掉更长的时间! (4) 静态存储。 这儿的“静态”(Static)是指“位于固定位置”(尽管也在 RAM 里)。程序运行期间,静态存储的数据将随时等候调用。可用 static 关键字指出一个对象的特定元素是静态的。但 Java 对象本身永远都不会置入静态存储空间。 (5) 常数存储。 常数值通常直接置于程序代码内部。这样做是安全的,因为它们永远都不会改变。有的常数需要严格地保护,所以可考虑将它们置入只读存储器(ROM)。 (6) 非 RAM 存储。 若数据完全独立于一个程序之外,则程序不运行时仍可存在,并在程序的控制范围之外。其中两个最主要的例子便是“流式对象”和“固定对象”。对于流式对象,对象会变成字节流,通常会发给另一台机器。而对于固定对象,对象保存在磁盘中。即使程序中止运行,它们仍可保持自己的状态不变。对于这些类型的数据存储,一个特别有用的技巧就是它们能存在于其他媒体中。一旦需要,甚至能将它们恢复成普通的、基于 RAM 的对象。Java 1.1 提供了对 Lightweight persistence 的支持。未来的版本甚至可能提供更完整的方案。 "],["kindle初体验.","2017年02月02日","/2017/mykindle/","昨天在Tmail上败家了一个kindle,虽然心疼了挺久.但是对于经常看书的来说,这种纸质书的即视感还是很让人享受的. 在买了kindle之后在知乎上查了很多相关的使用感受,感觉真心是物以类聚.关注kindle的人要么是喜欢读书的人要么是有情怀的人.不得不说很多评论还是挺犀利的. https://www.zhihu.com/question/26844201 比如这篇文章,对于kindle的使用体验描述的比较详细. 说一下我的体验吧 第一阶段:开箱 第一感觉就是颜值,真心惊艳到我了.美丽的外观加上天蓝色的外壳,简直不要太漂亮. 打开之后第一反应是,我擦,为啥总是闪屏.是不是邮寄了一个坏的给我,于是赶紧各种百度.后来慢慢了解到kindle的水墨屏的特性. 第二阶段:初体验 它的视觉体验是我使用过最接近纸质书的感觉,对眼睛的保护可谓是所有电子产品中最友好的. 就像这样 read 第三阶段:阅读灯对比 kindle适合在任何时间任何地点使用,不过它最适合的还是在温暖的阳光下静静的享受书中的世界. 但是如果是在晚上没有灯光的情况下,纸质视觉感就会差不少. 下面上图进行一下对比 白天 light 晚上 night 建议 如果你不喜欢读书,kindle买了估计会被打入冷宫. 如果你喜欢读书,并且还没有一套属于自己的房子,那么你确实需要一个kindle. 我用ipad,为什么还会买kindle. 说下我的体验吧,ipad软件很多.用ipad当然资源会更好找.但是有几个问题.ipad太重,晚上砸在脸上真的很疼.还有就是关了灯多会儿东西眼睛又酸又涩.记单词的时候隔一会儿没有操作就熄屏了,常亮又大费电等等问题. kindle的优点:轻,只有205g;大小刚好合适操作方便;水墨屏,视觉体验真心好. 我就不多说了,毕竟专业的比我介绍的更好. http://www.bilibili.com/video/av6246300/ "],["我的新车常备用品","2017年02月02日","/2017/somethingfornewcar/","提车也有一周的时间了,一直在某宝上淘一些常用的汽车用品,列个清单。 1. 脚垫 这个是4s店送的，算是必须品吧。对了，驾驶室一定要带卡扣的垫子，不然影响刹车加油操作。 比如这种，请忽略外观和颜色。我没有去我的车上拍，图片网上找的，只是说明要带卡扣 jiaodian 2. 工具包 4s店配的,主要是备胎安装工具,灭火器和危险警告三脚架之类的。 spareTireTool 3. 牌照框 4s店送的，确切说是出钱买的吧。因为没有浙A资格，花钱让4s店上上海的牌，牌照框也是算在内的东西。 carCard 4. 车膜 在太阳比较大的时候。不管开车还是不开车的时候，直接裸在太阳下面都是一件十分痛苦的事情，提车的时候4s店强制要求加装。所以就选了个原厂膜，2500RMB的价格，真心偏高。 carMembrane 5. 行车记录仪 行车记录仪上路必装,老家有个人就是酒碰酒驾,人家几个人一起的，直接在交警来之前换司机了,他只有一个人还没有记录仪直接全责,一脸懵逼。我是直接在360上买的，因为便宜而且实用。插上之后它会发出一个wifi信息，手机连上之后可以通过360记录仪app可以管理内存和视频回放。 360record 6. 手机支架 开车的时候最重要的安全，有个位置放手机随时可以瞅一眼导航，可以说是汽车必备品了。 carSupport 7. 中控屏钢化膜 新思域的中控充满了科技感，以及全液晶的仪表盘，都深深吸引着我。不忍心划伤中控大屏，直接买个钢化膜贴一下。 zhong 8. 挪卡车 telCard 在汽车越来越普及的现在，尤其是在杭州，找个车位真心是比较费力的事情。偶尔有事临时停靠一下如果不小心挡住了别人的车又联系不上人的时候就尴尬了，留个联系方式终究是好的。 9. 自动落锁+升降窗 autoLock 不得不吐槽一下，新思域各种配置齐全，唯独差了自动落锁和升降窗(我的是思域 2016款 220TURBO 自动尊贵版 )。直接淘了一个一体机加装一下。 10. 野炊地毯+帐篷 出去玩的时候总不能一直坐地上，买个毯子还是很有必要的。湖边风景虽然美，但是冷嗖嗖的风吹着还是挺难受的，因此还缺一个帐篷。 outUse 11. 迎宾踏板+ 档泥板 踏板不仅能提升逼格，更能防脏。尤其是雨天踩了一脚的泥，你就体会到了它的作用了。挡泥板也是一样，因为现在还没有上牌，所以挡泥板还安安静静的躺在后备箱，等上了牌照再搬出来装上吧。 guest 12. 炭包 新车多少会有些味道，虽然多透气可以快速去味。但是你总不能上班的时候将窗子开着离开,这就尴尬了。尤其是真皮座椅味道有点重,所以买几个炭包放车上是很有必要的。可以买内装炭包的玩具狗之类的美观又实用。 dog 13. 车载香水+汽车摆件 这些东西伴随着一定的危险性，因为在急刹车或者急加速的时候由于惯性这些东西可能会变成危险品。如果对这些没有要求的可以干干净净的也不错。我买了车载香水，还是因为真皮座椅味道比较重，想压一下味道。这些东西在买的时候基本上都会送防滑垫，如果没有防滑垫，还是赶紧买一个吧,毕竟安全最重要。 cologne 14. 靠背收纳袋 不得不说新思域的空间简直无可挑剔，溜背式的设计坐在后排也不会觉得挤，还可以把中间靠背打开放杯子，当手托,因此考虑加一个收纳袋。美中不足的是排气管凸起来，坐在中间的时候脚放着不舒服。 jiaodian 15. 靠枕 开车的时候一定要找一个舒服的姿势，当然还得配一个舒服的靠枕。 makuna 16. 后备箱垫 自己的爱车当然希望当干干净净的，放个垫子清理的时候直接拿出来倒掉渣子十分的方便。 backDian 17. 钥匙扣 小巧的钥匙没有钥匙扣万一丢了可就麻烦了。 key 18. 自驾游工具包 里面包括拖车绳啊，手电啊乱七八糟以防万一的东西,平时一直用不上。但万一到了要用的时候，却没有备是多么的悲催。 outTools 19. 玻璃水 刮雨器在清理前玻璃的时候如果不喷水会很脏,放自来水的话万一哪天温度低于0度冻坏了就坑了。玻璃水也很便宜，买几瓶放到后备箱。 glassWater 20. 前雷达 因为标配没有前雷达,加上驾驶位座位比较低.经常担心车头被擦到,装个雷达让自己省心一点. 大概或许这么多己经可以了，以后需要什么的话再补充吧。 jiaodian jiaodian jiaodian "],["使用vim打开文件时tab补全忽略大小写设置","2017年02月02日","/2017/vimtabautocomplete/","在elementary os 中默认开启了tab补全忽略大小写的设置，感觉用着特别方便。但是阿里云centeros并没默认开启，因此折腾了一下。 参考:http://blog.csdn.net/u012805048/article/details/53291482 1、在用户家目录下创建“.inputrc”文件。 touch .inputrc 2、在该文件中输入以下内容“set completion-ignore-case on” vi .inputrc 输入set completion-ignore-case on :wq 保存并退出 3、关闭终端，重新打开终端即可。 顺便贴一个升级vim到最新的方法 http://www.linuxprobe.com/vim8-0-linux.html ,看来我是需要找时间拜读一下这本著作了。 "],["win7系统登录不上onenote的解决方案","2017年02月02日","/2017/win7onenote/","因为有些软件没有linux版本的缘故,于是在linux上装了个win7的虚拟机.愉快的双机一起撸,各种软件装的不要太愉快。但是到了oneNote的时候,安装不仅很慢。而且还不能登录,真是急坏我胡汉三了。 当我艰辛的等oneNote安装完之后登录,一次\u0026hellip;两次\u0026hellip;N次。。。我擦，竟然登录不上，于是在网上各种姿势试。总结出来以下几种： 删注册表 修改dns 升级ie版本 当我做完所有尝试之后,发现只有升级ie版本是有效的。因为oneNote登录的时候调用的是ie浏览器,oneNote不支持低于ie9以下的浏览器，所以会出现登录不上的问题。 附上解决方案 http://cn.onenotegem.com/24120352653838239064/-onenote-2016 真是良心之作，让我成功的用回了oneNote,万分感谢。 "],["在linux系统下格式化移动硬盘的操作","2017年02月02日","/2017/formatdisk/","由于将移动硬盘装成了linux,因此它的格式在win下面读不出来了。打算在linux系统下将它给格成ntfs,所以有了以下这篇博客。 一 查看硬盘 sudo fdisk -l 找到自己的那块硬盘，一般为 /dev/sdb 2、 安装ntfs工具 为了使用ntfs分区，安装ntfs-3g 下载 3、 格式化 格式化成ntfs： mkfs.ntfs /dev/sdb1 不知道是不是我个人原因，我的是希捷1T的硬盘，花了我好几个时间。 4. 挂载磁盘 mount -t ntfs-3g /dev/sdb1 /mnt "],["linux系统环境下使用idea遇到的问题及解决方案","2017年02月02日","/2017/linuxideasetting/","最近将系统切换到linux下，使用的发行版本是elementary os 0.4,花了几美刀在官网买的。在使用idea的过程中遇到了一些问题，在此记录一下。 一 使用linux的忠告 你必须有一定的linux基础。 你要拥有和我一样不折腾会死星人的精神。 不要用windows的思维来思考linux的逻辑。 权限，权限，权限，重要的事情说三遍。 拥有开源精神，参与github。 会命令行就别去点图形界面。 vim和emacs总要会一个。 很多人看到我写了这么大一堆，用个linux还有这么多要求？这不是要求，而是建议。你掌握以上能力能够让你在linux系统下如虎添翼，不然只能寸步难行，走上重装——装环境——搞死系统——再重装的噩梦之路。 二 使用root权限启动idea 起因:因为我们开发的游戏中，沙箱启动端口是843。linux下1024以下的端口必须有root权限才能启动。 1. 开始折腾 elementary os 是基于ubuntu系统的。ubuntu是不能允许直接用root登录系统的，只能通过sudo的方式获取root权限。我才开始想着给它root权限就行了，于是我这样做: ，这样总行了吧。然后启动项目，运行沙箱。fuck\u0026hellip;依旧 access denied，我这就郁闷了。在我百般折腾之后，我这样做： ,设置一下别名 ，然后 一下。以后我启动项目就可以直接 就可以启动了。至此折腾完毕，这个问题解决了，其实大多数人不会遇到这个问题，因为我们测试项目的话一般都是8080——10000之间，这些端口都是可以随便使用不用root权限的。像我们公司的项目比较特殊，客户端请求的是843端口，我不可能因为这个原因去改游戏端口，所以只能想办法获取root权限，才有了以上的折腾。 二 linux下idea的ctrl+ space 占用 用window的时候没影响，但是linux下的idea的智能提示键和输入法切换的键冲突了，因此我们改一下idea的keymap 修改方法如下： 点击 文件菜单(File) –\u0026gt; 点击 设置(Settings… Ctrl+Alt+S), –\u0026gt; 打开设置对话框。 在左侧的导航框中点击 KeyMap。 接着在右边的树型框中选择 Main menu –\u0026gt; Code –\u0026gt; Completion. 接着需要做两件事： 移除原来的Cycle Expand Word 的 Alt+斜杠 快捷键绑定。 在 Basic 上点击右键,去除原来的 Ctrl+空格 绑定,然后添加 Alt + 斜杠 快捷键。 然后应用(Apply), OK. 三 linux下idea编辑器无法输入中文 不知道各位在linux系统下使用idea有没有遇到这个问题，但是通过百度发现还有有多少遇到这种问题的。虽然答案千奇百怪，不一定起作用。但是通过折腾之后终于发现在可以使用的方法，设置如下： 解决方法 在IDEA的bin目录下的idea.sh文件的前面加上 export XMODIFIERS=@im=fcitx export QT_IM_MODULE=fcitx 如果是使用vim编辑 的话一下要加 ,保存时用 四 感叹 切换到linux也有半个多月了，现在终于差不多适应了。从才开始的linux mint 17到现在的elementary os，还是爽舒服的。 "],["接口格式返回大小写处理.","2017年01月01日","/2017/javaapijsonformat/","前言：在写java api的时候会因业务复杂情况遇到各种棘手问题。比如说基于己有数据库开发移动端应用的时候，hibernate这种映射框架用着就不爽了，于是我切换到了myatis上，因为它灵活度够高 。这次要讲的主题是当数据库设计人员坑B的将java关键字设置为字段名的时候，现在的你是不是万脸懵逼状态。心里一万只草泥马在奔腾，这谁TM设计的数据库，出来我保证不打死它。 这应该是我2017年的第一篇博客了，不要误会我在偷懒。相反，我一直在充电，写文章的时间就少了。所以就采取了偷懒的办法，直接把网上搜到的链接贴在发的帖子下面，算作一个系列。比如最近研究的android,android环境搭建 ，这篇文章下面有N多干货可以学习。 并且现在习惯将东西放在 OneNote 笔记本上，有图为证。 oneNote 好了，不扯了正题开始。 一、案例 某XX将数据库数据库字段名定义为 , 无解！ 二、处理办法 我们知道数据库的字段是大小写不敏感的，java的属性是大小写敏感的。因此，在 鸡治的告诉我定义一个不是关键字的 属性接收，经过测试，竟然没问题。。。。 于是，我将实体类义为以下所示。 cLass 启动服务，查看结果。。 json 小小的激动了一把，但这终究是个取巧的办法。其实在这之前我也查了许多资料。有提到 和 ,但是测试都没有成功。按理推测，无论是在hibernate中还是mybatis中都应该有一个注解可以定义为如下这种。 格式 @我需要的注解(value = \u0026ldquo;数据库字段(java关键字)\u0026rdquo;) private String 任意属性名; 举例 @XXX(value = \u0026ldquo;class\u0026rdquo;) private String activityGoal; 学海无涯，需要我们不断的探索。越往深学，越觉得自己懂的少。感叹时间不够用，2016就这么过去了。2017，又要获得些什么。我想好好静下心下看一下《think in java》，想好好读读《Java设计模式》，想好好学日语早日过N1。时间那么少，想做的事情却太多。与君共勉，2017，一起加油！ "],["2016年终总结(进入游戏行业)","2016年12月12日","/2016/summary/","前言:由于春节回家了一趟，家里没网。导致我的github长达半个多月没有更新，看着一大块灰朦朦的，心情倒还是有点小失落。今天正式回归工作岗位，发现还是安安静静的上班适合我的生活。 PS:写完之后才发现，啊，不知不觉竟然码了这么多字，看来我也是个有情怀(HHKB)的人。 一、大事记 1. 回顾2016 决定到杭州: 还在学校时的我对未来还真的是有点担忧的，尤其是快要实习的时候，一直在考虑着去哪里。相信大部分刚毕业的同学都会遇到这个问题。武汉的招聘会跑了个遍，发现并没有多少合适的工作。去腾讯面试，结果第三轮被刷了，掩面痛哭。 由于都没有找到合适的工作，2014年5月份和基友一起只身几百RMB身家跑来杭州找工作，印象深刻当时是在打铁关附近找的酒店。值得一提的是，我们在这里一周，门缝里塞的小卡片收集起来好厚一札。还好我们禁住了诱（穷）惑(屌)。穿着西装，蹬着皮鞋，早起晚归。啊，那是我逝去的青春。 决定做互联网行业： 作为文科出身的我没有机会选择计算机专业，所以在大学基本上没学到什么东西。然而我就凭着这一股拼劲，自己贷款去培训Java,正式走上我的编程之路。往事不堪回首，但是正是这些磨练让我不断成长。 接触到动漫、日语： 自古喷子层出不穷，很多人无脑抵制这个抵制那个，我不知道他们过的累不累，反正我觉得只要我喜欢的，我一定会努力追求。这不，最近又成功安利了一个小伙伴入了动漫的坑，一起享受动漫的乐趣，真是觉得很有意思呢。我就是这样，遇到好东西，我总想把它分享给全世界喜欢它的人。还在大学时经常看动漫，也动过学日语的念头，然而自制力不好的我还没学会50音图就放弃了。毕业后很巧有机会进入日企实习，然后在全日语的环境下做java开发。没有网络，不能玩手机，直接一个终端连接到东京的机房做开发。旁边一个大电视直接远程视频沟通，觉得真的好棒。虽然那个时候过的很苦，但是依旧很快乐。我觉得如果没有当时的磨练，也不会有现在的我。实习一年顶我大学3年，说出来还真是有点迷之尴尬，说明我大学是个废柴，没有努力学习。现在我依旧爱着动漫，依旧努力学着日语。我相信以后也会。 主系统换到mac os： 经济不宽裕的我狠心买了一个mac book air,虽然是乞丐版。但是用起来依旧很舒服。这是我第一次近距离接触类linux系统。说实话，mac的体验真的要比win好太多了。不会动不动出现卡死的情况，也不用开机等待好几分钟都反应不过来。开盖编程，合盖休息。不用考虑关机、开机。自带终端。重量轻便，外观漂亮各种各种，真的太多就不一一列举。到现在为止己经2年了，系统用起来依旧非常流畅。还治好了我玩PC游戏的毛病，真是一举多得。 加入“盛和”大家庭： 2015年加入，当时公司只有不到60个人到现在的近200人。慢慢发展到后来占地2层楼，公司项目月流水过2亿，去三亚旅游。曾经因为公司的单休制度打算换个环境，后来因为CTO的挽留又打消了念头。在这里也非常感觉我们CTO的照顾，很庆幸自己从实习以来遇到了几个好领导和好同事。感觉他们的带领和理解，我才能够越走越远。 进入游戏行业： 其实也就是加入新公司之后。以前一直是做java web的企业级项目，那个时间我的代码水平很菜，真的很菜，菜到连我自己都不想提起。但是随着自己工作时间越来越长，github上泡的时候越来越久。我也从当初的小菜鸟慢慢的变成现在的老菜鸟。哈哈，虽然都是菜鸟，但鸟还是老的好。从以前只知道玩游戏的我，到现在可以参与制作大型rpg网络游戏的开发，真的觉得很刺激。还记得当初因为玩电脑和父母发生过不少争执，从小被成为网瘾少年。如今己经过了十多年，从当初的网瘾少年成长为现在的网瘾青年。我相信我还会晋级到网瘾中年，网瘾老年。活到老，学到老。生命不停，折腾不止。是我终生的信仰。 入了机械键盘的坑： 以前偶尔和朋友去网吧玩lol的时候使用到机械键盘，当时只觉得手感好像还不错。渐渐的公司同事都开始把键盘换成了机械的，我也开始在网上了解。从此一发不可收拾，成了键盘发烧友。入了一个初级键盘雷柏v500s青轴,价格只要200。200你买不了吃亏，200你买不了上当，我拿着这不顶用的200买了个键盘，从此开始了噼里啪啦编程生活，幻想着走向人生巅峰。然而敲击声有股浓浓的塑料感再次让我感觉到迷之尴尬，并且觉得声音有点大，听着同事那cherry3000，妇科圣手清脆的声音，吓的我按键盘都是轻轻的。无赖之下我开始了新的烧键盘之旅，借助着网络的强大力量。我发现了程序员梦寐以求的神器——HHKB，奈何身为穷DS的我并没有能力拥有这把神器。于是各种纠结之下买了一把 DUCK2108S,花了我大约600大洋。直到现在，我一直后悔着后悔着，因为我买了把红轴。因为不太喜欢，所以也没怎么爱惜，我的电脑桌也是我的餐桌，经常会进点东西到键盘里。那个脏的我己经没有脸拿出来了。再三考虑之下，我终于入手了HHKB，值得一提的是这个键盘算是键盘界的奇葩，只有60个键。不是每个人都能驾驭得了的，我一直到现在都还是慢慢习惯，现在这篇文章都是用HHKB敲的，不得不说这手感，真是越用越带劲。下面上一张我HHKB的美图。 hhkb 学习前端和android： 从毕业后一直做着后端的开发，对前端的知识了解的不多。在不忙的时候研究了大量关于前端的知识，了解其运行原理。包括自动构建工具 gulp、webpack，编程语言 nodejs、javascript，清楚了es5和es6的区别。 和monsterlin一起合作开发app: 在开发的过程中加深了沟通和交流，了解了app开发如何配合。其实跟做游戏一样，服务端和客户端的密切配合是完成工作的前提，如果遇到困难互相推诿，是做不出好的产品的。我是一个性子比较急的人，如果事情一旦决定好了就会抓紧事情去做。 决定学好linux: 其实从实习开始一起在使用linux。那个时间在日企实习，给了一个文档，然后让我照着命令操作。当时的我完全不明白我在做什么事情，但是终究还是达到了自己想要的效果。到后来开始接触linux系统，买了阿里云服务器和域名。愉快的折腾起了linux。环境安装、nginx、tomcat、redis、nodejs各种各种，就这样一直折腾着来到了2017。现在我打算从头开始系统的折腾一遍，所以我装了linux系统，下载了《linux就该这么学》，我的linux之路，正式开启吧！ 开通了自己的博客： 从开通博客开始，我花了大量的时间来折腾它。从此也养成了写博客的习惯。不过我的OneNote笔记中的内容更多。哈哈哈，无耻的笑了。我可是折腾过印象、有道云、为知等等各种知名产品最终用上了OneNote的哟。 在此也安利一波，别像我一直折腾这么久，导笔记可是件痛苦的事情。继续正题，讲到哪了。啊，对，说到博客了，瞧我这记性。阿里云服务器、万网域名、配上nginx服务器和git。使用起来不要太方便。因为我不是个贪图安逸的人，于是我努力的学前端，学习nodejs。折腾自己的主题。结果，我成功的把移动端的blog玩坏了。。。强势打脸，我还说我前端能力还不错来着。开通博客也有一年的时间了，虽然没怎么去宣传，但是通过github上链接过来的人访问量也快过万了，还是比较开心的。 我与github的不解之缘： 从cvs到svn再到现在的git,由衷的感叹git真是一款工匠级的优秀产品。 github2017 从github的更新记录来看，我使用github己有一年多时间，在这一年多来我通过github学到了很多很多的东西。至此做个总结吧 github用途 代码控制 当然，这也是最重的，我把我所有的代码全部开源放在我的github上面。在和各位大牛沟通的过程中，自己的能力也在不断提升。 项目合作 在使用github管理代码的时候，当然也可以使用github管理项目。合理的使用github的issue和wiki能够使让工作更加得心应手。 文字管理 不少以写作为主的大牛们也在开始使用github写文章。其中就有大牛阮一峰老师，在我的github中有很多业界大牛，时常翻一翻他们的github，能够让自己更有动力学习下去。从不追星的我，在面对各位大牛的时候还是忍不住“向大佬递茶的”冲动。 其他各种 其实，github的用途远远不止如此。在这里，不仅能够分享自己的代码，也能够查找你想要的代码，学习先进的思想。只要你想，就可以在github上顺手的帮你做各种事情。包括奥巴马总统也使用github发布自己的一些动态。在互联网界，github被戏称为 the biggest 同性交友网站。当然，这个交往，是互相学习和进步。 终于有了自己的车车： 因为老家是湖北省武当山那旮旯子的，过年回个家不亚于打仗，每年过年回家都是一个痛苦的过程。幸好去年有个神级软件 12306分流抢票 ，它彻底拯救了我也拯救了我认识的几个朋友。通过它的力量我不仅帮自己买到了火车票，也帮好几个朋友买了到票。如果你过年的时候也在受抢票之苦，那么恭喜你,拯救你于水火之中的家伙可以上场了(我就是这么乐于分享的人，不用谢，我叫雷锋)。说到这里，我怎么感觉我像在做传销的。算了，上张图为证吧。。 12306 说到上图，我真的想吐槽12306太垃圾了。抢不到票用使用的人多的理由搪塞也就罢了，客户端打开时不时卡死又是什么鬼。我真的想说，垃圾软件，毁我青春！算了，咱们还是继续说车。公司同事一个两个都买车了，耳濡目染之下也在也在看车，鬼使神差迷上思域不能自拔。预算12万，直接提到15万。结果到4s店一问要16万还没有现车。只有次顶配现车，一时冲动直接到18万。让我先哭一会儿，接下来的时间我要开始吃土了，都不要拦我。最后多谢我们CTO力哥，车神曲老板，新晋车神小陈，预备车神强总带我去看车。这几天一直在淘各种汽车小配件，哈哈，其乐无穷。 car 顺便再贴一个视频实拍 车身修长更加运动 实拍2016款全新思域 与各位小伙伴的“基情”： 两个高中同学兼大学同学，表妹，基友在杭州各自有了自己稳定的工作，在此也祝愿他们越来越好。在工作的过程中认识了很多有爱的同事，也在网上认识了很多大牛，尤其是还在学校都己经到了我望尘莫及的高度，一直激励着我进步。与志同道合有朋友们一起交流，海天海地，真的挺有意思。 2.展望2017 年底准备结婚了： 和女朋友在一起三年了，终于可以把她的户口转到我家来了。中间有过各种矛盾，酸甜苦辣。不过到最后都是甜蜜的回忆和满满的感动。 准备在杭州定居： 对于现在的我们来说这是件比较困难的事，但是有了目标终究是要好好努力的。来杭州第三年了，待的越久越喜欢这里。 继续努力学习日语： 希望自己努力学早，早日考过N2,奋战N1，然后去外面的世界闯一闯。 努力学习linux: 不仅因为它很帅，更因为它很实用。很符合极客风范，更因为我用了HHKB，也因为我爱折腾。理由很多，但最重要的是我喜欢。因为我爱，所以我想学。2017，我会加更努力。 认真学习《linux就该这么学》和《java编程思想》 练好开车技术,为了自己,能够自己开车回老家，也为了别人。 最后奉上我的人生格言 生命不停，折腾不止。 2017，开始新一年的折腾 "],["mysql常用操作","2016年12月12日","/2016/mysqlcommon/","这篇文章主要介绍了mysql的用法，包含安装、常用命令等等 一、环境 linux centerOs 6.5 mysql 最新 二、安装 1. yum安装 yum安装mysql 安装结果： 启动MySql服务 命令登录mysql 查询用户的密码，都为空，用下面的命令设置root的密码为root 设置MySQL的root用户设置密码 用新密码登陆 基本命令 2. 源码安装 1.假设已经有mysql-5.5.10.tar.gz以及cmake-2.8.4.tar.gz两个源文件 (1)先安装cmake（mysql5.5以后是通过cmake来编译的） (2)创建mysql的安装目录及数据库存放目录 (3)创建mysql用户及用户组 (4)安装mysql 复制代码 复制代码 参数说明： 注意事项： 重新编译时，需要清除旧的对象文件和缓存信息。 2.配置 (1)设置目录权限 (2) (3)创建系统数据库的表 (4)设置环境变量 复制代码 复制代码 (5)手动启动mysql 复制代码 启动日志写在此文件下： 关闭MySQL服务 复制代码 (6)另一种简单的启动mysql的方法(mysql已经被添加到系统服务中) 如果上述命令出现：mysql.server 未识别的服务 则可能mysql还没添加到系统服务中，下面用另一种方法添加： 注意：主要是将mysql.server拷贝到/etc/init.d中，命名为mysql。在有的系统中，mysql.server在/usr/local/mysql/share/mysql/mysql.server中，而本系统中，mysql.server在/usr/local/mysql/support-files/mysql.server中。 然后再用 来启动mysql即可。 (7)修改MySQL的root用户的密码以及打开远程连接 复制代码 重新登录： 若还不能进行远程连接，则关闭防火墙 复制代码 注：如果不能远程连接，出现错误 ，则加入下面语句试试： 三、加入service和自启动 将找到的文件copy到init.d下 加入到系统启动项 设置开机启动 四、设置编码 MySql修改数据库编码为UTF8 mysql 创建 数据库时指定编码很重要，很多开发者都使用了默认编码，乱码问题可是防不胜防。制定数据库的编码可以很大程度上避免倒入导出带来的乱码问题。 网页数据一般采用UTF8编码，而数据库默认为latin 。我们可以通过修改数据库默认编码方式为UTF8来减少数据库创建时的设置，也能最大限度的避免因粗心造成的乱码问题。 我们遵循的标准是，数据库，表，字段和页面或文本的编码要统一起来 我们可以通过命令查看数据库当前编码： 发现很多对应的都是 latin1，我们的目标就是在下次使用此命令时latin1能被UTF8取代。 第一阶段： mysql设置编码命令 然后 你可以看到全变为 。 但是，这只是一种假象 此种方式只在当前状态下有效，当重启数据库服务后失效。 所以如果想要不出现乱码只有修改my.ini文件， 从my.ini下手（标签下没有的添加，有的修改） 以上3个section都要加default-character-set=utf8，平时我们可能只加了mysqld一项。 然后重启mysql，执行 确保所有的Value项都是utf8即可。 但是可恶的事情又来了， 注意 该配置| character_set_server | latin1 无法设置成UTF8 交互时候仍然会出现乱码。 第二阶段：找到下面这东东 重新启动设置，将默认编码设置为utf8.这样就能达到我们所要的效果了。 另外注意事项： 1、建表时加utf8，表字段的Collation可加可不加，不加时默认是utf8_general_ci了。 2、网页xxx.php/jsp保存时选择utf8编码，页头最好加上 在执行CRUD操作前先执行一下 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- 连接数据库设置编码 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- java中的常用编码 对应mysql数据库中的编码 五、 设置权限 开放远程登录权限 六、创建用户 1.创建账户 2.授权 3.设置和修改密码 4.撤销权限 七、存储过程 我们常用的操作数据库语言SQL语句在执行的时候需要要先编译，然后执行，而存储过程（Stored Procedure）是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给定参数（如果该存储过程带有参数）来调用执行它 1.存储过程简介 我们常用的操作数据库语言SQL语句在执行的时候需要要先编译，然后执行，而存储过程（Stored Procedure）是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给定参数（如果该存储过程带有参数）来调用执行它。 一个存储过程是一个可编程的函数，它在数据库中创建并保存。它可以有SQL语句和一些特殊的控制结构组成。当希望在不同的应用程序或平台上执行相同的函数，或者封装特定功能时，存储过程是非常有用的。数据库中的存储过程可以看做是对编程中面向对象方法的模拟。它允许控制数据的访问方式。 存储过程通常有以下优点： (1).存储过程增强了SQL语言的功能和灵活性。存储过程可以用流控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。 (2).存储过程允许标准组件是编程。存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句。而且数据库专业人员可以随时对存储过程进行修改，对应用程序源代码毫无影响。 (3).存储过程能实现较快的执行速度。如果某一操作包含大量的Transaction-SQL代码或分别被多次执行，那么存储过程要比批处理的执行速度快很多。因为存储过程是预编译的。在首次运行一个存储过程时查询，优化器对其进行分析优化，并且给出最终被存储在系统表中的执行计划。而批处理的Transaction-SQL语句在每次运行时都要进行编译和优化，速度相对要慢一些。 (4).存储过程能过减少网络流量。针对同一个数据库对象的操作（如查询、修改），如果这一操作所涉及的Transaction-SQL语句被组织程存储过程，那么当在客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而大大增加了网络流量并降低了网络负载。 (5).存储过程可被作为一种安全机制来充分利用。系统管理员通过执行某一存储过程的权限进行限制，能够实现对相应的数据的访问权限的限制，避免了非授权用户对数据的访问，保证了数据的安全。 关于MySQL的存储过程 存储过程是数据库存储的一个重要的功能，但是MySQL在5.0以前并不支持存储过程，这使得MySQL在应用上大打折扣。好在MySQL 5.0终于开始已经支持存储过程，这样即可以大大提高数据库的处理速度，同时也可以提高数据库编程的灵活性。 MySQL存储过程的创建 (1). 格式 MySQL存储过程创建的格式：CREATE PROCEDURE 过程名 ([过程参数[,\u0026hellip;]]) [特性 \u0026hellip;] 过程体 这里先举个例子： 注： （1）这里需要注意的是DELIMITER //和DELIMITER ;两句，DELIMITER是分割符的意思，因为MySQL默认以\u0026quot;;\u0026ldquo;为分隔符，如果我们没有声明分割符，那么编译器会把存储过程当成SQL语句进行处理，则存储过程的编译过程会报错，所以要事先用DELIMITER关键字申明当前段分隔符，这样MySQL才会将\u0026rdquo;;\u0026ldquo;当做存储过程中的代码，不会执行这些代码，用完了之后要把分隔符还原。 （2）存储过程根据需要可能会有输入、输出、输入输出参数，这里有一个输出参数s，类型是int型，如果有多个参数用\u0026rdquo;,\u0026ldquo;分割开。 （3）过程体的开始与结束使用BEGIN与END进行标识。 这样，我们的一个MySQL存储过程就完成了，是不是很容易呢?看不懂也没关系，接下来，我们详细的讲解。 (2). 声明分割符 其实，关于声明分割符，上面的注解已经写得很清楚，不需要多说，只是稍微要注意一点的是：如果是用MySQL的Administrator管理工具时，可以直接创建，不再需要声明。 (3). 参数 MySQL存储过程的参数用在存储过程的定义，共有三种参数类型,IN,OUT,INOUT,形式如： CREATE PROCEDURE([[IN |OUT |INOUT ] 参数名 数据类形\u0026hellip;]) IN 输入参数:表示该参数的值必须在调用存储过程时指定，在存储过程中修改该参数的值不能被返回，为默认值 OUT 输出参数:该值可在存储过程内部被改变，并可返回 INOUT 输入输出参数:调用时指定，并且可被改变和返回 Ⅰ. IN参数例子 创建: 执行结果: 以上可以看出，p_in虽然在存储过程中被修改，但并不影响@p_id的值 Ⅱ.OUT参数例子 创建: 执行结果: Ⅲ. INOUT参数例子 创建: 执行结果: (4). 变量 Ⅰ. 变量定义 其中，datatype为MySQL的数据类型，如:int, float, date, varchar(length) 例如: Ⅱ. 变量赋值 Ⅲ. 用户变量 ⅰ. 在MySQL客户端使用用户变量 ⅱ. 在存储过程中使用用户变量 ⅲ. 在存储过程间传递全局范围的用户变量 注意: ①用户变量名一般以@开头 ②滥用用户变量会导致程序难以理解及管理 (5). 注释 MySQL存储过程可使用两种风格的注释 双模杠：\u0026ndash; 该风格一般用于单行注释 c风格： 一般用于多行注释 例如： MySQL存储过程的调用 用call和你过程名以及一个括号，括号里面根据需要，加入参数，参数包括输入参数、输出参数、输入输出参数。具体的调用方法可以参看上面的例子。 MySQL存储过程的查询 我们像知道一个数据库下面有那些表，我们一般采用show tables;进行查看。那么我们要查看某个数据库下面的存储过程，是否也可以采用呢？答案是，我们可以查看某个数据库下面的存储过程，但是是令一钟方式。 我们可以用 或者 或者 进行查询。 如果我们想知道，某个存储过程的详细，那我们又该怎么做呢？是不是也可以像操作表一样用describe 表名进行查看呢？ 答案是：我们可以查看存储过程的详细，但是需要用另一种方法： SHOW CREATE PROCEDURE 数据库.存储过程名; 就可以查看当前存储过程的详细。 6.MySQL存储过程的修改 更改用CREATE PROCEDURE 建立的预先指定的存储过程，其不会影响相关存储过程或存储功能。 MySQL存储过程的删除 删除一个存储过程比较简单，和删除表一样： 从MySQL的表格中删除一个或多个存储过程。 MySQL存储过程的控制语句 (1). 变量作用域 内部的变量在其作用域范围内享有更高的优先权，当执行到end。变量时，内部变量消失，此时已经在其作用域外，变量不再可见了，应为在存储 过程外再也不能找到这个申明的变量，但是你可以通过out参数或者将其值指派 给会话变量来保存其值。 (2). 条件语句 Ⅰ. if-then -else语句 Ⅱ. case语句： (3). 循环语句 Ⅰ. while ···· end while： Ⅱ. repeat···· end repeat： 它在执行操作后检查结果，而while则是执行前进行检查。 Ⅲ. loop ·····end loop: loop循环不需要初始条件，这点和while 循环相似，同时和repeat循环一样不需要结束条件, leave语句的意义是离开循环。 Ⅳ. LABLES 标号： 标号可以用在begin repeat while 或者loop 语句前，语句标号只能在合法的语句前面使用。可以跳出循环，使运行指令达到复合语句的最后一步。 (4). ITERATE迭代 Ⅰ. ITERATE: 通过引用复合语句的标号,来从新开始复合语句 9.MySQL存储过程的基本函数 (1).字符串类 注：mysql中处理字符串时，默认第一个字符下标为1，即参数position必须大于等于1 (2).数学类 注：返回类型并非均为整数，如： (1)默认变为整形值 (2)可以设定小数位数，返回浮点型数据 (3).日期时间类 "],["博客域名迁移(从二级域名迁移到一级域名).","2016年12月12日","/2016/blogtoxiaomo/","折腾完https之后在考虑SEO优化的问题，HTTPS对搜索收录更加友好。既然要友好，就要做到底，一级域名的SEO和比二级域名权重高，因此考虑把博客从二级域名迁移到一级域名。(生命不息折腾不止！) 从https://blog.xiaomo.info 迁移到https://xiaomo.info 一、迁移原因 1、 SEO 折腾完https之后在考虑SEO优化的问题，HTTPS对搜索收录更加友好。既然要友好，就要做到底，一级域名的SEO和比二级域名权重高，因此考虑把博客从二级域名迁移到一级域名。(生命不息折腾不止！) 2、 记忆 域名更短，更好记 3、 权重 一级域名的权重比二级域名高。 二、迁移过程 1、证书 重新去腾讯云申请个SSL证书 2、DNS解析 按照腾讯云给和CNAME添加一个解析 3、 nginx配置 换一下证书就可以了 三、迁移结果 1、域名 从https://blog.xiaomo.info 迁移到https://xiaomo.info 2、损失 迁移了域名，站点访问量开始从0算起。一切从头开始，总感觉有点回到解放前的感觉。不管怎么说，一切按照预想达到了，这样不好。不是吗？ "],["Sublime Text 3 使用配置与插件安装","2016年11月11日","/2016/sublimeconfig/","　记录安装配置 Sublime 的过程，同时列出所用到的插件，方便自己在新系统新电脑上快速用上熟悉的 Sublime。 开始使用 软件下载 一直使用的是 Sublime 3，直接转到 3 的 下载页面 好了。 用户设置 ，设置字体为 Consolas 雅黑混合体 yx5g，字号11，tab 转空格，显示空格和制表符。 其他设置参考 。 基础插件 Package Control Package Control 用于管理插件的插件，基础中的基础。之后列的插件全部通过 Package Control 安装。 插件使用与安装: https://packagecontrol.io/installation Convert​To​UTF8 文本编码自动转换，减少中日韩文乱码问题。 插件安装: Ctrl+Shift+P, Package Control: Installed Packages, 搜索 Convert​To​UTF8 IMESupport 解决输入法选字框不跟随问题。 Side​Bar​Enhancements 自带边栏功能太少，必须安装此插件增强一下。 主题配色 Theme - Spacegray Spacegray 主题的 Base16 Eighties Dark 配色方案看着最顺眼，用着最舒服。 Base16 Eighties Dark color scheme 代码规范 Sublime​Linter 用于管理其他 code linting 代码规范插件。 使用说明: http://sublimelinter.readthedocs.org/en/latest/installation.html#installing-via-pc Sublime​Linter-jshint 基于 JSHint ，用于检查规范 JavaScript 代码。 NPM 依赖包: 使用说明: https://github.com/SublimeLinter/SublimeLinter-jshint Sublime​Linter-csslint 基于 CSSLint ，用于检查规范 CSS 代码。 NPM 依赖包: 使用说明: https://github.com/SublimeLinter/SublimeLinter-csslint Sublime​Linter-contrib-htmlhint 基于 HTMLHint ，用于检查规范 HTML 代码。 NPM 依赖包: 使用说明: https://github.com/mmaday/SublimeLinter-contrib-htmlhint 常用插件 HTML-CSS-JS Prettify 格式化 HTML, CSS, JavaScript 及 JSON 代码。 Color Highlighter 直接在代码中预览颜色。 Stylus 使代码高亮支持 Stylus。 Stylus Clean Completions Stylus 代码自动补全。 AutoFileName 文件名自动补全。 AutoFileName Can I Use http://caniuse.com/ 的插件版，快速查询 HTML, CSS 等前端技术的浏览器兼容性 BracketHighlighter 调整各类括号匹配的高亮样式 To be added 相关链接 Package Control: https://packagecontrol.io/ SublimeLinter: http://sublimelinter.readthedocs.org/ JSHint: http://jshint.com/ CSSLint: https://github.com/CSSLint/csslint HTMLHint: http://htmlhint.com/ Stylus: http://learnboost.github.io/stylus/ "],["拥抱https(http全面切换到https)","2016年11月11日","/2016/httptohttps/","在百度和谷歌的鼓励下，现在很多网站都开始换成https了啊，只是有的没有隐私数据的网站感觉没有太大必要，但是设计要密码账号的网站必须要的。不过有部分网站没有换成https只是暂时的，2-3年后预估互联网会全部变成https。因为https成本也不是很高，免费SSL证书也有，比如腾讯免费SSL证书，starssl免费证书等。关键是https对SEO更加友好。 准备工作 域 名：阿里云 服务器：阿里云ECS SSL证书: 腾讯SSL免费版 web容器：nginx+php 一、为什么要切换到HTTPS 1.安全方面 HTTPS比HTTP更加安全 2.技术方面 不懂HTTPS多不好意思啊，所以就当是学习了。 二、为什么要用腾讯SSL 因为免费啊，毕竟穷人用不起企业级别的，先用一年免费的再说。starssl是外国的，看不习惯鸟语还是老老实实用中文。 三、申请证书 申请地址：https://console.qcloud.com/ssl 申请证书之后会给一个下载链接，下载之后会有3个文件夹。分别是nginx、tomcat、apache。因为我个人用的是nginx，就说下nginx的配置。没有调查就没有发言权，用其他两种的小伙伴请自行研究。 四、DNS配置 证书申请通过之后会让你配置一个CNAME类型的DNS,然后把这个DNS在你的域名中添加一个cname的解析。 cname 五、上传 将下载的证书nginx文件夹打包上传到 目录 六、nginx配置 先确认 安装时已编译http_ssl模块，也就是执行如下命令查看是否存在\u0026ndash;with-http_ssl_module参数： 执行 这个命令 在返回的结果中找是否有 参数，没有的话要先激活这个模块。 然后在 中修改配置，配置如下 在server中加入以下内容，注意修改一下对应 和 文件的位置 这一段主要是开启SSL 保存配置之后要确认是否配置正确，执行 命令 重定向http到https,加入以下这段，意思是访问http的网站的时候会重定向到https上去。 七、生效 执行 ,如无错误，现在应该可以顺利访问 xiaomo.info 这个网站，并且是https的。 八、附录 nginx配置 参考资料 1. Linux+Nginx/Apache/Tomcat新增SSL证书，开启https访问教程 2. 让你的网站免费支持 HTTPS 及 Nginx 平滑升级 "],["swagger ui和spring boot集成生成api文档","2016年11月11日","/2016/javaspringbootswaggerui/","曾经一度我一直想在做前后端分离的时间写api接口是一个痛苦的过程，虽然也在网上找了一些可以填写api的系统，但使用起来总是不尽人意。现在，终于找到一款可以和api完美集成自动生成api文档加测试的工具，真是一件让人高兴的事呢。如果你也需要，那就好好看看这篇文章吧。 一、环境 1. JAVA8 2. MAVEN 3.0.5 3. IDEA 2016.2.5 4. spring boot 1.4.1 二、相关依赖 三、配置 设置了一些默认显示的api相关信息，最后上截图的时就可以比较清楚的看到。 四、相关注解解读 1. @Api 用在类上，说明该类的作用 2. @ApiOperation 用在方法上，说明方法的作用 3 @ApiImplicitParams 用在方法上包含一组参数说明 4. @ApiImplicitParam 用在@ApiImplicitParams注解中，指定一个请求参数的各个方面 paramType：参数放在哪个地方 header\u0026ndash;\u0026gt;请求参数的获取：@RequestHeader query\u0026ndash;\u0026gt;请求参数的获取：@RequestParam path（用于restful接口）\u0026ndash;\u0026gt;请求参数的获取：@PathVariable body（不常用） form（不常用） name：参数名 dataType：参数类型 required：参数是否必须传 value：参数的意思 defaultValue：参数的默认值 5. @ApiResponses 用于表示一组响应 6. @ApiResponse 用在@ApiResponses中，一般用于表达一个错误的响应信息 code：数字，例如400 message：信息，例如\u0026quot;请求参数没填好\u0026quot; response：抛出异常的类 7. @ApiModel 描述一个Model的信息（这种一般用在post创建的时候，使用@RequestBody这样的场景，请求参数无法使用@ApiImplicitParam注解进行描述的时候） 8. @ApiModelProperty 描述一个model的属性 五、 和Swagger UI的集成 首先，从github swagger-ui 上下载Swagger-UI, 把该项目dist目录下的内容拷贝到项目的resources的目录public下。 六、访问 http://localhost:8080/swagger-ui.html 就可以看到效果如下 七、 项目实例 https://github.com/JavaUsers/xiaomo-info-java/tree/master/website "],["lombok简化java代码注解的使用","2016年11月11日","/2016/javalombok/","今天在stackoverflow上回答问题的时候发现了几个不得了的注解，是我从来没有见过的。然后呢，为了回答别人的问题，我就去查资料了。。。觉得挺有用的，记录一下。。 一、缘由 在 上看到了这个问题。 spring boot RestController not work with lombok ,然后就有了这篇博客。。 二、lombok是什么鬼 1. maven引用 2. 一些api ombok 注解： lombok 提供的注解不多，可以参考官方视频的讲解和官方文档。 Lombok 注解在线帮助文档：http://projectlombok.org/features/index.html . 下面介绍几个我常用的 lombok 注解： ：注解在类上；提供类所有属性的 getting 和 setting 方法，此外还提供了equals、canEqual、hashCode、toString 方法 ：注解在属性上；为属性提供 setting 方法 ：注解在属性上；为属性提供 getting 方法 ：注解在类上；为类提供一个 属性名为log 的 log4j 日志对象 ：注解在类上；为类提供一个无参的构造方法 ：注解在类上；为类提供一个全参的构造方法 下面是简单示例 不使用 lombok 的方案 二、实践结果 我发现 的那个伙计代码写的并没有问题，我把他的代码粘到我本地运行没有一点卡壳。倒不如说他教会了我lombok，在此感谢一下。。嘿嘿 "],["spring boot做前后分离时间格式化","2016年11月11日","/2016/javaspringbootdataformat/","最近在用spring boot 做数据接口时难免遇到时间这类的问题，接口原则：能服务端处理的别留给客户端。客户端的职责就是把服务端的数据完美的展现出来就好了。所以在返回时间的时候最好先进行一下格式化处理，不要返回时间戳格式。 一、写一个 然后做一个时间格式化的处理 二、 使用 在需要转换的时间的Model中加上这个类,仔细观察下面代码中类型为 的属性 "],["spring boot做前后分离的跨域问题","2016年11月11日","/2016/javaspringbootcors/","最近在用spring boot 做数据接口供客户端调用时发现存在跨域问题，虽然解决问题有很多。比如用nginx处理等等。但是更方便的是服务端设置一下跨域名。 一、前提 1. 使用spring boot + maven 构建的项目 二、设置 1. 写一个过滤器(filter) 实现Filter接口，然后设置一下响应头。 2. 在启动器中加入过滤器 实质就是加了一个 ，然后在启动的时候通过过滤器把所有的响应头设置一下。 这样一来，客户端就不会存在跨域问题了。 "],["spring boot相关资料","2016年10月10日","/2016/javaspringziliao/","spring真是让人又爱又恨呢，好用但是难学。spring铺的又太大，不知道从哪入手。整理点资料，免得头晕。 一、spring boot 配置相关 1. 配置文件 properties 2. spring boot cli 安装和使用 下载zip压缩包并解压 配置环境变量 , path里加 测试是否成功 帮助 spring \u0026ndash;help 生成项目 spring init project_name 3. spring boot首页 4. 二、spring boot 常见错误 "],["Maven 与 IntelliJ IDEA 的完美结合","2016年10月10日","/2016/javaideamaven/","你是否正在学习Maven？是否因为Maven难用而又不得不用而苦恼？是否对Eclipse于Maven的冲突而困惑？ 那么我告诉你一个更直接更简单的解决方案: IntelliJ IDEA！ 1. 什么是 Maven，为什么要使用 Maven 而不是 Ant Maven简单来说是一个项目管理工具，被认为是Ant的替代品或者继任者。事实上Maven的功能要远远超出Ant，它不仅仅提供编译的脚本，更是在整 个项目周期中提供测试，发布，文档生成等功能，并且有着独特的依赖性管理方法。但是强大的功能的代价就是复杂的使用方法，第一次使用Maven往往需要将 近半个小时的时间（国内网速）来下载一个本地的依赖库，这无疑会使很多开发人员“知难而退”。虽然广受诟病，一个不争的事实就是Maven逐渐代替了 Ant，使用Maven也成了Java开发人员的一个必要技能。 2. IntelliJ IDEA 与 Eclipse 在Java的世界里，Eclipse毋庸置疑是IDE中的王者，IntelliJ IDEA和NetBeans都只能生活在Eclipse的光环下。Eclipse的强大已经不用我多说了，但其实IntelliJ IDEA也是一个相当优秀的IDE，尤其体现在它的智能上。它的一个针对.Net的Clone产品ReSharper已经被越来越多的C#开发者所接受。 IntelliJ IDEA提供了大量的智能规则来协助开发者，类似代码补全，用法的转换，格式的提示等等，当你习惯以后，你就会对那个小灯泡爱不释手。 3. 选择 Maven + IntelliJ IDEA 的理由 之所以要选择IntelliJ IDEA，是因为Maven+Eclipse实在太难用了。Eclipse有两个Maven插件 m2eclipse 和 Eclipse IAM。但是由于Eclipse和Maven设计上的矛盾，这两个插件可能都达不到你想要的效果。m2eclipse 会把你所有类型的项目都视为Maven类型项目，这对于一个单纯的Java项目或许可以，对于一个JEE或者WEB项目都是一场灾难。Eclipse IAM 并不会改变你的项目类型，但是他提供的功能也就仅仅限于编辑和运行POM文件了，甚至连依赖性都管理不了。相比之下，如果你非要用Eclipse的话我还 是推荐你使用Eclipse IAM。Eclipse想要完美的支持Maven恐怕需要在底层设计上做一些改变，无论是代码规范，项目结构规范和依赖性管理上，都有着不可调和的矛盾。 显然，在这方面IntelliJ IDEA做的要好的多，以至于你很难说出对它的不满。 4. Maven + IntelliJ IDEA 的优势 一切都是Module： IntelliJ IDEA借鉴的Maven的概念，不在采取Eclipse里Project的概念，一切都是Module。无论是否使用Maven，你的项目都是一个独立 的Module。并且你可以混搭使用Maven Module和普通的Java Module，两者可以和谐共存。 支持Multi-module： 可以说Maven的项目结构设计是非常严格的，现实应用中你必须用到Parent-Child的模式。Eclipse由于不支持在一个Project上建 立Sub-Project，因此无论如何目前都不能实现。IntelliJ IDEA可以完美的实现这个设计，并且无论是Module属性里，还是彼此的依赖性上都不会出现问题。 更方便的生命周期操作： 比起Eclipse通通放进右键菜单的行为，IntelliJ IDEA有着单独的窗口可以完成Maven的操作。你可以针对不同Module进行 Clean Compile Package Install等操作，各个Plug-in的操作也一清二楚。 完美的依赖性管理： 由于Maven会把所有依赖的包放在本机的一个目录下，所以实际上是脱离Project本身存在的。IntelliJ IDEA引入了一个External Library的概念，所有的Maven依赖性都会放在这里，和项目自带的库区分开。并且Module之间会智能的判断，你不需要Maven Install来进行引用代码的更新。 动态更新： 每当Maven相关的设置更改时，例如修改了pom的依赖性，添加删除Module，IntelliJ IDEA会提示你进行更新。这种更新实际上就是运行了Maven，所以你不许要手动运行Maven Compile来进行更新，也不会像Eclipse里遇到莫名其妙的问题。 5. Maven 安装 到http://maven.apache.org/download.html 下载最新的Maven版本，我下载的版本为最新的apache-maven-3.0.4。推荐使用最新的Maven 3，因为比以前的Maven 2性能更好，而且完全兼容Maven 2。 下载好以后，解压到一个目录，我的目录为 D:\\apache-maven-3.0.4，接着配置Maven环境变量M2_HOME为你解压的目录，如下图新建M2_HOME变量并追加到Path后面： 如果要在CMD控制台运行Maven命令的话，还需要配置Jdk环境变量，因为我接下来的操作都是基于IntelliJ IDEA，所以就不用配置JDK环境变量。 6. Maven 与IntelliJ IDEA完美使用（基于IntelliJ IDEA 12） 打开IntelliJ IDEA，新建一个Maven项目，如下图，项目名称为mymaven 选择Maven模版 创建过程中，配置Maven主目录 创建好后的目录结构如下图，IDEA创建了src/main/resources（自动创建）、src/main/java（手动创建）、src/main/test（手动创建）、以及pom.xml文件（自动创建） 按照Maven约定，项目的主目录位于src/main/resources、src/main/java中，测试目录位于src/main/test 中，所以我们在最终打包项目的时候，只包含主目录代码，不会包含测试目录里的代码，而测试目录里的代码只会在测试时候用到。 最后pom.xml这个文件是我们Maven项目的核心文件，POM(Project Object Model，项目对象模型)定义了项目的基本信息，用于描述项目如何构建，声明项目依赖。 project：是xml文件的根元素，我们主要关心根元素下的子元素 modelVersion：定义了当前POM模型的版本，Maven 2 或Maven 3 只能是4.0.0 groupId：定义了项目属于哪个组，一般来说这个网网和公司或组织关联，比如说，你所在的公司为mycom.那就应该定义为com.mycom.mymaven，mymaven为项目名称 artifactId：定 义了当前Maven项目在组中的唯一id，例如HelloMaven这个项目，我则把他定义为hello-maven，还例如spring项目，他的 groupId为org.springframework，对于content项目来说artifactId则为spring-content，web项 目则为spring-web 最后我们使用IntelliJ IDEA来用Maven编译我们的代码，打开Maven Projects菜单，如图，选中clean、compile并右键点击Run \u0026lsquo;hello-maven[clean,compile]\u0026lsquo;按钮即可。 根据输出结果我们看到，clean命令让Maven先清理target目录，Maven一般认为项目的输出目录为target，然后执行resource任务，现在为定义项目资源，所以暂时略过，最后执行编译任务！ "],["生活习惯的不同，造就了丰富多彩的世界","2016年08月08日","/2016/nihonsekaku/","にほんのライフスタイルに 不喜欢用蓝色圆珠笔。蓝色圆珠笔只在作标记的场合使用。 香烟吸一半就扔掉。有的人烟瘾大，吸两个半支烟，而不是吸一个整支。 日本人不太在意姓的意思。在中国人看来日本人的姓稀奇古怪。一次我去开会签到，抬头一看接待小姐的姓是“我孙子”。还有人姓厕所（御手洗）。很多姓是地名，“大阪”“名古屋”“涩谷”都见过。还有四个字的姓，如最近的丑闻作曲家姓“佐村河内”。 日本人不忌讳鬼、地狱、幽灵。含“鬼”字的地名有很多，叫“地狱”的拉面店也见到过。 不把跪着视为低人一等。因为跪着比蹲着省力，经常看到日本人跪着工作。例如，在没有椅子的时候，跪着操作电脑，高度正好。 如果第二天下午开会，日本人前一天晚上就不吃韭菜了。 如果感冒了，一定带口罩，即使不是流行性感冒也怕别人忌讳。 不使用非常浓的香水。无香料的化妆品很受欢迎。 不会打听别人的衣服、物品多少钱买的。 不会和别人勾肩搭背，即使是好朋友。 女士吃面包点心时，用手掰下一块放到嘴里，不会直接咬。（可能认为这样吃比较体面。） 吸烟时不劝烟，聚餐时不劝酒，更不会把人灌醉。 不轻易把谁称为自己的朋友，交往了几十年还把对方称为“知人”。对自来熟，刚见面就称朋友的人不喜欢。 不会轻易触摸别人的肌肤，即使是同性。对拉拉手的亲热和拍拍肩的关心不接受。 不打听别人的家事，更不要说隐私。在一起工作十几年，不知道对方有几个兄弟姐妹。福原爱在接受日本媒体的采访时说，中国记者什么都问，问得直想哭。 不轻易交换电话号码。我们公司的部长课长之间，甚至也有不知道对方电话号码的人。 日本人的胃口很小，初到日本的中国留学生（男生）在学校食堂一份定食大部分吃不饱。 在工作场合绝不穿张扬的服装。一般60岁以上的人开始穿红色的花的衣服。 工作场合不可吃东西，但可以吃水果糖。 工作时间不可接私人电话。个人不能使用公家电话打出去，也不能打进来。 私人的信件和物品不能寄到公司。 在家里高声说话，邻居会到家中提出警告。 泡温泉以前要先洗净身子。 如果你送给日本人点心，对方说真好吃。千万不要信以为真，是真是假得在其他的场合验证。 日本的绿茶泡一分钟就可以喝。 把手插到衣服裤子口袋里，被认为是对对方不尊敬。张艺谋拍的《千里走单骑》电影里的女日语翻译，很多场面把手放在口袋里，感觉不舒服。 日本人没有抱肘的习惯，认为这个姿势显示傲慢。 行人过马路遇到红灯必停，即使绿灯侧没有车。本人这种情况走过，被旁边的车“嘀”过。日本人说，这样做的目的是，告诉孩子，有法必依。 开车时，后灯双闪，是表示对后车的感谢。常在别人给让路后使用。 对面的车前灯瞬闪，表示给你让路。 公司业务关系新年拜年，带的礼品基本就是两条毛巾。 公司来两伙客人，一方是得到工作的上家，一方是外协的下家，在一个接待室谈话。只给上家上茶，下家没有。 公司来客，不管是什么工作关系，到吃饭时间基本都不提供午饭。 工作中出现差错，再好的朋友都不会说一句同情的话。有再多的客观原因也没人体谅。如果争辩解释，被认为错上加错。 企业一般都有自己的日历，根据客户的日历制定，国家法定假日常常有不休息的时候。 企业的年假，日本人一般不休，很少利用年假去旅游。 日本人工作比较配合，部门之间扯皮的事很少。 日本人的习惯是报忧不报喜，看电视听领导讲话，没有大好形势。 日本的电视广告很好看，没有太长时间的广告，幽默让人不厌倦。例，一个美女到动物店说想买一条狗，两只老虎，三头狮子。旁边的顾客惊得把手包都掉到了地上。店主问为什么，她说，单身女子在家害怕，每个房间都要有猛兽守卫。这时画外音，有比这还安全的，“家用电子警备系统”。 日本不光小孩看漫画，动画片，大人也很爱看。 店铺开业，门前摆放的祝贺物品，简直就可以说是中国追悼会上的花圈。 传统文化节，很多人穿的衣服上印着“祭”字。在日本，“祭”字的意思是文化节。 日本的医院对消炎药的使用严格控制，但相对而言，对激素的使用比较放松。 "],["yargs插件的使用，node.js 命令行框架 yargs 和你的程序实现交互","2016年08月08日","/2016/npmyargs/","如何让你的node.js 应用程序像shell 脚本一样和你交互?没错，就是yargs。 一、使用场景 大概有一种情况你需要让你的程序接收一个参数,通过这个参数我们做一系列的定制化功能. 常见的做法是 把一些不同环境不同配置的变量写到 config 配置文件中. 当你的环境变化的时候,你手动去修改你的config 中的变量来达到不同环境显示定制化的东西. 更具象的一个例子: config文件中有一个配置项 langue 当你发布国内站点的时候,你需要配置成 langue=\u0026ldquo;zh-cn\u0026rdquo; 当你发布国外站点的时候,你需要配置成 langue=\u0026ldquo;en\u0026rdquo; 现在, yargs 的功能就是帮你实现类似上面这种定制化的参数功能. 从此一些简单定制参数可以彻底摆脱 config 配置了. 比如: 你的node.js 启动文件是 app.js 当你部署中文环境站点的时候,就可以这样 node app.js \u0026ndash;l zh-cn 英文网站部署时 node app.js \u0026ndash;l en 当然上面输入给启动文件的 -l 参数,你是可以在 app.js 文件中获取,然后对应加载你需要定制化的东东即可. 上面我们只是介绍它的作用,以及一个具体的例子让大家明白什么时候使用.下面开始介绍如何使用: 二、使用 1.安装 2. 定义命令交互参数: 3. 使用 4. 接收参数 上面我们通过 argv 获取 \u0026ndash;l 参数来判断当前要运行哪个环境. 然后使用全局变量 global.langue 来标识当前运行环境. 在后面的所有个性化定制处我们都可以直接使用全局变量 global.langue 来做判断. "],["javascript设计模式","2016年07月07日","/2016/javascriptdesignpattern/","设计模式是一套反复使用的、思想成熟、经过分类和无数实战总结出来的。使用设计模式是为了让代码可重用、可扩展、可解藕、更容易让人理解并且有保证代码的可靠性。设计模式能够真正工程化，设计模式是软件工程的基石脉络，如同大厦的结构一样。只有夯实基础结构，才能盖好健壮的大楼。 也是我们迈向高级开发人员必经的一步。 一、设计原则 1. 开闭原则 对扩展开发，对修改关闭。 2. 里氏替换原则 子类继承父类，但单独调用完全可以运行。 3. 依赖倒转原则 引用一个对象，如果这个对象有低层类型，直接引用低层。 4. 接口隔离原则 每一个接口应该是一种角色。 5. 合成/聚合复用原则 新的对象应使用一些己有的对象，使之成为新对象的一部分。 6. 迪米特原则 一个对象在对其他对象尽可能少的了解。 二、 设计模式 1. 原型模式 概念：和javascript的prototype不同 prototype是指原型实例(new)指向创建对象的种类，并且通过拷贝这些原型创建新的对象。如克隆 作用： 原型对象本身就是有效的利用了每个构造器创建的对象 注意事项： 注意深拷贝和浅拷贝，以免出现引用问题。 代码实战和总结： Object.create(prototype,optionalDescriptorObjects) 2. 策略模式 概念： 策略模式定义了算法家族，\u0008分别封装起来，让它们之间可以相互替换，此模式让算法的变化不会影响到使用算法的客户。（目标一致，顺序不同，例如：田忌赛马） 作用： 所有的这些算法都是做相同的事情，只是实现不同。 以相同的方法调用所有的方法，减少了各种算法在和使用算法类之间的耦合。 单独定义了算法类，也方便单元测试。 注意事项： 不仅可以封装算法，也可以封装几乎任何类型的规则，是要在分析过程中需要在不同时间应用不同的规则， 可以考虑使用策略模式 代码实战和总结 3. 组合模式 概念： 作用： 注意事项： 代码实战和总结： 4. 外观模式 概念： 作用： 注意事项： 代码实战和总结 5. 迭代器模式 概念： 作用： 注意事项： 代码实战和总结 6. 命令模式 概念： 作用： 注意事项： 代码实战和总结 7. 代理模式 概念： 作用： 注意事项： 代码实战和总结 8. 适配器模式 概念： 作用： 注意事项： 代码实战和总结 9. 责任链模式 概念： 作用： 注意事项： 代码实战和总结 10. 工厂模式 概念： 作用： 注意事项： 代码实战和总结 11. 单例模式 概念： 作用： 注意事项： 代码实战和总结 12. 观察者模式 概念： 作用： 注意事项： 代码实战和总结 13. 中介者模式 概念： 作用： 注意事项： 代码实战和总结 14. 装饰者模式 概念： 作用： 注意事项： 代码实战和总结 15. 建造者模式 概念： 作用： 注意事项： 代码实战和总结 16. 构造函数模式 概念： 作用： 注意事项： 代码实战和总结 "],["5年学习计划","2016年07月07日","/2016/2016studyplan/","2015年，软件开发界发生了很多变化。有很多流行的新语言发布了，也有很多重要的框架和工具发布了新版本。下面有一个我们觉得最重要的简短清单，同时也有我们觉得值得你在2016年花时间精力去学习的新事物的一些建议。 一、开发工具 1. atom Atom 代码编辑器支持 Windows、Mac、Linux 三大桌面平台，完全免费，并且已经在 GitHub 上开放了全部的源代码。在经过一段长时间的迭代开发和不断改进后，Atom 终于从早期的测试版达到了 1.0 正式版了！相比之前的版本，在性能和稳定性方面都有着显著的改善。 2. idea IDEA 全称IntelliJ IDEA，是java语言开发的集成环境，IntelliJ在业界被公认为最好的java开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE支持、Ant、JUnit、CVS整合、代码审查、 创新的GUI设计等方面的功能可以说是超常的。IDEA是JetBrains公司的产品，这家公司总部位于捷克共和国的首都布拉格，开发人员以严谨著称的东欧程序员为主。 3. eclipse 虽然用上了IDEA之后再也不想回到eclipse。虽然它恶心，但是它毕竟伴随了很多程序员大部分时间，给点最起码的尊重。 4. lodash lodash一开始是Underscore.js库的一个fork，因为和其他(Underscore.js的)贡献者意见相左。John-David Dalton的最初目标，是提供更多“一致的跨浏览器行为……，并改善性能”。之后，该项目在现有成功的基础之上取得了更大的成果。最近lodash也发布了3.5版，成为了npm包仓库中依赖最多的库。它正在摆脱屌丝身份，成为开发者的常规的选择之一。 5. fetch 对于 AJAX，现在一般都是使用各种框架实现，其本质是 XMLHttpRequest。使用过原生XMLHttpRequest的人都知道，这种方法实现起来不太方便。现在，我们有了新的选择：Fetch API。 6. Electron Electron 框架的前身是 Atom Shell，可以让你写使用 JavaScript，HTML 和 CSS 构建跨平台的桌面应用程序。它是基于io.js 和 Chromium 开源项目，并用于在 Atom 编辑器中。Electron 是开源的，由 GitHub 维护，有一个活跃的社区。最重要的是，Electron 应用服务构建和运行在 Mac，Windows 和 Linux。 二、javascript框架 1. angular2 跨平台开发 学习如何基于 Angular 构建应用程序，并复用代码和技能来构建适用于所有平台的应用。比如： Web 应用、移动 Web 应用、原生移动应用和原生桌面应用等。 速度与性能 通过 Web Worker 和服务端渲染，达到在如今 ( 以及未来）的 Web 平台上所能达到的最高速度。 Angular 让你有效掌控可伸缩性。基于 RxJS 、 Immutable.js 和其它推送模型，能适应海量数据需求。 美妙的工具 使用简单的声明式模板，快速实现各种特性。使用自定义组件和大量现有组件，扩展模板语言。在几乎所有的 IDE 中获得针对 Angular 的即时帮助和反馈。所有这一切，都是为了帮助你编写漂亮的应用，而不是绞尽脑汁的让代码“能用”。 2. react+redux React+Redux非常精炼，良好运用将发挥出极强劲的生产力。但最大的挑战来自于函数式编程（FP）范式。在工程化过程中，架构（顶层）设计将是一个巨大的挑战。要不然做出来的东西可能是一团乱麻。说到底，传统框架与react+redux就是OO与FP编程范式的对决。 3. jquery JQuery是继prototype之后又一个优秀的Javascript库。它是轻量级的js库 ，它兼容CSS3，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及后续版本将不再支持IE6/7/8浏览器。 三、node相关技术 1. npm NPM（node package manager），通常称为node包管理器。顾名思义，它的主要功能就是管理node包，包括：安装、卸载、更新、查看、搜索、发布等。 2. koa2 koa 是由 Express 原班人马打造的，致力于成为一个更小、更富有表现力、更健壮的 Web 框架。使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升错误处理的效率。koa 不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web 应用变得得心应手。 3. rxjs 是一组库使用可观察到的集合和阵列、演员风格组成，组成异步和基于事件的程序。 4. zonejs 在ng2的开发过程中，Angular团队为我们带来了一个新的库 – zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（thread-local storage: 线程本地存储）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。 四、设计模式 1. javascript设计模式 2. java设计模式 五、编程语言 1. javascript JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。 2. ecmscript6 ES6是继ES5之后的一次主要改进，语言规范由ES5.1时代的245页扩充至600页。ES6增添了许多必要的特性，例如：模块和类，以及一些实用特性，例如Maps、Sets、Promises、生成器（Generators）等。尽管ES6做了大量的更新，但是它依旧完全向后兼容以前的版本，标准化委员会决定避免由不兼容版本语言导致的“web体验破碎”。结果是，所有老代码都可以正常运行，整个过渡也显得更为平滑，但随之而来的问题是，开发者们抱怨了多年的老问题依然存在。 3. typesript typescript是JavaScript的超集。TypeScript是JavaScript类型的超集，它可以编译成纯JavaScript。TypeScript可以在任何浏览器、任何计算机和任何操作系统上运行，并且是开源的。 4. java java是继c/c++使用最广泛的开发语言，写java真的是越写越觉得舒服。java生态环境十分良好，有大量优秀的开源框架以供选择。 1. spring Spring 是一个开源框架，是为了解决企业应用程序开发复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许您选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。 2. struts2 Struts2框架是一个轻量级的MVC流程框架，轻量级是指程序的代码不是很多，运行时占用的资源不是很多，MVC流程框架就是说它是支持分层开发，控制数据的流程，从哪里来，到那里去，怎么来，怎么去的这样一个框架 3. hibernate hibernate是轻量级JavaEE应用的一个持久层框架。它的作用在于管理Java实体类到数据库表之间的映射关系，并且提供数据查询和获取数据的方法，可以大幅度的缩短使用JDBC处理数据持久化的时间。 4. mybatis 一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAO），同时还提供一个利用这个框架开发的 JPetStore实例 5. springMVC Spring MVC框架是有一个MVC框架，通过实现Model-View-Controller模式来很好地将数据、业务与展现进行分离。从这样一个角度来说，Spring MVC和Struts、Struts2非常类似。Spring MVC的设计是围绕DispatcherServlet展开的，DispatcherServlet负责将请求派发到特定的handler 6. Play Framework 有别于其他臃肿的企业级 Java 框架，简洁的 Play 框架提供另外一种选择，它关注于开发者的效率和 RESTful 风格的架构。Play 是 敏捷软件开发的完美伴侣。 六、数据存储 1. mysql MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下公司。MySQL 最流行的关系型数据库管理系统，在 WEB 应用方面MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。 2. mongodb MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。 3. redis Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 4. cookie Cookie，有时也用其复数形式Cookies，指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密） 5. access token Windows操作系统安全性的一个概念。一个访问令牌包含了此登陆会话的安全信息。当用户登陆时，系统创建一个访问令牌，然后以该用户身份运行的的所有进程都拥有该令牌的一个拷贝。该令牌唯一表示该用户、用户的组和用户的特权。系统使用令牌控制用户可以访问哪些安全对象，并控制用户执行相关系统操作的能力。有两种令牌：主令牌和模拟的令牌。主令牌是与进程相关的；模拟的令牌是与模拟令牌的线程相关的。 七、html5+css3 1. html5 HTML5是HTML最新的修订版本，2014年10月由万维网联盟（W3C）完成标准制定。 HTML5的设计目的是为了在移动设备上支持多媒体。 HTML5 简单易学。 2. canvas html5中 标签用于绘制图像（通过脚本，通常是 JavaScript）。不过， 元素本身并没有绘制能力（它仅仅是图形的容器） - 您必须使用脚本来完成实际的绘图任务。getContext() 方法可返回一个对象，该对象提供了用于在画布上绘图的方法和属性。 3. css3 CSS3是CSS技术的一个升级版本，是由Adobe、Systems、Apple、Google、HP、IBM、Microsoft、Mozilla、Opera、Sun Microsystems 等许多WEB界的巨头联合组织的一个名为 “CSS Working Group” 的组织共同协商策划的。虽然目前很多细节还在讨论之中，但它还是不断地朝前发展着。2010年在HTML5成为IT界人士关注的焦点的同时，它也开始慢慢地普及开来。 4. sass SASS是一种CSS的开发工具，提供了许多便利的写法，大大节省了设计者的时间，使得CSS的开发，变得简单和可维护。 5. 白鹭引擎 白鹭引擎是一个开源的、跨平台的手机游戏开发引擎,你可以快速地创建HTML5类型的移动游戏,也可以将游戏项目编译输出成为目标移动平台的原生游戏应用。 八、算法和数据结构 1. 线型查找 在一列给定的值中进行搜索，从一端开始逐一检查每个元素，直到找到所需元素的过程。线性查找又称为顺序查找·如果查找池是某种类型的一个表，比如一个数组，简单的查找方法是从表头开始，一次将每一个值与目标元素进行比较，最后，或者查找到目标，或者达到表尾，而目标不存在于组中，这个方法称为线性查找。 2. 二分查找 二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好；其缺点是要求待查表为有序表，且插入删除困难。因此，折半查找方法适用于不经常变动而查找频繁的有序列表。首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。 3. 冒泡排序 冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 4. 选择排序 选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面）。 5. 插入排序 插入排序的基本思想是：每步将一个待排序的纪录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。 6. 字符串反转 7. 搜索算法 搜索算法是利用计算机的高性能来有目的的穷举一个问题解空间的部分或所有的可能情况，从而求出问题的解的一种方法。搜索算法实际上是根据初始条件和扩展规则构造一棵“解答树”并寻找符合目标状态的节点的过程。 8. 贪心算法 贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。 9. tween算法 Flash做动画时会用到Tween类，利用它可以做很多动画效果，例如缓动、弹簧等等。 10. javascript算法库 numbers.js Numeric Javascript Tangle accounting.js 九、测试框架 1. mocha mocha 是一个简单、灵活有趣的 JavaScript 测试框架，用于 Node.js 和浏览器上的 JavaScript 应用测试。Mocha 是具有丰富特性的 JavaScript 测试框架，可以运行在 Node.js 和浏览器中，使得异步测试更简单更有趣。Mocha 可以持续运行测试，支持灵活又准确的报告，当映射到未捕获异常时转到正确的测试示例。 2. karma Karma是Testacular的新名字，在2012年google开源了Testacular，2013年Testacular改名为Karma。Karma是一个让人感到非常神秘的名字，表示佛教中的缘分，因果报应，比Cassandra这种名字更让人猜不透！Karma是一个基于Node.js的JavaScript测试执行过程管理工具（Test Runner）。该工具可用于测试所有主流Web浏览器，也可集成到CI（Continuous integration）工具，也可和其他代码编辑器一起使用。这个测试工具的一个强大特性就是，它可以监控(Watch)文件的变化，然后自行执行，通过console.log显示测试结果。 3. jasmine Jasmine （茉莉）是一款 JavaScript BDD（行为驱动开发）测试框架，它不依赖于其他任何 JavaScript 组件。它有干净清晰的语法，让您可以很简单的写出测试代码。对基于 JavaScript 的开发来说，它是一款不错的测试框架选择。 4. chai Chai 是一个针对 Node.js 和浏览器的行为驱动测试和测试驱动测试的诊断库，可与任何 JavaScript 测试框架集成。 5.Qunit 该框架诞生之初是为了jquery的单元测试，后来独立出来不再依赖于jquery本身，但是其身上还是脱离不开jquery的影子 6. should.js: TJ的另外一个开源贡献 7. expect.js BDD风格的另外一个断言库，基于should.js,是mini版的BDD库 8. assert node自带核心模块: 可以在node中使用的断言模块 十、重构 1. 命名 模块划分和命名空间 2. 加载 js的动态加载 3. 测试 Javascript的测试 4. 编码 Javascript编码规则 5. 闭包 利用原型/闭包开发组件 6. 继承 利用继承来做事 7. 重用 重用老代码 8. 检测 JSDoc和JSLint 9. 框架 自定义JavaScript产品框架 10. 强化 强化对象封装和模块封装 "],["几个国内专用的公共 DNS","2016年06月06日","/2016/publicdns/","　之前 有个网站 自己经常上不去，查了挺久才发现是 DNS 的问题，更换为公共 DNS 后访问恢复正常。由此可见，挑选一个合适自己网络的 DNS 还是挺有必要的。 DNS 简介 DNS 全称 ，中文译为 ，是因特网的一项服务，其域名服务器的分布式数据库中存储着因特网上域名和 IP 地址相互映射的关系，经解析器解析，使用户能够通过域名来访问互联网。 114DNS 114.114.114.114 114.114.115.115 官　网：http://www.114dns.com/ 关键词：权威，高速，稳定，可靠，无劫持，防钓鱼，防病毒 阿里公共DNS 223.5.5.5 223.6.6.6 官　网：http://www.alidns.com/ 关键词：快速，稳定，智能 腾讯 Public DNS + 119.29.29.29 官　网：https://www.dnspod.cn/Products/Public.DNS 关键词：快速，准确，稳定 百度公共DNS 180.76.76.76 官　网：http://dudns.baidu.com/intro/publicdns/ 关键词：云防护，无劫持，更精确 oneDNS 南方首选：112.124.47.27 北方首选：114.215.126.16 官　网：http://www.onedns.net/ 关键词：安全，快速，恶意网站拦截，广告过滤，上网加速 CNNIC SDNS 1.2.4.8 210.2.4.8 **官　网：**http://public.sdns.cn/ **关键词：**权威，安全，智能，高速 DNS 选用 在线查询 可以通过 在线小工具 测试一下 DNS 的解析速度，结果可以作为参考 DNS Tool 本地优选 下载 魔方DNS助手 ，可以方便地检测，选择和修改 DNS DNS Helper 如果更换 DNS 后网络异常，可以尝试 刷新本地的DNS缓存 "],["linux权限详细解读","2016年06月06日","/2016/linuxchmod/","话说我接触linux也有近2年的时候了,而且有自己的linux服务器。感觉对linux的操作熟练程度还可以，但是基本知识还是有待提高，linux权限这一块有必要啃一啃了。 一、理论说明 Linux系统中的每个文件和目录都有访问许可权限，用它来确定谁可以通过何种方式对文件和目录进行访问和操作。 1. 权限说明 文件或目录的访问权限分为只读，只写和可执行三种。 以文件为例，只读权限表示只允许读其内容，而禁止对其做任何的更改操作。 可执行权限表示允许将该文件作为一个程序执行。 文件被创建时，文件所有者自动拥有对该文件的读、写和可执行权限，以便于对文件的阅读和修改。 用户也可根据需要把访问权限设置为需要的任何组合。 2. 用户组 有三种不同类型的用户可对文件或目录进行访问： 文件所有者， 同组用户 其他用户 所有者一般是文件的创建者。 所有者可以允许同组用户有权访问文件，还可以将文件的访问权限赋予系统中的其他用户。 在这种情况下，系统中每一位用户都能访问该用户拥有的文件或目录。 3. 文件权限 每一文件或目录的访问权限都有三组，每组用三位表示，分别为 文件属主的读、写和执行权限； 与属主同组的用户的读、写和执行权限； 系统中其他用户的读、写和执行权限。 当用ls -l命令显示文件或目录的详细信息时，最左边的一列为文件的访问权限。 4.实例分析 随意查看一个目录： 解读： 单个实例 详细解读(如果没有看懂建议回头看看理论说明1-3) 二、命令使用说明 1.格式(参数设定) 命令解读： 操作对象who可是下述字母中的任一个或者它们的组合： 操作符号可以是： 设置mode所表示的权限可用下述字母的任意组合： 2.权限设置(数字) 我们必须首先了解用数字表示的属性的含义： 三、其他命令 1. 命令 功能：改变文件或目录所属的组。 语法： 该命令改变指定指定文件所属的用户组。其中 可以是用户组ID，也可以是 文件中用户组的组名。文件名是以空格分开的要改变属组的文件列表，支持通配符。如果用户不是该文件的属主或超级用户，则不能改变该文件的组。 该命令的各选项含义为： 例1： 改变 及其子目录下的所有文件的属组为 。 2. 命令 功能：更改某个文件或目录的属主和属组。这个命令也很常用。例如root用户把自己的一个文件拷贝给用户xu，为了让用户xu能够存取这个文件，root用户应该把这个文件的属主设为xu，否则，用户xu无法存取这个文件。 语法： 说明： 将指定文件的拥有者改为指定的用户或组。用户可以是用户名或用户ID。组可以是组名或组ID。文件是以空格分开的要改变权限的文件列表，支持通配符。 该命令的各选项含义如下： 例1：把文件 的所有者改为 。 $ 例2：把目录/his及其下的所有文件和子目录的属主改成 ，属组改成 。 $ "],["阿里云服务器磁盘挂载","2016年06月06日","/2016/linuxdisk/","起因在于前段时间在阿里云上购买了一台ECS的云服务器，奈何硬盘20G不够用，所以又买了一块硬块。so,问题来了,磁盘挂载哪家强？最终还要靠自己！！ 一、基本信息 参考自阿里云服务器使用心得。 云服务器环境：CentOS 6.2 64位 客户端环境：Mac OSX 远程连接方式：运行 Terminal，输入命令 ssh username@ip 二、硬盘分区及挂载操作步骤 1. 查看未挂载的硬盘 （名称为/dev/xvdb） 输出 2. 创建分区 3. 格式化分区 执行命令： 4. 建立挂载目录 执行命令： 注意名字不要和原有磁盘上的重复 不然原有磁盘上的内容会被覆盖 5. 挂载分区 将磁盘挂载到刚建立的 目录中 6. 设置开机自动挂载 在vi中输入i进入INERT模式，将光标移至文件结尾处并回车，将下面的内容复制/粘贴，然后按Esc键，输入:x保存并退出 7. 确认是否挂载成功 重启服务器: 查看硬盘分区: 反馈信息 搞定！Mac 下通过 Terminal 远程操作 Linux 的感觉不错！ 四、 原文地址 aliyun-linux-fdisk "],["Markdown 表格样式调整与自适应优化","2016年06月06日","/2016/markdowntablestyle/","　Markdown 写的表格最终会被解析成 HTML 代码，如果使用的编辑器支持自定义 CSS，就能方便的调整样式。如果可以引入 JavaScript，样式自适应也能较好地实现。 See the Pen Table style by MOxFIVE (@MOxFIVE) on CodePen. 样式调整 基础概念 \u0026lt;table\u0026gt;: 表格 \u0026lt;thead\u0026gt;: table header 表头区 \u0026lt;th\u0026gt;: table headings 表头单元格内容 \u0026lt;tbody\u0026gt;: table body 表格内容区 \u0026lt;tr\u0026gt;: table row 表行 \u0026lt;td\u0026gt;: table data 单元格内容 基本样式 表头样式 隔行变色 使用选择器选取复数行设置背景色。一般 Markdown 表格编译后都有 包裹内容，那下面就相当于从表格第二行开始计数 悬浮变色 鼠标悬浮时该行改变背景色 自适应优化 表格用 Markdown 书写，编辑器解析，因而只能在已经生成好的代码上进行自适应优化。 表头不换行 设置表头单元格内容不换行，这样可以通过表头控制该列的最小宽度，避免浏览器窗口缩小时内容被压缩得太紧 首列不换行 表格第一列单元格内容不换行，多数情况下表格首列不应该被压缩换行 表格滚动条 添加 JavaScript 代码，用一个 把表格包裹起来，父元素宽度不足时显示横向滚动条，避免表格撑破布局 jQuery 同时添加如下 CSS To be added "],["gulp构建工具的使用","2016年06月06日","/2016/gulpuse/","先前学习了webpack,但是总是感觉webpack略显复杂，并且现在很多公司gulp工作流用的比较多，因此就入gulp的坑来踩一踩，技多不压身，霍霍霍\u0026hellip;。 一、简介(增强和使你的工作自动化) 1. 使用简单 没有繁琐的配置，一个任务一个task。通过代码优于配置的策略，Gulp 让简单的任务简单，复杂的任务可管理。 2. 高效 利用node强大的工作流，快速的构建项目并减少频繁的 IO 操作。 3. 高质量 gulp生态圈有相当多优秀的插件以供我们使用，Gulp 严格的插件指南确保插件如你期望的那样简洁高质得工作。 4. 易学 通过最少的 API，掌握 Gulp 毫不费力，构建工作尽在掌握：如同一系列流管道。 二、gulp相关api 1. : 来源 2. : 目标 3. : 管道 4. : 热加载 5. : 任务 6. (\u0026lsquo;default\u0026rsquo;) 默认任务,必须存在 三、使用(工作流程) 1. 全局安装gulp 2. 建立项目 3. 初始化项目 (会生成package.json) 4. 安装项目依赖 创建配置文件 6. gulp常用的功能 转码（ ）、合并（ ）、压缩（ ）、模块化（ ）、测试（gulp-jasmine），请依次安装这些依赖。 7. 小常识 因为国外的网站比较慢 npm经常会卡住。我们可以设置镜像源或使用 或者设置镜像源 8. 写配置 （gulpfile一定有一个default的任务，你可以把每个任务分文件书写然后再require进来，这种方式适合多人同时书写任务时，可以防止多人修改同一文件导致的冲突） 四、配置文件解读 1. 第一部分 一堆 ,是引用gulp相应的插件。在引用之前要确保己经安装。 2. 第二部分 几个 ,是定义任务名常量，有多几任务就定义多少常量。 3. 第三部分 几个 ,每个task对应一个任务，具有不同的功能。可以使用 来启动这个任务。 4. 第四部分 ,是执行 之后就会开始的任务 常用参数( )。 五、执行 如果要执行 任务，直接 如果想要执行单个任务，请输入 ,例如 六、gulp常见任务 1. 处理js （包括转码、合并、压缩） gulp-babel babel-preset-es2015 gulp-concat gulp-uglify 2. 处理scss (包括转码、合并、压缩) gulp-sass gulp-concat gulp-uglify 3. 处理less (包括转码、合并、压缩) gulp-less gulp-concat gulp-uglify 4. 测试 gulp-jasmine 5. 清理 gulp-clean 6. 热加载 gulp-util gulp-watch 7. debug gulp-print 8. sourceMap gulp-sourcemaps 9. 复制静态资源 10. 处理css雪碧图 gulp-css-spriter 11. 压缩css gulp-minify-css 12. 压缩图片 gulp-imagemin 13. 检查js gulp-jshint gulp-jshint 14. gzip压缩 gulp-gzip 15. 处理前缀 gulp-autoprefixer 七、项目地址 gulp-start-kit "],["前端工程化工具初选","2016年06月06日","/2016/frontendtools/","　面对日益纷杂的前端工具，作为新人常感无从下手。经过一番检索和简单对比，再结合自己的喜好，筛选了将要学习和使用的工具，以适应日益工程化、专业化的 Web 前端开发工作。 库与框架 jQuery jQuery UI : 一个JQuery的UI框架,特点是高效、组件化 Vue.js : 数据驱动的组件，为现代化的 Web 界面而生 angularjs 应用最广泛的企业级web开发框架 angular : 新一代angular开发框架 React.js : 构建组化件应用的javascript库 React Native : 使用react构建移动app应用 Flutter : 新一代跨平台移动框架 构建工具\u0026amp;模块化 一个构建、测试应用的构建工具 gulp.js : 自动化工作流 node 建立在V8引擎上的快速构建平台 模块打包器 将模块打包到一个bundle中 webpack : 能够将依赖打包、生成的自动构建工具 包管理 一个用来管理依赖的包管理器，你可以使用它下载很多模块化的工具 npm : Node 模块化管理工具 CSS 处理 提供一个高效、动态的方法生成css Stylus : node社区的css预处理器 PostCSS : 将css转换成js插件 模块化 ECMAScript 6 Module 模板引擎 使用js生成html文件 EJS jade 测试框架 Mocha : 一个简单、快速的用来测试node和web应用的测试框架 Chai : Chai 是一个针对 Node.js 和浏览器的行为驱动测试和测试驱动测试的诊断库，可与任何 JavaScript 测试框架集成。 脚手架 Yeoman Web 应用开发流程与工具 koa-generator koa项目生成器 集成方案 FIS : 解决前端开发中自动化工具、性能优化、模块化框架、开发规范、代码部署、开发流程等问题 UI框架 bootstrap 简洁、直观、强悍的UI框架，让web开发更迅速,后端程序的福音。 foundation 最流行的响应式前前端布局框架 semantic-ui Semantic作为一个开发框架，通过HTML语言帮助创建令人赏心悦目、响应式的布局。 Material UI 一组反应元件，实现谷歌的材料设计。 ant design Ant Design 是一个 UI 设计语言，是一套提炼和应用于企业级后台产品的交互语言和视觉体系。 游戏引擎 CreateJS 基于HTML5的一套模块化的库和工具共同工作或独立使丰富的交互式内容的开放式Web技术。 PhaserJS PC端和移动端HTML5游戏框架 。 ThreeJS 制作HTML5的3D游戏引擎 。 白鹭 Egret是一套HTML5游戏开发解决方案 Cocos2d-JS 开发者可以通过cocos游戏开发引擎快速编辑界面和动画、编写和调试代码等，最终导出适合于各平台、各渠道发布的游戏安装包。 容器 Docker : Build, Ship, and Run Any App, Anywhere 社区 stackoverflow 技术大牛多，素质好，质量高 segmentfault 自动生成目录，博客UI看起来相对漂亮 开源中国 支持开源文化 学习网站 汇智网 涉及面比较广,免费收费课程都有 极客学院 学习资源多,但比较泡面化 慕课网 质量高，但很多课程开始收费了 花川学院 学习swift的好去处 麦子学院 后起之秀 W3C菜鸟 新手程序员的天堂 云路课堂 极客风 极客时间 基本上都是收费课程,接受知识付费的用户应该会觉得很有收货 其他常用网站 github 程序员的QQ,面试的门面 码云 和马云同名，给个面子 淘宝同步npm 访问快，10分钟同步一次，查资料必备 bootCDN 使用最普遍的CDN font-awesome 最好用的图标库 JSON格式化 这个时代的开发者谁离得了JSON呢 开发工具 全面省心 "],["CSS font-family 网页字体使用小结","2016年06月06日","/2016/cssfontfamily/","前言一直到最近才开始调整博客的字体，之前都是全站微软雅黑了事。慢慢调整后发现 font-family 这个属性相关的知识还是不少的，整理一下常用的部分，分享于此。 基本用法 使用语法 语法说明 系统将选择列表中最先可用的字体来显示文字; 因为规则1，通常在最末添加一个 generic-family 字体系列名，保证文字获得相似的显示效果; 因为规则1，西文字体名应该写在中文字体前，这样才能中英文同时使用不同字体; 字体名为中文或包含空格等时，需要加双引号\u0026quot;\u0026ldquo;才能正确识别; 中文字体建议也是用其对应英文字体名，如\u0026quot;微软雅黑\u0026quot;为\u0026quot;Microsoft YaHei\u0026rdquo;，以提高编码兼容性。 常见字体系列 Serif 衬线字体 Times New Roman, Georgia 和宋体都是很常见的衬线字体； 特征: 文字笔划的开始或结束处有额外的装饰，笔划有粗细之分。 serif Sans-serif 无衬线字体 Arial, Verdana, Tahoma, 微软雅黑都是很常见的无衬线字体; 说明: 源于法语前缀，意思为 。Sans-serif 也就是指无衬线字体。 特征: 字体比较圆滑，笔划较为均匀。 sans-serif 字体选用: 有种说法是正文多用衬线字体，易于区分；标题多用无衬线字体。不过这个也看个人喜好，我更习惯正文用无衬线字体。如果实在不知道怎么选，随便找一个自己看着舒服的网站，套用它的字体样式好了。 Monospace 等宽字体 Courier New, Consolas, Menlo 都是比较常见的等宽字体; 特征: 字母、数字、空格以及其他符号所占宽度都一致。识别度高，易于对齐和定位，通常用于显示代码。 Monospace 一个优秀的代码字体除了等宽外，还应该能较好地区分出 等字符。 Cursive 手写体 Comic Sans, Author, 华文行楷都是比较常见的仿手写体; 特征: 模仿人的手写体，笔划圆滑或者有连笔等装饰。英文的花体，中文的行书草书等都属于此类。 cursive 获取字体名称 同一个字体在不同系统和应用中可能会显示为不同名字，但其内部一般有一个不变的英文名字。CSS font-family 需要引用的就是字体的内部名字。 本地字体 Win 上通过搜索或控制面板进入字体文件夹，然后双击字体查看字体名称; 通过软件，如记事本、Office 等也可以查看字体名字: font-a1 Mac 上搜索打开字体册即可，中间一栏显示的就是字体名称: font-a2 网页字体 审查元素，查看生效的 font-family: font-a3 通过 Chrome 插件 WhatFont : font-a4 字体图标 使用 引入字体后，可以像使用文字那样，无损的控制图标的大小，颜色等样式。常见的有 Webdings，Wingdings, Font Awesome . font-icon 备用记录 字体配置 下面是自己目前比较常用的字体配置，通常按系列设置为 CSS 预处理器的变量，方便调用。 字体英文名 一些常见中文字体的对应英文名。 - 中文名 英文名 1 苹方 PingFang SC 2 冬青黑/苹果丽黑 Hiragino Sans GB 3 思源黑体 Source Han Sans CN 4 华文细黑 STHeiti Light [STXihei] 5 华文黑体 ST Heiti 6 华文楷体 STKaiti 7 华文宋体 STSong 8 华文仿宋 STFangsong 9 丽黑 Pro LiHei Pro Medium 10 丽宋 Pro LiSong Pro Light 11 标楷体 BiauKai 12 苹果丽中黑 Apple LiGothic Medium 13 苹果丽细宋 Apple LiSung Light 14 新细明体 PMingLiU 15 细明体 MingLiU 16 标楷体 DFKai-SB 17 (中易)黑体 SimHei 18 宋体 SimSun 19 新宋体 NSimSun 20 仿宋 FangSong 21 楷体 KaiTi 22 仿宋_GB2312 FangSong_GB2312 23 楷体_GB2312 KaiTi_GB2312 24 微软正黑体 Microsoft JhengHei 25 微软雅黑 Microsoft YaHei 26 隶书 LiSu 27 幼圆 YouYuan 28 华文中宋 STZhongsong 29 方正舒体 FZShuTi 30 方正姚体 FZYaoti 31 华文彩云 STCaiyun 32 华文琥珀 STHupo 33 华文隶书 STLiti 34 华文行楷 STXingkai 35 华文新魏 STXinwei 36 文泉驿微米黑 Wenquanyi Micro Hei 37 文泉驿正黑 WenQuanYi Zen Hei 38 文泉驿点阵正黑 WenQuanYi Zen Hei Sharp 相关链接 Font Awesome: http://fontawesome.io/ Webdings和Wingdings字符码对应表: http://dwz.cn/2jOjYi CSS魔法堂：再次认识 font by 肥仔John on 2015/3/3: http://www.cnblogs.com/fsjohnhuang/p/4310533.html 有字库-中文在线字体: http://www.youziku.com/ 谈谈网页设计中的字体应用 (2) serif 和 sans-serif by 棕熊 on 2008/5/6: http://www.cnblogs.com/ruxpinsp1/archive/2008/05/06/font-in-front-end-development-2.html Serif 和 Sans Serif 字体的区别 by 冰火九九 on 2013/11/4: http://blog.jobbole.com/50828/ Chinese Web Font Guide by Kendra Schaefer on 2012/6/11: http://www.kendraschaefer.com/2012/06/chinese-standard-web-fonts-the-ultimate-guide-to-css-font-family-declarations-for-web-design-in-simplified-chinese/ Fonts.css \u0026ndash; 跨平台中文字体解决方案: http://zenozeng.github.io/fonts.css/ "],["nodejs爬虫项目实战","2016年06月06日","/2016/nodespider/","这篇文章主要介绍了NodeJS制作爬虫的全过程，包括项目建立，目标网站分析、使用superagent获取源数据、使用cheerio解析、使用eventproxy来并发抓取每个主题的内容等方面，有需要的小伙伴参考下吧。 一、 依赖 1. DOM操作 cheerio 2. 请求插件 request 3. http库 superagent 4. 代理 eventproxy 二、建立项目node-spider 1. 建立一个Koa2项目 2. 生成一个koa2的项目 -e表示使用ejs模板，具体参照[koa生成器,一键生成koa和koa2项目](http://localhost:4000/2016/05/26/2016-5-26-koa_generator/) 三、目标网站分析 如图，这是CNode首页一部分div标签，我们就是通过这一系列的id、class来定位我们需要的信息。 四、爬虫功能制作 1. superagent 是ajax API来使用的Http库，它的使用方法与jQuery差不多，我们通过它发起get请求，在回调函数中输出结果。 它的res结果为一个包含目标url信息的对象，网站内容主要在其text(string)里。 2. 使用cheerio解析 cheerio充当服务器端的jQuery功能，我们先使用它的.load()来载入HTML，再通过CSS selector来筛选元素。 其结果为一个个对象，调用 函数来遍历每一个对象，返回的是HTML DOM Elements。 输出 的结果为 输出 的结果为 。 再用 函数来补全完整的url。 3.使用eventproxy来并发抓取 教程上展示了深度嵌套(串行)方法和计数器方法的例子，eventproxy就是使用事件(并行)方法来解决这个问题。当所有的抓取完成后，eventproxy接收到事件消息自动帮你调用处理函数。 结果如下 获取留言用户名和积分 在文章页面的源码找到评论的用户class名，classname为reply_author。console.log第一个元素 $(\u0026rsquo;.reply_author\u0026rsquo;).get(0)可以看到，我们需要获取东西都在这里头。 首先，我们先对一篇文章进行抓取，一次性把需要的都得到即可。 我们可以通过 抓取积分信息 在用户信息页面 即为积分信息。 使用cheerio的函数.get(0)为获取第一个元素。 "],["package.json常用script","2016年06月06日","/2016/package.jsonscripts/","好的script能够大大减少我们对命令行的操作，直接使用npm run xxx 就可以执行。 一、git相关 1. 查看分支 , 2. 查看标签 , 3. 创建标签 , 4. 推送标签 , 5. 删除分支 , 6. 同步git : , 7. 推送更新 : , 8. 提交代码 : , 9. 检出代码 : , 10. 删除标签 , 11. 删除己合并分支 , 12. 删除所分支 , 13. 重命名分支 , 二、webpack相关 1. 清空目录 , 2. 构建项目 , 3. 启动项目 , 4. 测试代码 , 5. 检测测试 "],["npm模块分享","2016年06月06日","/2016/npmmodulesshare/","平时自己用的npm模块也不算少了，其实网上有很多牛人开发的npm模块都很好，希望不要被埋没了。 一、 实用的模块 1.thunder-vip 作用：获取最新可用的迅雷 vip 账号。 解决什么：不用每次打开网站去找号。。 用法： or 截图 1 2. npm-user-downloads npm-user-downloads 查看 npm 用户某个时间段内所有模块的下载量，按从高到低排名。 解决什么：起初是想看自己的那些模块下载量多，好重点维护。。 用法： 截图： 1 二、koa开发模块 1. co 作用：异步控制 1 栗子 2 如果你想把一个 co-generator-function 转成真实的functionu并返回一个promise 可以使用 3 完整的example 4 api 解决一个generator然后返回一个promise 将一个generator转成普通的function并返回一个promise 2、debug 使用方法 效果图 1 在windows环境下需要设置环境变量 我这里使用的是idea的debug调试 1 windows 下启动方式 1 将debug日志转存到文件中 3、koa-bodyparser 使用方法 在koa2中使用 4. koa-json 使用方法 4. koa-webpack-dev-middleware 使用方法 "],["mongodb数据库的使用","2016年05月05日","/2016/mongodbuse/","最近在学习node，听说node和mongodb更配哦。。所以我就来学习mongodb了 一、mongodb的开启和关闭 1. 查找mongod是否可用 2. 启动mongodb 指定path 和log日志 3. 关闭数据库 二、mongodb的操作 1. 连接服务器 2. 使用数据库 (不存在的数据库也可以使用,插入数据之后会自动保存) 3. 权限登陆 4. 展示数据库列表 5. 插入数据 (类似于mysql的表) 6. 查询集合 (前提是use了一个数据库) 有一个System.indexes 是索引 7. 不带条件查询 8. 带条件查询 (参数是一个对象) 9. 更新数据 (有三个参数,1:查询条件,2:更新的内容 3：更新的配置) 修改满足条件的第一条数据 修改所有满足条件的数据 10. 保存数据 (只有一个参数，必须要传id，后面是要修改的数据) 11. 删除数据 (1:条件 2 是否删除所有符合条件的) 12. 删除集合 三、使用mongoose操作数据库 1. 模块的介绍 连接mongdodb的驱动 2. 配置和链接 3. Model 和Shema 4. 创建文档 5. 删除文档 6. 简单查询 第一个满足条件的结果 7. 条件语句 三、在项目中使用mongoose 1. 生成项目 2. 安装依赖 3. 安装mongoose 4. 创建模型 5. 创建配置文件 6. 操作mongdodb 代码 "],["koa生成器,一键生成koa和koa2项目","2016年05月05日","/2016/koagenerator/","最近在学koa,想着express有生成器,那么koa应该也有。不出所料，经过我仔细上网排查,果然也有koa生成器。这对于想学koa，且规范的使用koa的朋友来说是一件多么让人开心的事情。 一、一键生成koa项目特性## Express-style Support koa 1.x（已支持） Support koa 2.x（已支持所有的koa中间件写法，依赖runkoa，不需要了解babel） 二、使用说明## 1. 准备工作 一定要全局安装(koa1.2和koa2都己经支持) koa1.2 生成一个test项目,切到test目录并下载依赖 koa2 生成一个test项目,切到test目录并下载依赖 运行 访问 http://localhost:3000 就可以看到项目效果 三、参数## 当然koa生成器功能没有这么弱啦,可以定制你想要的东西 四、项目地址## https://github.com/houko/node-koa 五、国际惯例-项目演示## 安装koa-generator 新建项目 运行项目 演示结束 koa生成器 查看大图 koa生成器 我的github地址 https://github.com/houko "],["nodejs框架koa学习","2016年05月05日","/2016/nodekoa/","Koa 是一个类似于 Express 的Web开发框架，创始人也都是TJ。Koa 的主要特点是，使用了 ES6 的 Generator 函数，进行了架构的重新设计。Koa 的原理和内部结构很像 Express，但是语法和内部结构进行了升级。 一、国际惯例 hello world## 1. 当前版本1.2 2. 代码撸起来 如此这般我们就创建了一个简单的http服务器。这段程序的作用是监听 8080 端口，当收到 GET 请求的时候，答复 hello xiaomo 你应该注意到了，我没有只用 var 关键词。我使用了 let 代替。在 ES6 中这基本上就是新的 var。这改变了变量的作用域，但是我不想在这里多说。 另一件事情有些奇怪，就是我们使用关键词 function*。这个星号表示这个函数是一个生成器函数。这意味着这个函数可以在运行的时候跳出然后再跳回来。这个概念很难去表述，所以我给你举个栗子。 我分解一下这个程序： inc 函数定义了一个生成器函数，在每一次 while 循环中，产出 number 变量然后 number 变量加 1 inc 函数被指派给了变量 test inc 函数被迭代了 3 次，第一次的时候，number 变量在函数中被初始化了。然后，这个函数进入到了一个 while 循环，在之后的迭代中这个循环也不会退出。然后 number 0 被产出，所以这个可以用 .value 方法接收。在后来的迭代中这个变量 number 自增了两次。 我希望这可以帮助理解一点生成器的工作原理。这只是非常复杂的 ES6 中的一小部分。 但是无论如何，让我们回到 koa。koa 非常简单，甚至不包含一个路由。你需要在中间件生成器函数中手动做路由匹配： 你可以看到，我们只要用 if 就可以做路由匹配了。你是不是很疑惑在这个上下文中的 this 是什么，express 中的 req 和 res 去哪里了。其实 this 绑定了大部分的 req 和 res 的函数和属性。如果你想知道更多关于 this 的详情，请点这里 。 让我们写一个将请求中的内容大写的中间件： 我的github地址 https://github.com/houko "],["javascript学习笔记","2016年05月05日","/2016/javascriptsyntax/","一直对javascript抱有敬畏的态度，也没有一直深入学习。当学到各种js框架的时候才发现力不从心，感觉到了javascript基础的重要性，重新认真的系统的学习一下。 一、一些不同 1. javascript没有块级作用域 于是es6中有了let和var 模拟js的块级作用域 2. javascript中this用法不同 它指向调用它的那个对象 3. 闭包是指有权访问另一个函数作用域中的变量的函数。 二、基本数据类型 、 、 、 、 、 、 它们有对应的方法 、 、 、 1. 没有被定义就会返回 ,是 衍生出来的,因些 返回true 2. 由于历史原因 返回 3. 非0返回true 0、null、undefined返回false 4. 不管传入什么都会原样返回,但如果是 ,会执行该方法并返回 //返回索引 //第一个参数支持正则 第二个参数也可以是一个function //支持正则，支持指定长度 它只有length属性 5. true=\u0026gt;1 false=\u0026gt;0 null=\u0026gt;0 undefined=\u0026gt;NaN 最大值 最小值 它是一个特例，不与任何值相等包括自己 //可以查找字符串中的数字并转换 //可以查找字符串中的数字并转换 //是否在最大值和最小值之间 说明：它能够识别科学计数法 比如 2.15e5 =\u0026gt; 215000 6. 构造函数 是否具有自己的方法 检查传入的对象是否是另一个对象的原型 检查给定的属性能否使用for-in 返回执行地区对应的对象的字符串 =\u0026gt;[\u0026lsquo;Object\u0026rsquo;] 返回执行对象的字符串 =\u0026gt;[\u0026lsquo;Object\u0026rsquo;] 返回对象序列化之后的结果 三、运算符 1. 大于和小于 //true,字符串的比较跟数字的比较不同 //false a会被转成NaN :NaN和任何数比都是false //false //false //false \u0026lsquo;23\u0026rsquo;会被转成23再与3比较 2. 全等和不全等 //true 不全等只判断值不判断类型 //false 全等不仅判断值还判断类型 四、条件控制语句 五、方法 注意：javascript和java不同，它没有重载,定义两个方法名相同的方法后面一个会覆盖前面一个。 六、检测类型 // 返回数据类型 七、引用类型 1. 声明对象的方法 赋值 使用对象的属性 2. 可以存任何类型 声明 添加对象 操作对象(删除、插入、替换) ：起始位置，要删除的个数 例子： //返回[1] 返回删除的那个数 ：起始位置、要删除的个数(0)、要插入的数,可以是多个,返回空数组 例子: ：起始位置、要删除的项目、要插入的任意项，可以是多个,返回被替换的值 例子: 其他数组操作 插入到数组的最后面 插入到数组的最前面 //删除数组的最后一个值 //删除数组第一个值 使用对象 数组自带的方法 反转数组 默认升序排列 传入排序方法会按照自定义排序 如果传入数组也会被展开拿出来,不会影响原数组 会把选定的部分截取出来生成一个新的数组，不会影响原数组 返回该值存在的下标,不存在返回-1 从倒数开始查找,返回该值存在的下标,不存在返回-1 对每个参数进行处理，全部符合返回true 对每个参数进行处理，有一个符合就返回true 对每个参数进行处理，返回过滤后的数组 对每个参数进行处理，返回处理后的数组 对每个参数进行处理，没有返回值 对每个参数进行处理，迭代返回最终结果 从右边对每个参数进行处理，迭代返回最终结果 3. Date类型 声明: 创建当前时间 也可以接收参数 // 6/13/2016 May 25,2016 或者 yyyy-MM-dd hh:mm:ss格式的 返回时间戳 // 将时间戳格式化为正常的时间 //也可以用逗号 2016-05-19 20:49:15 //当前时间的时间戳 //返回时间的字符串 星期、日、月、年 //时、分、秒、时区 特定时区的星期、日、月、年 特定时区的时、分、秒、时间 时间格式 4. 正则 RegExp类型 5. 方法　function 方法没有重载,如果是同名,不管参数个数是不是相同,后面定义的方法都会覆盖前面的方法 每个方法都包含两个属性: (参数个数)和 (原型链) 你可以不按正常顺序执行方法,因为在执行的时候 function都会被提前 但如果是立即执行的函数则不行 方法有两个特殊的内部属性和两个非继承来的方法 、 ,以及其他方法 和 是类数组,保存着参数。它有 方法 在javascript中用法比较特殊,它指向它的调用者 原型链 //encode字符串 //decode字符串 //解析字符串表达式 6. //e //10的自然对数 //以10为底e的对数 //PI //2的平方根 // 1/2的平方根 方法： //向上取整 //向下取整 //标准的四舍五入 // 0-1之间的数 //绝对值 八、面向对象的编程方法 工厂模式 构造函数(不用显式的创建对象，不用返回值，直接把属性赋给this) 判断类型 原型模式 九、定时器和延迟执行 十、BOM(浏览器相关) 1. 系统对话框 2. location对象 参数 3. navigator对象 检测浏览器属性 4. history对象 十一、表单 1. 表单属性 可以取到表单的所有控件 2. 控件 修改控件的值 选择文本 取得选中的文本 3. 剪贴板事件 EventUtil 自动切换焦点 4. 下拉框 select 5. 表单序列化 原则： 对表单字段的名字和值进行url编码,使用\u0026amp;分割 不发送禁用的表单字段 只发送勾选的单选按钮和复选框 不发送type为reset和button的按钮 多选框中的每选中的值单独一个条目 submit的时候,本按钮也会被提交 select发送的时候如果有value就发value的值 没有就发text内容 6. 富文本编辑器 只要加上 就可以让div可以编辑 也可以用js控制 十二、canvas 十三、html5脚本编程 十四、本地存储 1. cookie 使用util方法 2. localStorage "],["es6语法快速上手","2016年05月05日","/2016/es6syntax/","随着google和firefox以及node6.0对es6的支持，es6语法的定稿使它越来越受到关注，尤其是react项目基本上都是用es6来写的。是时候从es5到es6转变了 一、相关背景介绍 我们现在大多数人用的语法javascript 其实版本是ecmscript5,也是就es5。这个版本己经很多年了，且完美被各大浏览器所支持。所以很多学js的朋友可以一直分不清楚es5和javascript的关系。javascript是一门编程语言，那么它就会有版本，es5还是es6 就就是它的版本号。最新版es7己经在紧锣密布的进行中，它最新的语法会让我们写代码更新的行云流水。 二、babel 一个es6的解析器 在我们正式讲解ES6语法之前，我们得先了解下Babel。 Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。大家可以选择自己习惯的工具来使用使用Babel,我最喜欢的构建工具就是webpack。具体过程可直接在Babel官网查看： 三、语法 最常用的ES6特性 , , , , , , , , , 这些是ES6最常用的几个语法，基本上学会它们，我们就可以走遍天下都不怕啦！我会用最通俗易懂的语言和例子来讲解它们，保证一看就懂，一学就会。 1. 这两个的用途与 类似，都是用来声明变量的，但在实际运用中他俩都有各自的特殊用途。 首先来看下面这个例子： 使用 两次输出都是obama，这是因为ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。第一种场景就是你现在看到的内层变量覆盖外层变量。而 则实际上为 新增了块级作用域。用它所声明的变量，只在 命令所在的代码块内有效。 另外一个 带来的不合理场景就是用来计数的循环变量泄露为全局变量，看下面的例子： 上面代码中，变量i是var声明的，在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值。而使用let则不会出现这个问题。 再来看一个更常见的例子，了解下如果不用ES6，而用闭包如何解决这个问题。 我们本来希望的是点击不同的clickBox，显示不同的i，但事实是无论我们点击哪个clickBox，输出的都是5。下面我们来看下，如何用闭包搞定它。 也用来声明变量，但是声明的是常量。一旦声明，常量的值就不能改变。 当我们尝试去改变用const声明的常量时，浏览器就会报错。 const有一个很好的应用场景，就是当我们引用第三方库的时声明的变量，用const来声明可以避免未来不小心重命名而导致出现bug： 2. , , 这三个特性涉及了ES5中最令人头疼的的几个部分：原型、构造函数，继承\u0026hellip;你还在为它们复杂难懂的语法而烦恼吗？你还在为指针到底指向哪里而纠结万分吗？ 有了ES6我们不再烦恼！ ES6提供了更接近传统语言的写法，引入了Class（类）这个概念。新的class写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。 上面代码首先用 定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。简单地说，constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的。 之间可以通过 关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。上面定义了一个Cat类，该类通过extends关键字，继承了Animal类的所有属性和方法。 关键字，它指代父类的实例（即父类的this对象）。子类必须在 方法中调用 方法，否则新建实例时会报错。这是因为子类没有自己的 对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。 的继承机制，实质是先创造父类的实例对象 （所以必须先调用s 方法），然后再用子类的构造函数修改 。 P.S 如果你写react的话，就会发现以上三个东西在最新版 中出现得很多。创建的每个component都是一个继承 的类。详见react文档 3. 这个恐怕是ES6最最常用的一个新特性了，用它来写function比原来的写法要简洁清晰很多: 简直是简单的不像话对吧\u0026hellip; 如果方程比较复杂，则需要用 把代码包起来： 除了看上去更简洁以外， 还有一项超级无敌的功能！ 长期以来， 语言的 对象一直是一个令人头痛的问题，在对象方法中使用 ，必须非常小心。例如： 运行上面的代码会报错，这是因为 中的 指向的是全局对象。所以为了让它能够正确的运行，传统的解决方法有两种： 第一种是将this传给self,再用self来指代this 第二种方法是用bind(this),即 但现在我们有了箭头函数，就不需要这么麻烦了： 当我们使用箭头函数时，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，它的this是继承外面的，因此内部的this就是外层代码块的this。 4. 这个东西也是非常有用，当我们要插入大段的html内容到文档中时，传统的写法非常麻烦，所以之前我们通常会引用一些模板工具库，比如mustache等等。 大家可以先看下面一段代码： 我们要用一堆的\u0026rsquo;+\u0026lsquo;号来连接文本与变量，而使用ES6的新特性模板字符串``后，我们可以直接这么来写： 用反引号（\\）来标识起始，用${}`来引用变量，而且所有的空格和缩进都会被保留在输出之中，是不是非常爽？！ React Router 从第1.0.3版开始也使用ES6语法了，比如这个例子： 5. ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 看下面的例子： 用ES6完全可以像下面这么写： 反过来可以这么写： 6. , default很简单，意思就是默认值。大家可以看下面的例子，调用animal()方法时忘了传参数，传统的做法就是加上这一句type = type || \u0026lsquo;cat\u0026rsquo; 来指定默认值。 如果用ES6我们而已直接这么写： 最后一个rest语法也很简单，直接看例子： 而如果不用ES6的话，我们则得使用ES5的 。 7. 这两个家伙对应的就是 自己的 功能。 我们之前写的 一直都没有模块化的体系，无法将一个庞大的js工程拆分成一个个功能相对独立但相互依赖的小工程，再用一种简单的方法把这些小工程连接在一起。 这有可能导致两个问题： 一方面js代码变得很臃肿，难以维护; 另一方面我们常常得很注意每个script标签在html中的位置，因为它们通常有依赖关系，顺序错了可能就会出bug; 在es6之前为解决上面提到的问题，我们得利用第三方提供的一些方案，主要有两种CommonJS(服务器端)和AMD（浏览器端，如require.js）。 如果想了解更多AMD，尤其是require.js，可以参看这个教程 why modules on the web are useful and the mechanisms that can be used on the web today to enable them 而现在我们有了es6的module功能，它实现非常简单，可以成为服务器和浏览器通用的模块解决方案。 ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。 上面的设计思想看不懂也没关系，咱先学会怎么用，等以后用多了、熟练了再去研究它背后的设计思想也不迟！好，那我们就上代码\u0026hellip; 传统的写法 首先我们回顾下require.js的写法。假设我们有两个js文件: index.js和content.js,现在我们想要在index.js中使用content.js返回的结果，我们要怎么做呢？ 首先定义: 然后require: 那CommonJS是怎么写的呢？ ES6的写法 以上我把三者都列出来了，妈妈再也不用担心我写混淆了\u0026hellip; 8. ES6 module的其他高级用法 输出\\输入多个变量 上面可以看出，export命令除了输出变量，还可以输出函数，甚至是类（react的模块基本都是输出类） 这里输入的时候要注意：大括号里面的变量名，必须与被导入模块（content.js）对外接口的名称相同。 如果还希望输入content.js中输出的默认值(default), 可以写在大括号外面。 9. 修改变量名 此时我们不喜欢type这个变量名，因为它有可能重名，所以我们需要修改一下它的变量名。在es6中可以用as实现一键换名。 //index.js 10. 模块的整体加载 除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。 通常星号*结合as一起使用比较合适。 终极秘籍 考虑下面的场景： 上面的content.js一共输出了三个变量（default, say, type）,假如我们的实际项目当中只需要用到type这一个变量，其余两个我们暂时不需要。我们可以只输入一个变量： 由于其他两个变量没有被使用，我们希望代码打包的时候也忽略它们，抛弃它们，这样在大项目中可以显著减少文件的体积。 ES6帮我们实现了！ 不过，目前无论是webpack还是browserify都还不支持这一功能\u0026hellip; 如果你现在就想实现这一功能的话，可以尝试使用rollup.js 他们把这个功能叫做Tree-shaking，哈哈哈，意思就是打包前让整个文档树抖一抖，把那些并未被依赖或使用的东西统统抖落下去。。。 看看他们官方的解释吧： Normally if you require a module, you import the whole thing. ES2015 lets you just import the bits you need, without mucking around with custom builds. It\u0026rsquo;s a revolution in how we use libraries in JavaScript, and it\u0026rsquo;s happening right now. 希望更全面了解es6伙伴们可以去看阮一峰所著的电子书ECMAScript 6入门 "],["webpack进阶之loader篇","2016年05月05日","/2016/webpackllink/","webpack的loaders是一大特色，也是很重要的一部分。这遍博客我将分类讲解一些常用的laoder 一、loaders之 预处理 css-loader 处理css中路径引用等问题 style-loader 动态把样式写入css sass-loader scss编译器 less-loader less编译器 postcss-loader scss再处理 栗子: 二、loaders之 js处理 babel-loader jsx-loader 栗子 新建一个名字为 的文件 新建一个名字为 文件 三、loaders之 图片处理 url-loader 四、loaders之 文件处理 file-loader 五、loaders之 json处理 json-loader 六、loaders之 html处理 raw-loader "],["webpack进阶之插件篇","2016年05月05日","/2016/webpackplugins/","上一篇博客讲解了webpack环境的基本，这一篇讲解一些更深入的内容和开发技巧。基本环境搭建就不展开讲了 一、插件篇 1. 自动补全css3前缀 autoprefixer 官方是这样说的： ，也就是说它是一个自动检测兼容性给各个浏览器加个内核前缀的插件。 举个栗子：最新的弹性盒模型flux 实际代码： 插件自动补充后 效果显而易见，我们可以更专注于css布局和美化，而不需要花过多的精力都写相同的外码而加上不同的前缀，也减少了冗余代码。 使用方法: 2. 自动生成html插件 html-webpack-plugin 作用:它会在dist目录下自动生成一个index.html 其他配置参数: 作用： 3. 提取样式插件 extract-text-webpack-plugin 官网是这么解释的 ,把额外的数据加到编译好的文件中 说明：将css放到index.html的body上面 4. 拷贝资源插件 copy-webpack-plugin 官方这样解释 ,在webpack中拷贝文件和文件夹 作用：把public 里面的内容全部拷贝到编译目录 参数 作用 其他说明 from 定义要拷贝的源目录 from: __dirname + \u0026lsquo;/src/public\u0026rsquo; to 定义要烤盘膛的目标目录 from: __dirname + \u0026lsquo;/dist\u0026rsquo; toType 或者 可选，默认是文件 force 强制覆盖先前的插件 可选 默认false context 不知道作用 可选 默认 base context 可用 specific context flatten 只拷贝文件不管文件夹 默认是false ignore 忽略拷贝指定的文件 可以用模糊匹配 5. 全局挂载插件 webpack.ProvidePlugin [webpack内置插件 ] 作用: 和上面5个一一对应 二、一个完整的栗子 三、调试技巧 作用: 使用source-map可以在debug的时候看到源代码，方便 查错 "],["webpack相关命令参数","2016年05月05日","/2016/webpackparams/","使用webpack的同学，你真的熟练应用webpack么？其实直接 就可以看到，但是有很多人还是在网上到处搜相关参数 一、webpack相关参数 "],["nodejs的process模块","2016年05月05日","/2016/nodeprocess/","我们在使用webpack的时候经常会有两套配置，一套生产环境和一套测试环境。因此我们会用到一些系统变量，我们就需要用到process。process模块用来与当前进程互动，可以通过全局变量process访问，不必使用require命令加载。它是一个EventEmitter对象的实例。 一、process属性。 process.pid：当前进程的进程号。 process.version：Node的版本，比如v0.10.18。 process.platform：当前系统平台，比如Linux。 process.title：默认值为“node”，可以自定义该值。 process.argv：当前进程的命令行参数数组。 process.env：指向当前shell的环境变量，比如process.env.HOME。 process.execPath：运行当前进程的可执行文件的绝对路径。 process.stdout：指向标准输出。 process.stdin：指向标准输入。 process.stderr：指向标准错误。 下面是主要属性的介绍。 1. stdout process.stdout用来控制标准输出，也就是在命令行窗口向用户显示内容。它的write方法等同于console.log。 2. argv process.argv返回命令行脚本的各个参数组成的数组。 先新建一个脚本文件argv.js。 在命令行下调用这个脚本，会得到以下结果。 上面代码表示，argv返回数组的成员依次是命令行的各个部分。要得到真正的参数部分，可以把argv.js改写成下面这样。 3.方法 process对象提供以下方法： process.cwd()：返回运行当前脚本的工作目录的路径。_ process.chdir()：改变工作目录。 process.exit()：退出当前进程。 process.nextTick()：将一个回调函数放在下次事件循环的顶部。 process.chdir()改变工作目录的例子。 process.nextTick()的例子，指定下次事件循环首先运行的任务。 上面代码可以用setTimeout改写，但是nextTick的效果更高、描述更准确。 4. 事件 （1）exit事件 当前进程退出时，会触发exit事件，可以对该事件指定回调函数。这一个用来定时检查模块的状态的好钩子(hook)(例如单元测试),当主事件循环在执行完’exit’的回调函数后将不再执行,所以在exit事件中定义的定时器可能不会被加入事件列表. （2）uncaughtException事件 当前进程抛出一个没有被捕捉的意外时，会触发uncaughtException事件。 摘自阮老师博客 Node.js 概述 "],["使用nodejs搭建一个简易的即时聊天软件","2016年05月05日","/2016/nodeonlinechat/","最近在学习node，跟着书上的例子写的一个基于net模块的tcp服务器，感觉挺有意思在此分享一下。 一、搭建简易的服务器## 开启服务器 此时服务己经成功开启 二、客户端连接## 格式： 例如我在本地再开启一个shell窗口 Hi!127.0.0.1:43358,您己成功连接服务器，可以正常通讯了.. 三、测试效果 1. 开启服务器 2. 客户端连接 3. 测试通讯 下面是gif效果图 tcp在线聊天服务器 "],["angularjs复选框","2016年05月05日","/2016/ngcheckbox/","使用angularjs做复选框，这也是一个常见的需求。 一、代码 1. html 2. controller 二、效果图 checkbox效果图 三、参考文档 ZH奶酪：AngularJS判断checkbox/复选框是否选中并实时显示 四、 附上我github的地址 https://github.com/houko "],["angularjs复选框","2016年05月05日","/2016/ngcheckbox/"," 一、绑定键盘事件 （尤其注意：不能用a标签，不然会失效） 推荐button 方法一：ng内置指令 说明：在对应的控制器中的$scope上绑定一个todoSomething方法 方法二：自定义指令 html 指令 二、总结 两种方法都能实现敲回车登录的功能，不过推荐指令的方式，对$scope的污染比较低 参考文档：angularjs学习笔记—事件指令 "]]